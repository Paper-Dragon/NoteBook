{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction NoteBook By JokerDragon Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 11:32:06 "},"git/Git分支管理合并与删除命令.html":{"url":"git/Git分支管理合并与删除命令.html","title":"Git分支管理合并与删除命令","keywords":"","body":"Git分支 几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。而Git的分支模型则别具一格，创建分支非常的快，在不同分支之间切换也十分的快，这一优势也使得Git鼓励人们更多地使用分支。 Git保存数据的方式 在了解分支之前，让我们先来看看Git是如何保存数据的。我的理解是我们每次提交到Git的文件，它并不是只保存每次文件中的差异，而是类似于照片那样将整个文件都在重新保存一份 Git分支 Git 会把仓库中的每次提交串成一条时间线，这条时间线就是一个分支。在 Git 里，每个仓库都会有一个主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git 用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，如下图： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 Git分支创建 当我们创建新的分支，例如dev时，Git 新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上，如下图： 所以Git 创建一个分支很快，因为除了增加一个dev指针，改变HEAD的指向，工作区的文件则没有任何变化。 在创建完新的分支以后，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变，如下图： 具体创建分支命令如下 git branch dev //创建一个新的dev分支 git checkout dev //切换到该分支上 当然你也可以使用git checkout -b dev或者git switch -c dev创建dev并切换，相当于以上两条命令。最新版本的 Git 提供了新的git switch命令来切换分支，以便更好的与git checkout 进行区分。 创建好新的分支以后，当我们想查看新的分支时，可以使用 git branch 该命令会列出所有的分支，而当前分支前面会标一个*号。 在分支之间来回切换使用git switch master或者git checkout 分支名 Git的分支合并、删除 注意：当我们在dev分支提交修改的文件切换回主分支是查看不到的，此时如果想提交到主分支上去就需要合并分支。 Git分支合并非常的便捷，直接把master指向dev的当前提交，就完成了合并，只是改变了指针，工作区内容不变，合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。 我们合并分支可以使用git merge该命令用于合并指定分支到当前分支。 分支合并，Git一般 会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git 就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 我们可以使用 git merge --no-ff -m \"禁用Fast forward模式\" dev 来禁用Fast forward模式。合并后，我们用git log看看分支历史： 可以看到，不使用Fast forward模式，merge后就像这样： Git分支删除 使用命令 git branch -d dev Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-01 16:08:24 "},"git/git更新远程分支.html":{"url":"git/git更新远程分支.html","title":"git更新远程分支","keywords":"","body":"同事创建出新的分支后，我这边用sourcetree刷新，始终看不到最新的。上网查了一下，可以用命令刷新，刷新之后就可以看到新创建的分支了。 git remote update origin --prune 或者 git remote update origin -p Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 14:00:23 "},"JumperServer/":{"url":"JumperServer/","title":"Jumper Server","keywords":"","body":"JumperServer Insight Over View 开源：零门槛，线上快速获取和安装； 分布式：轻松支持大规模并发访问； 无插件：仅需浏览器，极致的 Web Terminal 使用体验； 多云支持：一套系统，同时管理不同云上面的资产； 云端存储：审计录像云端存储，永不丢失； 多租户：一套系统，多个子公司和部门同时使用； 多应用支持：数据库，Windows远程应用，Kubernetes。 Function List 注：带有 X-Pack 标识的功能为 JumpServer 堡垒机企业版功能。 身份验证 Authentication 登录认证 资源统一登录和认证；LDAP / AD 认证；RADIUS 认证；实现单点登录（OpenID 认证、CAS 认证）；SSO 对接；扫码登录（企业微信认证、钉钉认证和飞书认证）； 多因⼦认证 MFA 二次认证（Google Authenticator）； RADIUS 二次认证；短信（阿里云、腾讯云）二次认证；X-Pack 登录复核 用户登录 JumpServer 系统行为受管理员的监管与控制；X-Pack 登录限制 用户登录来源 IP 受管理员控制（支持黑 / 白名单）； 授权控制 Authorization 多维度授权 可对用户、用户组、资产、资产节点、应用以及系统用户进行授权； 资产授权 资产树以树状结构进行展示；资产和节点均可灵活授权；节点内资产自动继承授权；子节点自动继承父节点授权； 数据库授权 支持 MySQL数据库应用授权； 支持 Oracle、PostgreSQL、MariaDB 数据库应用授权；X-Pack 应用授权 实现更细粒度的应用级授权； Kubernetes 授权 支持用户通过 JumpServer 连接 Kubernetes 集群； RemoteApp 远程应用 针对 Windows 系统实现更细粒度的应用级授权，并对应用操作录像进行回放审计；X-Pack 动作授权 实现对授权资产的文件上传、下载以及连接动作的控制；支持剪切板复制 / 粘贴（Windows 资产）； 时间授权 实现对授权资源使用时间段的限制； 特权指令 实现对特权指令的使用，支持黑白名单； 命令过滤 实现对授权系统用户所执行的命令进行控制； 文件传输与管理 支持 SFTP 文件上传 / 下载；支持 Web SFTP 文件管理； 工单管理 支持对用户登录请求行为进行控制；支持授权工单申请；支持二级审批流程；X-Pack 组织管理 实现多租户管理与权限隔离；全局组织功能；X-Pack 访问控制 支持对通过 SSH 和 Telnet 协议登录的资产进行复核；X-Pack 账号管理 Accounting 集中账号管理 系统用户管理（包含普通用户和特权用户）； ⽤户⻆⾊ 支持超级管理员、超级审计员、普通用户三种角色； 支持超级管理员、超级审计员、组织管理员、组织审计员、普通用户五种角色；X-Pack 统⼀密码管理 资产密码托管；⾃动⽣成密码；密码自动推送；密码过期设置； 改密计划 资产和数据库定期批量修改密码；生成随机密码；多种密码策略；X-Pack 多云资产纳管 对私有云、公有云资产⾃动统⼀纳管；X-Pack 收集⽤户 ⾃定义任务定期收集主机⽤户；X-Pack 账号管理 统⼀对资产主机的⽤户密码进行查看、更新、测试等操作；X-Pack 安全审计 Auditing 登录审计 支持对用户登录到 JumpServer 系统的日志进行审计；支持将审计信息收集至 Syslog； 操作审计 用户操作行为审计； 会话审计 ⽀持在线会话内容审计；历史会话内容审计；支持会话水印信息； 录像审计 支持对 Linux、Windows 等资产操作的录像进行回放审计；支持对 RemoteApp X-Pack、MySQL、Kubernetes 等应用操作的录像进行回放审计；支持将录像上传至公有云； 指令审计 支持对资产和应用等操作的命令进⾏审计；高危命令告警； ⽂件传输审计 ⽀持对⽂件的上传 / 下载记录进⾏审计； 实时监控 支持管理员 / 审计员实时监控用户的操作行为，并可进行实时中断，以提升用户操作的安全性； Environment Requirement OS Version Linux Kerner Soft Requirement Linux Release >= 4.0 wget curl tar gettext iptables python 硬件配置：. 操作系统centos 7.8 Python = 3.6.x Mysql Server ≥ 5.6 Mariadb Server ≥ 5.5.56 Redis ↩ Databases DB Version Cache Version MySQL >= 5.7 Redis >= 5.0 MySql和Mariadb二选一 MariaDB >= 10.2 MySql和Mariadb二选一 Redis 缓存功能 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 06:56:38 "},"JumperServer/Docker_Deploy.html":{"url":"JumperServer/Docker_Deploy.html","title":"Docker Deploy","keywords":"","body":"二进制部署 环境展示和配置如下 [root@localhost ~]# cat /etc/redhat-release Rocky Linux release 8.5 (Green Obsidian) [root@localhost ~]# sed -i 's/SELINUX=.*$/SELINUX=disabled/g' /etc/selinux/config [root@localhost ~]# grep SELINUX /etc/selinux/config # SELINUX=disabled SELINUX=disabled # SELINUXTYPE= can take one of these three values: SELINUXTYPE=targeted [root@localhost ~]# setenforce 0 [root@localhost ~]# getenforce Permissive [root@localhost ~]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since Sat 2022-04-23 12:21:01 CST; 3min 39s ago Docs: man:firewalld(1) Main PID: 1011 (firewalld) Tasks: 2 (limit: 24736) Memory: 30.5M CGroup: /system.slice/firewalld.service └─1011 /usr/libexec/platform-python -s /usr/sbin/firewalld --nofork --nopid Apr 23 12:21:01 localhost.localdomain systemd[1]: Starting firewalld - dynamic firewall daemon... Apr 23 12:21:01 localhost.localdomain systemd[1]: Started firewalld - dynamic firewall daemon. Apr 23 12:21:01 localhost.localdomain firewalld[1011]: WARNING: AllowZoneDrifting is enabled. This is considered an insecure configuration option. It will be removed in a future release. Please consider di> [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# firewall-cmd --list-all public (active) target: default icmp-block-inversion: no interfaces: ens160 sources: services: cockpit dhcpv6-client ssh ports: protocols: forward: no masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@localhost ~]# 上传脚本 脚本实例 JumperServer\\others\\jumper_bin_deploy.sh #!/usr/bin/env bash # 因为使用了国外网络，实际使用仁者见仁 Version=v2.21.0 #版本 function install_soft() { if command -v dnf > /dev/null; then dnf -q -y install \"$1\" elif command -v yum > /dev/null; then yum -q -y install \"$1\" elif command -v apt > /dev/null; then apt-get -qqy install \"$1\" elif command -v zypper > /dev/null; then zypper -q -n install \"$1\" elif command -v apk > /dev/null; then apk add -q \"$1\" command -v gettext >/dev/null || { apk add -q gettext-dev python2 } else echo -e \"[\\033[31m ERROR \\033[0m] Please install it first (请先安装) $1 \" exit 1 fi } function prepare_install() { for i in curl wget tar; do command -v $i &>/dev/null || install_soft $i done } function get_installer() { echo \"download install script to /opt/jumpserver-installer-${Version} (开始下载安装脚本到 /opt/jumpserver-installer-${Version})\" cd /opt || exit 1 if [ ! -d \"/opt/jumpserver-installer-${Version}\" ]; then timeout 60 wget -qO jumpserver-installer-${Version}.tar.gz https://github.com/jumpserver/installer/releases/download/${Version}/jumpserver-installer-${Version}.tar.gz || { rm -rf /opt/jumpserver-installer-${Version}.tar.gz echo -e \"[\\033[31m ERROR \\033[0m] Failed to download jumpserver-installer-${Version} (下载 jumpserver-installer-${Version} 失败, 请检查网络是否正常或尝试重新执行脚本)\" exit 1 } tar -xf /opt/jumpserver-installer-${Version}.tar.gz -C /opt || { rm -rf /opt/jumpserver-installer-${Version} echo -e \"[\\033[31m ERROR \\033[0m] Failed to unzip jumpserver-installer-${Version} (解压 jumpserver-installer-${Version} 失败, 请检查网络是否正常或尝试重新执行脚本)\" exit 1 } rm -rf /opt/jumpserver-installer-${Version}.tar.gz fi } function config_installer() { cd /opt/jumpserver-installer-${Version} || exit 1 shopt -s expand_aliases if [[ $(uname) == 'Darwin' ]]; then alias sedi='sed -i \"\"' else alias sedi='sed -i' fi sed -i \"s/VERSION=.*/VERSION=${Version}/g\" /opt/jumpserver-installer-${Version}/static.env ./jmsctl.sh install ./jmsctl.sh start } function main(){ prepare_install get_installer config_installer } main 脚本运行过程 注意第23行，出现错误，这个是因为官方脚本不对，需要修改sed -i [root@localhost ~]# ls -l total 8 -rw-------. 1 root root 1154 Apr 23 12:20 anaconda-ks.cfg -rw-r--r--. 1 root root 2249 Apr 23 12:28 jumper_bin_deploy.sh [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# chmod +x jumper_bin_deploy.sh [root@localhost ~]# ls -l total 8 -rw-------. 1 root root 1154 Apr 23 12:20 anaconda-ks.cfg -rwxr-xr-x. 1 root root 2249 Apr 23 12:28 jumper_bin_deploy.sh [root@localhost ~]# ./jumper_bin_deploy.sh Importing GPG key 0x6D745A60: Userid : \"Release Engineering \" Fingerprint: 7051 C470 A929 F454 CEBE 37B7 15AF 5DAC 6D74 5A60 From : /etc/pki/rpm-gpg/RPM-GPG-KEY-rockyofficial Installed: libmetalink-0.1.3-7.el8.x86_64 wget-1.19.5-10.el8.x86_64 download install script to /opt/jumpserver-installer-v2.21.0 (开始下载安装脚本到 /opt/jumpserver-installer-v2.21.0) Redirecting output to ‘wget-log’. ./jumper_bin_deploy.sh: line 58: sedi: command not found ██╗██╗ ██╗███╗ ███╗██████╗ ███████╗███████╗██████╗ ██╗ ██╗███████╗██████╗ ██║██║ ██║████╗ ████║██╔══██╗██╔════╝██╔════╝██╔══██╗██║ ██║██╔════╝██╔══██╗ ██║██║ ██║██╔████╔██║██████╔╝███████╗█████╗ ██████╔╝██║ ██║█████╗ ██████╔╝ ██ ██║██║ ██║██║╚██╔╝██║██╔═══╝ ╚════██║██╔══╝ ██╔══██╗╚██╗ ██╔╝██╔══╝ ██╔══██╗ ╚█████╔╝╚██████╔╝██║ ╚═╝ ██║██║ ███████║███████╗██║ ██║ ╚████╔╝ ███████╗██║ ██║ ╚════╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚══════╝╚══════╝╚═╝ ╚═╝ ╚═══╝ ╚══════╝╚═╝ ╚═╝ Version: v2.21.0 1. Check Configuration File Path to Configuration file: /opt/jumpserver/config /opt/jumpserver/config/config.txt [ √ ] /opt/jumpserver/config/nginx/cert/server.crt [ √ ] /opt/jumpserver/config/nginx/cert/server.key [ √ ] complete >>> Install and Configure Docker 1. Install Docker Starting to download Docker engine ... Starting to download Docker Compose binary ... complete 2. Configure Docker Do you want to support IPv6? (y/n) (default n): n complete 3. Start Docker Created symlink /etc/systemd/system/multi-user.target.wants/docker.service → /etc/systemd/system/docker.service. ^C [root@localhost ~]# ^C [root@localhost ~]# ^C 作如下修改 function config_installer() { cd /opt/jumpserver-installer-${Version} || exit 1 shopt -s expand_aliases if [[ $(uname) == 'Darwin' ]]; then alias sedi='sed -i \"\"' else alias sedi='sed -i' fi sed - i \"s/VERSION=.*/VERSION=${Version}/g\" /opt/jumpserver-installer-${Version}/static.env ./jmsctl.sh install ./jmsctl.sh start } 如果因为网络问题可以多跑几次 [root@localhost ~]# ./jumper_bin_deploy.sh download install script to /opt/jumpserver-installer-v2.21.0 (开始下载安装脚本到 /opt/jumpserver-installer-v2.21.0) sed: -e expression #1, char 1: unknown command: `-' ██╗██╗ ██╗███╗ ███╗██████╗ ███████╗███████╗██████╗ ██╗ ██╗███████╗██████╗ ██║██║ ██║████╗ ████║██╔══██╗██╔════╝██╔════╝██╔══██╗██║ ██║██╔════╝██╔══██╗ ██║██║ ██║██╔████╔██║██████╔╝███████╗█████╗ ██████╔╝██║ ██║█████╗ ██████╔╝ ██ ██║██║ ██║██║╚██╔╝██║██╔═══╝ ╚════██║██╔══╝ ██╔══██╗╚██╗ ██╔╝██╔══╝ ██╔══██╗ ╚█████╔╝╚██████╔╝██║ ╚═╝ ██║██║ ███████║███████╗██║ ██║ ╚████╔╝ ███████╗██║ ██║ ╚════╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚══════╝╚══════╝╚═╝ ╚═╝ ╚═══╝ ╚══════╝╚═╝ ╚═╝ Version: v2.21.0 1. Check Configuration File Path to Configuration file: /opt/jumpserver/config /opt/jumpserver/config/config.txt [ √ ] /opt/jumpserver/config/core/config.yml [ √ ] /opt/jumpserver/config/koko/config.yml [ √ ] /opt/jumpserver/config/mariadb/mariadb.cnf [ √ ] /opt/jumpserver/config/mysql/my.cnf [ √ ] /opt/jumpserver/config/nginx/lb_http_server.conf [ √ ] /opt/jumpserver/config/redis/redis.conf [ √ ] /opt/jumpserver/config/nginx/cert/server.crt [ √ ] /opt/jumpserver/config/nginx/cert/server.key [ √ ] complete >>> Install and Configure Docker 1. Install Docker complete 2. Configure Docker Do you want to support IPv6? (y/n) (default n): complete 3. Start Docker complete >>> Loading Docker Image [jumpserver/redis:6-alpine] 6-alpine: Pulling from jumpserver/redis Digest: sha256:8300b885570faad626e569e7b8cfef3407c87050d705ff26e243200cb3f84da8 Status: Image is up to date for jumpserver/redis:6-alpine docker.io/jumpserver/redis:6-alpine [jumpserver/mysql:5] 5: Pulling from jumpserver/mysql Digest: sha256:b3b2703de646600b008cbb2de36b70b21e51e7e93a7fca450d2b08151658b2dd Status: Image is up to date for jumpserver/mysql:5 docker.io/jumpserver/mysql:5 [jumpserver/web:v2.21.0] v2.21.0: Pulling from jumpserver/web Digest: sha256:1fdbb613c610b1a9131d586716a98d8655fe7022b2ef9376aca35601b3f7a697 Status: Image is up to date for jumpserver/web:v2.21.0 docker.io/jumpserver/web:v2.21.0 [jumpserver/core:v2.21.0] v2.21.0: Pulling from jumpserver/core Digest: sha256:9d71ab8155c80f30af2c29ed4c93b738a2f05589259e5f3f06a111aaae8f44b8 Status: Image is up to date for jumpserver/core:v2.21.0 docker.io/jumpserver/core:v2.21.0 [jumpserver/koko:v2.21.0] v2.21.0: Pulling from jumpserver/koko a2abf6c4d29d: Already exists 2c1a7e91d4e4: Pull complete 96de146d0b8c: Pull complete b4f8dcc8c180: Pull complete d04025369df5: Pull complete ff7eca95c753: Pull complete 9ed1a3e05bfa: Pull complete 76f894474555: Pull complete f55ed9d8f2da: Pull complete 6754e6167f39: Pull complete 187761dc098e: Pull complete 3bc030919db1: Pull complete Digest: sha256:32636524d6395ef645dc931cebd83f1617417786f32ef7537d07d14920ce7454 Status: Downloaded newer image for jumpserver/koko:v2.21.0 docker.io/jumpserver/koko:v2.21.0 [jumpserver/lion:v2.21.0] v2.21.0: Pulling from jumpserver/lion 72a69066d2fe: Pull complete 01971ece8edb: Pull complete 00efad7f1f86: Pull complete ac262804a75a: Pull complete 0688de3fd063: Pull complete 2e94ff443643: Pull complete d4b1196ea6e9: Pull complete f7b6cdb41d27: Pull complete 15b59ceecb8f: Pull complete a1a72a5d006a: Pull complete 104f6af46917: Pull complete 734049daf1ee: Pull complete 872a952e8fc8: Pull complete 54365e38ac80: Pull complete 462e43406301: Pull complete Digest: sha256:0c0c4ebacf2641843bebd34493d0b53813e51c5d6bbeda2fc2d2c3771739e8d4 Status: Downloaded newer image for jumpserver/lion:v2.21.0 docker.io/jumpserver/lion:v2.21.0 [jumpserver/magnus:v2.21.0] v2.21.0: Pulling from jumpserver/magnus a2abf6c4d29d: Already exists dd890438b467: Pull complete 7089ae322f82: Pull complete 870d44bc43dd: Pull complete 500ad50c6bd6: Pull complete f7a09e01efd6: Pull complete Digest: sha256:edee98923b5fc3081aa49f66ce045c087ed6467764b88ba2478d5fe471c92bba Status: Downloaded newer image for jumpserver/magnus:v2.21.0 docker.io/jumpserver/magnus:v2.21.0 complete >>> Install and Configure JumpServer 1. Configure Private Key SECRETE_KEY: OWIxMjRkNTYtY2I1NC0zNDhkLTlmMDYtYWIxODViOTE5MGVk BOOTSTRAP_TOKEN: OWIxMjRkNTYtY2I1NC0zNDhk complete 2. Configure Persistent Directory Do you need custom persistent store, will use the default directory /opt/jumpserver? (y/n) (default n): y To modify the persistent directory such as logs video, you can select your largest disk and create a directory in it, such as /data/jumpserver Note: you can not change it after installation, otherwise the database may be lost Filesystem Size Used Avail Use% Mounted on Persistent storage directory (default /opt/jumpserver): complete 3. Configure MySQL Do you want to use external MySQL? (y/n) (default n): complete 4. Configure Redis Do you want to use external Redis? (y/n) (default n): complete 5. Configure External Port Do you need to customize the JumpServer external port? (y/n) (default n): complete 6. Init JumpServer Database Creating network \"jms_net\" with driver \"bridge\" Creating jms_mysql ... done Creating jms_redis ... done Creating jms_core ... done 2022-04-23 13:13:51 Collect static files 2022-04-23 13:13:51 Collect static files done 2022-04-23 13:13:51 Check database structure change ... 2022-04-23 13:13:51 Migrate model change to database ... Operations to perform: Apply all migrations: acls, admin, applications, assets, audits, auth, authentication, captcha, common, contenttypes, django_cas_ng, django_celery_beat, jms_oidc_rp, notifications, ops, orgs, perms, rbac, sessions, settings, terminal, tickets, users Running migrations: Applying contenttypes.0001_initial... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0001_initial... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying users.0001_initial... OK Applying users.0002_auto_20171225_1157_squashed_0019_auto_20190304_1459... OK Applying authentication.0001_initial... OK Applying authentication.0002_auto_20190729_1423... OK Applying authentication.0003_loginconfirmsetting... OK Applying authentication.0004_ssotoken... OK Applying acls.0001_initial... OK Applying acls.0002_auto_20210926_1047... OK Applying acls.0003_auto_20211130_1037... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying admin.0003_logentry_add_action_flag_choices... OK Applying users.0020_auto_20190612_1825... OK Applying users.0021_auto_20190625_1104... OK Applying users.0022_auto_20190625_1105... OK Applying users.0023_auto_20190724_1525... OK Applying users.0024_auto_20191118_1612... OK Applying users.0025_auto_20200206_1216... OK Applying users.0026_auto_20200508_2105... OK Applying users.0027_auto_20200616_1503... OK Applying users.0028_auto_20200728_1805... OK Applying users.0029_auto_20200814_1650... OK Applying users.0030_auto_20200819_2041... OK Applying users.0031_auto_20201118_1801... OK Applying tickets.0001_initial... OK Applying tickets.0002_auto_20200728_1146... OK Applying tickets.0003_auto_20200804_1551... OK Applying tickets.0004_ticket_comment... OK Applying tickets.0005_ticket_meta_confirmed_system_users... OK Applying tickets.0006_auto_20201023_1628... OK Applying tickets.0007_auto_20201224_1821... OK Applying terminal.0001_initial... OK Applying terminal.0002_auto_20171228_0025_squashed_0009_auto_20180326_0957... OK Applying terminal.0010_auto_20180423_1140... OK Applying terminal.0011_auto_20180807_1116... OK Applying terminal.0012_auto_20180816_1652... OK Applying terminal.0013_auto_20181123_1113... OK Applying terminal.0014_auto_20181226_1441... OK Applying terminal.0015_auto_20190923_1529... OK Applying terminal.0016_commandstorage_replaystorage... OK Applying common.0001_initial... OK Applying common.0002_auto_20180111_1407... OK Applying common.0003_setting_category... OK Applying common.0004_setting_encrypted... OK Applying common.0005_auto_20190221_1902... OK Applying common.0006_auto_20190304_1515... OK Applying settings.0001_initial... OK Applying terminal.0017_auto_20191125_0931... OK Applying terminal.0018_auto_20191202_1010... OK Applying terminal.0019_auto_20191206_1000... OK Applying terminal.0020_auto_20191218_1721... OK Applying terminal.0021_auto_20200213_1316... OK Applying terminal.0022_session_is_success... OK Applying terminal.0023_command_risk_level... OK Applying terminal.0024_auto_20200715_1713... OK Applying terminal.0025_auto_20200810_1735... OK Applying terminal.0026_auto_20201027_1905... OK Applying terminal.0027_auto_20201102_1651... OK Applying terminal.0028_auto_20201110_1918... OK Applying terminal.0029_auto_20201116_1757... OK Applying terminal.0030_terminal_type... OK Applying terminal.0031_auto_20210113_1356... OK Applying assets.0001_initial... OK Applying perms.0001_initial... OK Applying assets.0002_auto_20180105_1807_squashed_0009_auto_20180307_1212... OK Applying assets.0010_auto_20180307_1749_squashed_0019_auto_20180816_1320... OK Applying perms.0002_auto_20171228_0025_squashed_0009_auto_20180903_1132... OK Applying perms.0003_action... OK Applying perms.0004_assetpermission_actions... OK Applying assets.0020_auto_20180816_1652... OK Applying assets.0021_auto_20180903_1132... OK Applying assets.0022_auto_20181012_1717... OK Applying assets.0023_auto_20181016_1650... OK Applying assets.0024_auto_20181219_1614... OK Applying assets.0025_auto_20190221_1902... OK Applying assets.0026_auto_20190325_2035... OK Applying applications.0001_initial... OK Applying perms.0005_auto_20190521_1619... OK Applying perms.0006_auto_20190628_1921... OK Applying perms.0007_remove_assetpermission_actions... OK Applying perms.0008_auto_20190911_1907... OK Applying assets.0027_auto_20190521_1703... OK Applying assets.0028_protocol... OK Applying assets.0029_auto_20190522_1114... OK Applying assets.0030_auto_20190619_1135... OK Applying assets.0031_auto_20190621_1332... OK Applying assets.0032_auto_20190624_2108... OK Applying assets.0033_auto_20190624_2108... OK Applying assets.0034_auto_20190705_1348... OK Applying assets.0035_auto_20190711_2018... OK Applying assets.0036_auto_20190716_1535... OK Applying assets.0037_auto_20190724_2002... OK Applying assets.0038_auto_20190911_1634... OK Applying perms.0009_remoteapppermission_system_users... OK Applying assets.0039_authbook_is_active... OK Applying assets.0040_auto_20190917_2056... OK Applying assets.0041_gathereduser... OK Applying assets.0042_favoriteasset... OK Applying assets.0043_auto_20191114_1111... OK Applying assets.0044_platform... OK Applying assets.0045_auto_20191206_1607... OK Applying assets.0046_auto_20191218_1705... OK Applying applications.0002_remove_remoteapp_system_user... OK Applying applications.0003_auto_20191210_1659... OK Applying applications.0004_auto_20191218_1705... OK Applying perms.0010_auto_20191218_1705... OK Applying perms.0011_auto_20200721_1739... OK Applying assets.0047_assetuser... OK Applying assets.0048_auto_20191230_1512... OK Applying assets.0049_systemuser_sftp_root... OK Applying assets.0050_auto_20200711_1740... OK Applying assets.0051_auto_20200713_1143... OK Applying assets.0052_auto_20200715_1535... OK Applying assets.0053_auto_20200723_1232... OK Applying assets.0054_auto_20200807_1032... OK Applying applications.0005_k8sapp... OK Applying perms.0012_k8sapppermission... OK Applying assets.0055_auto_20200811_1845... OK Applying assets.0056_auto_20200904_1751... OK Applying assets.0057_fill_node_value_assets_amount_and_parent_key... ................................................................. OK Applying perms.0013_rebuildusertreetask_usergrantedmappingnode... OK Applying perms.0014_build_users_perm_tree... OK Applying perms.0015_auto_20200929_1728... OK Applying assets.0058_auto_20201023_1115... OK Applying assets.0059_auto_20201027_1905... OK Applying applications.0006_application... OK Applying perms.0016_applicationpermission... OK Applying perms.0017_auto_20210104_0435... OK Applying assets.0060_node_full_value... - Start migrate node value if has / - Start migrate node full value OK Applying assets.0061_auto_20201116_1757... OK Applying assets.0062_auto_20201117_1938... OK Applying assets.0063_migrate_default_node_key... Check old default node `key=0 value=Default` not exists OK Applying assets.0064_auto_20201203_1100... OK Applying assets.0065_auto_20210121_1549... OK Applying perms.0018_auto_20210208_1515... OK Applying orgs.0001_initial... OK Applying orgs.0002_auto_20180903_1132... OK Applying orgs.0003_auto_20190916_1057... OK Applying orgs.0004_organizationmember... OK Applying orgs.0005_auto_20200721_1937... OK Applying orgs.0006_auto_20200721_1937... OK Applying orgs.0007_auto_20200728_1805... OK Applying orgs.0008_auto_20200819_2041... OK Applying orgs.0009_auto_20201023_1628... OK Applying ops.0001_initial... OK Applying ops.0002_celerytask... OK Applying ops.0003_auto_20181207_1744... OK Applying ops.0004_adhoc_run_as... OK Applying ops.0005_auto_20181219_1807... OK Applying ops.0006_auto_20190318_1023... OK Applying ops.0007_auto_20190724_2002... OK Applying ops.0008_auto_20190919_2100... OK Applying ops.0009_auto_20191217_1713... OK Applying ops.0010_auto_20191217_1758... OK Applying ops.0011_auto_20200106_1534... OK Applying ops.0012_auto_20200108_1659... OK Applying ops.0013_auto_20200108_1706... OK Applying ops.0014_auto_20200108_1749... OK Applying ops.0015_auto_20200108_1809... OK Applying ops.0016_commandexecution_org_id... OK Applying ops.0017_auto_20200306_1747... OK Applying ops.0018_auto_20200509_1434... OK Applying ops.0019_adhocexecution_celery_task_id... OK Applying audits.0001_initial... OK Applying audits.0002_ftplog_org_id... OK Applying audits.0003_auto_20180816_1652... OK Applying audits.0004_operatelog_passwordchangelog_userloginlog... OK Applying audits.0005_auto_20190228_1715... OK Applying audits.0006_auto_20190726_1753... OK Applying audits.0007_auto_20191202_1010... OK Applying audits.0008_auto_20200508_2105... OK Applying audits.0009_auto_20200624_1654... OK Applying audits.0010_auto_20200811_1122... OK Applying audits.0011_userloginlog_backend... OK Applying assets.0066_auto_20210208_1802... OK Applying applications.0007_auto_20201119_1110... OK Applying applications.0008_auto_20210104_0435... OK Applying orgs.0010_auto_20210219_1241... Migrate model org id: Application done, use 0.99 ms Migrate model org id: AdminUser done, use 0.9 ms Migrate model org id: Asset done, use 1.06 ms Migrate model org id: AuthBook done, use 1.12 ms Migrate model org id: CommandFilter done, use 0.83 ms Migrate model org id: CommandFilterRule done, use 0.8 ms Migrate model org id: Domain done, use 0.69 ms Migrate model org id: Gateway done, use 0.81 ms Migrate model org id: GatheredUser done, use 0.69 ms Migrate model org id: Label done, use 0.78 ms Migrate model org id: Node done, use 0.79 ms Migrate model org id: SystemUser done, use 0.74 ms Migrate model org id: FTPLog done, use 0.88 ms Migrate model org id: OperateLog done, use 0.72 ms Migrate model org id: AdHoc done, use 0.71 ms Migrate model org id: AdHocExecution done, use 0.66 ms Migrate model org id: CommandExecution done, use 0.74 ms Migrate model org id: Task done, use 0.9 ms Migrate model org id: ApplicationPermission done, use 0.71 ms Migrate model org id: AssetPermission done, use 0.7 ms Migrate model org id: UserAssetGrantedTreeNodeRelation done, use 0.74 ms Migrate model org id: Session done, use 0.74 ms Migrate model org id: Command done, use 0.73 ms Migrate model org id: Ticket done, use 0.73 ms Migrate model org id: UserGroup done, use 0.77 ms Will add users to default org: 1 Add users to default org: 1-1 done, use 3.72 ms OK Applying assets.0067_auto_20210311_1113... OK Applying assets.0068_auto_20210312_1455... OK Applying assets.0069_change_node_key0_to_key1... --> Not exist key=0 nodes, do nothing. OK Applying assets.0070_auto_20210426_1515... OK Applying assets.0071_systemuser_type... OK Applying assets.0072_historicalauthbook... OK Applying assets.0073_auto_20210606_1142... OK Applying assets.0074_remove_systemuser_assets... OK Applying assets.0075_auto_20210705_1759... OK Applying assets.0076_delete_assetuser... OK Applying applications.0009_applicationuser... OK Applying applications.0010_appaccount_historicalappaccount... OK Applying applications.0011_auto_20210826_1759... OK Applying applications.0012_auto_20211014_2209... OK Applying applications.0013_auto_20211026_1711... OK Applying applications.0014_auto_20211105_1605... OK Applying applications.0015_auto_20220112_2035... OK Applying applications.0016_auto_20220118_1455... OK Applying applications.0017_auto_20220217_2135... OK Applying applications.0018_auto_20220223_1539... OK Applying applications.0019_auto_20220310_1853... OK Applying applications.0020_auto_20220316_2028... OK Applying assets.0077_auto_20211012_1642... OK Applying assets.0078_auto_20211014_2209... OK Applying assets.0079_auto_20211102_1922... OK Applying assets.0080_auto_20211104_1347... OK Applying assets.0081_auto_20211105_1605... OK Applying assets.0082_auto_20211209_1440... OK Applying assets.0083_auto_20211215_1436... OK Applying assets.0084_auto_20220112_1959... OK Applying assets.0085_commandfilterrule_ignore_case... OK Applying assets.0086_auto_20220217_2135... OK Applying assets.0087_auto_20220223_1539... OK Applying assets.0088_auto_20220303_1612... OK Applying assets.0089_auto_20220310_0616... OK Applying assets.0090_auto_20220412_1145... OK Applying audits.0012_auto_20210414_1443... OK Applying audits.0013_auto_20211130_1037... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying auth.0010_alter_group_name_max_length... OK Applying auth.0011_update_proxy_permissions... OK Applying auth.0012_alter_user_first_name_max_length... OK Applying authentication.0005_delete_loginconfirmsetting... OK Applying authentication.0006_auto_20211227_1059... OK Applying authentication.0007_connectiontoken... OK Applying authentication.0008_superconnectiontoken... OK Applying authentication.0009_auto_20220310_0616... OK Applying authentication.0010_temptoken... OK Applying captcha.0001_initial... OK Applying django_cas_ng.0001_initial... OK Applying django_celery_beat.0001_initial... OK Applying django_celery_beat.0002_auto_20161118_0346... OK Applying django_celery_beat.0003_auto_20161209_0049... OK Applying django_celery_beat.0004_auto_20170221_0000... OK Applying django_celery_beat.0005_add_solarschedule_events_choices... OK Applying django_celery_beat.0006_auto_20180322_0932... OK Applying django_celery_beat.0007_auto_20180521_0826... OK Applying django_celery_beat.0008_auto_20180914_1922... OK Applying django_celery_beat.0006_auto_20180210_1226... OK Applying django_celery_beat.0006_periodictask_priority... OK Applying django_celery_beat.0009_periodictask_headers... OK Applying django_celery_beat.0010_auto_20190429_0326... OK Applying django_celery_beat.0011_auto_20190508_0153... OK Applying django_celery_beat.0012_periodictask_expire_seconds... OK Applying django_celery_beat.0013_auto_20200609_0727... OK Applying django_celery_beat.0014_remove_clockedschedule_enabled... OK Applying django_celery_beat.0015_edit_solarschedule_events_choices... OK Applying jms_oidc_rp.0001_initial... OK Applying users.0032_userpasswordhistory... OK Applying users.0033_user_need_update_password... OK Applying users.0034_auto_20210506_1448... OK Applying users.0035_auto_20210526_1100... OK Applying users.0036_user_feishu_id... OK Applying notifications.0001_initial... OK Applying notifications.0002_auto_20210909_1946... Init user message subscription: 1 OK Applying ops.0020_adhoc_run_system_user... OK Applying ops.0021_auto_20211130_1037... OK Applying rbac.0001_initial... OK Applying rbac.0002_auto_20210929_1409... OK Applying rbac.0003_auto_20211130_1037...Update builtin Role: SystemAdmin - True Update builtin Role: SystemAuditor - True Update builtin Role: SystemComponent - True Update builtin Role: User - True Update builtin Role: OrgAdmin - True Update builtin Role: OrgAuditor - True Update builtin Role: OrgUser - True OK Applying rbac.0004_auto_20211201_1901... OK Applying orgs.0011_auto_20211223_1913... OK Applying orgs.0012_auto_20220118_1054... OK Applying perms.0019_auto_20210906_1044... OK Applying perms.0020_auto_20210910_1103... OK Applying perms.0021_auto_20211105_1605... OK Applying perms.0022_applicationpermission_actions... OK Applying perms.0023_auto_20220112_2035... OK Applying perms.0024_auto_20220217_2135... OK Applying perms.0025_auto_20220223_1539... OK Applying perms.0026_auto_20220307_1500... OK Applying perms.0027_auto_20220310_1802... OK Applying perms.0028_auto_20220316_2028... OK Applying rbac.0005_auto_20220307_1524... OK Applying rbac.0006_auto_20220310_0616... OK Applying rbac.0007_auto_20220314_1525... OK Applying rbac.0008_auto_20220411_1709... OK Applying rbac.0009_auto_20220411_1724... OK Applying sessions.0001_initial... OK Applying settings.0002_auto_20210729_1546... OK Applying settings.0003_auto_20210901_1035... OK Applying settings.0004_auto_20220211_1401... OK Applying settings.0005_auto_20220310_0616... OK Applying terminal.0032_auto_20210302_1853... OK Applying terminal.0033_auto_20210324_1008... OK Applying terminal.0034_auto_20210406_1434... OK Applying terminal.0035_auto_20210517_1448... OK Applying terminal.0036_auto_20210604_1124... OK Applying terminal.0037_auto_20210623_1748... OK Applying terminal.0038_task_kwargs... OK Applying terminal.0039_auto_20210805_1552... OK Applying terminal.0040_sessionjoinrecord_sessionsharing... OK Applying terminal.0041_auto_20211105_1605... OK Applying terminal.0042_auto_20211229_1619... OK Applying terminal.0043_auto_20220217_2135... OK Applying terminal.0044_auto_20220223_1539... OK Applying terminal.0045_auto_20220228_1144... OK Applying terminal.0046_auto_20220228_1744... OK Applying terminal.0047_auto_20220302_1951... OK Applying terminal.0048_endpoint_endpointrule... OK Applying tickets.0008_auto_20210311_1113... OK Applying tickets.0009_auto_20210426_1720... OK Applying tickets.0010_auto_20210812_1618... OK Applying tickets.0011_remove_approvalrule_assignees_display... OK Applying tickets.0012_ticketsession... OK Applying tickets.0013_ticket_serial_num... Fill ticket serial number ... 0 OK Applying tickets.0014_auto_20220217_2135... OK Applying tickets.0015_superticket... OK Applying users.0037_user_secret_key... OK Applying users.0038_auto_20211209_1140... OK Applying users.0039_auto_20211229_1852... OK After migration, update builtin role permissions complete >>> The Installation is Complete 1. You can use the following command to start, and then visit cd /opt/jumpserver-installer-v2.21.0 ./jmsctl.sh start 2. Other management commands ./jmsctl.sh stop ./jmsctl.sh restart ./jmsctl.sh backup ./jmsctl.sh upgrade For more commands, you can enter ./jmsctl.sh --help to understand 3. Web access http://10.4.7.129:80 Default username: admin Default password: admin 4. SSH/SFTP access ssh -p2222 admin@10.4.7.129 sftp -P2222 admin@10.4.7.129 5. More information Official Website: https://www.jumpserver.org/ Documentation: https://docs.jumpserver.org/ jms_redis is up-to-date jms_mysql is up-to-date Creating jms_core ... done Creating jms_lion ... done Creating jms_celery ... done Creating jms_magnus ... done Creating jms_koko ... done Creating jms_web ... done [root@localhost ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae1497b2801d jumpserver/web:v2.21.0 \"/docker-entrypoint.…\" 6 seconds ago Up 4 seconds (health: starting) 0.0.0.0:80->80/tcp, :::80->80/tcp jms_web 86e2da92ec2d jumpserver/magnus:v2.21.0 \"./entrypoint.sh\" 6 seconds ago Up 4 seconds (health: starting) 0.0.0.0:33060-33061->33060-33061/tcp, :::33060-33061->33060-33061/tcp, 54320/tcp jms_magnus 4ae17327680d jumpserver/koko:v2.21.0 \"./entrypoint.sh\" 6 seconds ago Up 4 seconds (health: starting) 0.0.0.0:2222->2222/tcp, :::2222->2222/tcp, 5000/tcp jms_koko c296dca6f372 jumpserver/lion:v2.21.0 \"./entrypoint.sh\" 6 seconds ago Up 4 seconds (health: starting) 4822/tcp jms_lion ca4b03a976bd jumpserver/core:v2.21.0 \"./entrypoint.sh sta…\" 6 seconds ago Up 4 seconds (health: starting) 8070/tcp, 8080/tcp jms_celery fb41c4e52bef jumpserver/core:v2.21.0 \"./entrypoint.sh sta…\" 18 seconds ago Up 17 seconds (healthy) 8070/tcp, 8080/tcp jms_core ab2adfdfd389 jumpserver/redis:6-alpine \"docker-entrypoint.s…\" About a minute ago Up About a minute (healthy) 6379/tcp jms_redis c622150334e4 jumpserver/mysql:5 \"docker-entrypoint.s…\" About a minute ago Up About a minute (healthy) 3306/tcp, 33060/tcp jms_mysql [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ae1497b2801d jumpserver/web:v2.21.0 \"/docker-entrypoint.…\" 8 seconds ago Up 5 seconds (health: starting) 0.0.0.0:80->80/tcp, :::80->80/tcp jms_web 86e2da92ec2d jumpserver/magnus:v2.21.0 \"./entrypoint.sh\" 8 seconds ago Up 5 seconds (health: starting) 0.0.0.0:33060-33061->33060-33061/tcp, :::33060-33061->33060-33061/tcp, 54320/tcp jms_magnus 4ae17327680d jumpserver/koko:v2.21.0 \"./entrypoint.sh\" 8 seconds ago Up 6 seconds (health: starting) 0.0.0.0:2222->2222/tcp, :::2222->2222/tcp, 5000/tcp jms_koko c296dca6f372 jumpserver/lion:v2.21.0 \"./entrypoint.sh\" 8 seconds ago Up 6 seconds (health: starting) 4822/tcp jms_lion ca4b03a976bd jumpserver/core:v2.21.0 \"./entrypoint.sh sta…\" 8 seconds ago Up 6 seconds (health: starting) 8070/tcp, 8080/tcp jms_celery fb41c4e52bef jumpserver/core:v2.21.0 \"./entrypoint.sh sta…\" 20 seconds ago Up 19 seconds (healthy) 8070/tcp, 8080/tcp jms_core ab2adfdfd389 jumpserver/redis:6-alpine \"docker-entrypoint.s…\" About a minute ago Up About a minute (healthy) 6379/tcp jms_redis c622150334e4 jumpserver/mysql:5 \"docker-entrypoint.s…\" About a minute ago Up About a minute (healthy) 3306/tcp, 33060/tcp jms_mysql [root@localhost ~]# [root@localhost ~]# [root@localhost ~]# ls anaconda-ks.cfg jumper_bin_deploy.sh Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 06:56:38 "},"JumperServer/HA_Deploy.html":{"url":"JumperServer/HA_Deploy.html","title":"HA Deploy","keywords":"","body":"负载均衡 环境说明 除 JumpServer 自身组件外，其他组件的高可用请参考对应的官方文档进行部署 按照此方式部署后，后续只需要根据需要扩容 JumpServer 节点然后添加节点到 HAProxy 即可 如果已经有 HLB 或者 SLB 可以跳过 HAProxy 部署，第三方 LB 要注意 session 和 websocket 问题 如果已经有 云存储 (* S3/Ceph/Swift/OSS/Azure) 可以跳过 MinIO 部署，MySQL Redis 也一样 生产环境中，应该使用 Ceph 等替代 NFS，或者部署高可用的 NFS 防止单点故障 Redis 高可用快速部署可以参考此项目 DB Version Cache Version MySQL >= 5.7 Redis >= 5.0 MariaDB >= 10.2 Server Name IP Port Use Minimize Hardware Standard Hardware NFS 192.168.100.11 Core 2Core/8GB RAM/100G HDD 4Core/16GB RAM/1T SSD MySQL 192.168.100.11 3306 Core 2Core/8GB RAM/90G HDD 4Core/16GB RAM/1T SSD Redis 192.168.100.11 6379 Core, Koko, Lion 2Core/8GB RAM/90G HDD 4Core/16GB RAM/1T SSD HAProxy 192.168.100.100 80,443,2222,33060,33061 All 2Core/4GB RAM/60G HDD 4Core/8GB RAM/60G SSD JumpServer 01 192.168.100.21 80,2222,33060,33061 HAProxy 2Core/8GB RAM/60G HDD 4Core/8GB RAM/90G SSD JumpServer 02 192.168.100.22 80,2222,33060,33061 HAProxy 2Core/8GB RAM/60G HDD 4Core/8GB RAM/90G SSD JumpServer 03 192.168.100.23 80,2222,33060,33061 HAProxy 2Core/8GB RAM/60G HDD 4Core/8GB RAM/90G SSD JumpServer 04 192.168.100.24 80,2222,33060,33061 HAProxy 2Core/8GB RAM/60G HDD 4Core/8GB RAM/90G SSD MinIO 192.168.100.41 9000,9001 Core, KoKo, Lion 2Core/4GB RAM/100G HDD 4Core/8GB RAM/1T SSD Elasticsearch 192.168.100.51 9200,9300 Core, KoKo 2Core/4GB RAM/100G HDD 4Core/8GB RAM/1T SSD Server Name Check Health Example Core http://core:8080/api/health/ https://demo.jumpserver.org/api/health/ KoKo http://koko:5000/koko/health/ https://demo.jumpserver.org/koko/health/ Lion http://lion:8081/lion/health/ https://demo.jumpserver.org/lion/health/ 部署 NFS 服务 服务器: 192.168.100.11 安装依赖 yum -y install epel-release 安装 NFS yum -y install nfs-utils rpcbind 启动 NFS systemctl enable rpcbind nfs-server nfs-lock nfs-idmap systemctl start rpcbind nfs-server nfs-lock nfs-idmap 配置防火墙 firewall-cmd --add-service=nfs --permanent --zone=public firewall-cmd --add-service=mountd --permanent --zone=public firewall-cmd --add-service=rpc-bind --permanent --zone=public firewall-cmd --reload 配置 NFS mkdir /data chmod 777 -R /data vi /etc/exports # 设置 NFS 访问权限, /data 是刚才创建的将被共享的目录, 192.168.100.* 表示整个 192.168.100.* 的资产都有括号里面的权限 # 也可以写具体的授权对象 /data 192.168.100.30(rw,sync,no_root_squash) 192.168.100.31(rw,sync,no_root_squash) /data 192.168.100.*(rw,sync,all_squash,anonuid=0,anongid=0) exportfs -a 部署 MySQL 服务 服务器: 192.168.100.11 设置 Repo yum -y localinstall http://mirrors.ustc.edu.cn/mysql-repo/mysql57-community-release-el7.rpm 安装 MySQL yum install -y mysql-community-server 配置 MySQL if [ ! \"$(cat /usr/bin/mysqld_pre_systemd | grep -v ^\\# | grep initialize-insecure )\" ]; then sed -i \"s@--initialize @--initialize-insecure @g\" /usr/bin/mysqld_pre_systemd fi 启动 MySQL systemctl enable mysqld systemctl start mysqld 数据库授权 mysql -uroot Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.32 MySQL Community Server (GPL) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> create database jumpserver default charset 'utf8'; Query OK, 1 row affected (0.00 sec) mysql> set global validate_password_policy=LOW; Query OK, 0 rows affected (0.00 sec) mysql> create user 'jumpserver'@'%' identified by 'KXOeyNgDeTdpeu9q'; Query OK, 0 rows affected (0.00 sec) mysql> grant all on jumpserver.* to 'jumpserver'@'%'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) mysql> exit Bye 配置防火墙 firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.100.0/24\" port protocol=\"tcp\" port=\"3306\" accept\" firewall-cmd --reload 部署 Redis 服务 服务器: 192.168.100.11 设置 Repo yum -y install epel-release https://repo.ius.io/ius-release-el7.rpm 安装 Redis yum install -y redis5 配置 Redis sed -i \"s/bind 127.0.0.1/bind 0.0.0.0/g\" /etc/redis.conf sed -i \"561i maxmemory-policy allkeys-lru\" /etc/redis.conf sed -i \"481i requirepass KXOeyNgDeTdpeu9q\" /etc/redis.conf 启动 Redis systemctl enable redis systemctl start redis 配置防火墙 firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.100.0/24\" port protocol=\"tcp\" port=\"6379\" accept\" firewall-cmd --reload 部署 JumpServer 01 服务器: 192.168.100.21 配置 NFS yum -y install nfs-utils showmount -e 192.168.100.11 # 将 Core 持久化目录挂载到 NFS, 默认 /opt/jumpserver/core/data, 请根据实际情况修改 # JumpServer 持久化目录定义相关参数为 VOLUME_DIR, 在安装 JumpServer 过程中会提示 mkdir /opt/jumpserver/core/data mount -t nfs 192.168.100.11:/data /opt/jumpserver/core/data # 可以写入到 /etc/fstab, 重启自动挂载. 注意: 设置后如果 nfs 损坏或者无法连接该服务器将无法启动 echo \"192.168.100.11:/data /opt/jumpserver/core/data nfs defaults 0 0\" >> /etc/fstab 下载 jumpserver-install cd /opt yum -y install wget wget https://github.com/jumpserver/installer/releases/download/v2.21.0/jumpserver-installer-v2.21.0.tar.gz tar -xf jumpserver-installer-v2.21.0.tar.gz cd jumpserver-installer-v2.21.0 修改配置文件 vi config-example.txt # 修改下面选项, 其他保持默认, 请勿直接复制此处内容 ### 注意: SECRET_KEY 和要其他 JumpServer 服务器一致, 加密的数据将无法解密 # 安装配置 ### 注意持久化目录 VOLUME_DIR, 如果上面 NFS 挂载其他目录, 此处也要修改. 如: NFS 挂载到 /data/jumpserver/core/data, 则 VOLUME_DIR=/data/jumpserver VOLUME_DIR=/opt/jumpserver DOCKER_DIR=/var/lib/docker # Core 配置 ### 启动后不能再修改，否则密码等等信息无法解密, 请勿直接复制下面的字符串 SECRET_KEY=kWQdmdCQKjaWlHYpPhkNQDkfaRulM6YnHctsHLlSPs8287o2kW # 要其他 JumpServer 服务器一致 (*) BOOTSTRAP_TOKEN=KXOeyNgDeTdpeu9q # 要其他 JumpServer 服务器一致 (*) LOG_LEVEL=ERROR # 日志等级 # SESSION_COOKIE_AGE=86400 SESSION_EXPIRE_AT_BROWSER_CLOSE=true # 关闭浏览器 session 过期 # MySQL 配置 USE_EXTERNAL_MYSQL=1 # 使用外置 MySQL DB_HOST=192.168.100.11 DB_PORT=3306 DB_USER=jumpserve DB_PASSWORD=KXOeyNgDeTdpeu9q DB_NAME=jumpserver # Redis 配置 USE_EXTERNAL_REDIS=1 # 使用外置 Redis REDIS_HOST=192.168.100.11 REDIS_PORT=6379 REDIS_PASSWORD=KXOeyNgDeTdpeu9q # KoKo Lion 配置 SHARE_ROOM_TYPE=redis # KoKo Lion 使用 redis 共享 REUSE_CONNECTION=false # Koko 禁用连接复用 ./jmsctl.sh install ██╗██╗ ██╗███╗ ███╗██████╗ ███████╗███████╗██████╗ ██╗ ██╗███████╗██████╗ ██║██║ ██║████╗ ████║██╔══██╗██╔════╝██╔════╝██╔══██╗██║ ██║██╔════╝██╔══██╗ ██║██║ ██║██╔████╔██║██████╔╝███████╗█████╗ ██████╔╝██║ ██║█████╗ ██████╔╝ ██ ██║██║ ██║██║╚██╔╝██║██╔═══╝ ╚════██║██╔══╝ ██╔══██╗╚██╗ ██╔╝██╔══╝ ██╔══██╗ ╚█████╔╝╚██████╔╝██║ ╚═╝ ██║██║ ███████║███████╗██║ ██║ ╚████╔╝ ███████╗██║ ██║ ╚════╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚══════╝╚══════╝╚═╝ ╚═╝ ╚═══╝ ╚══════╝╚═╝ ╚═╝ Version: v2.21.0 1. 检查配置文件 配置文件位置: /opt/jumpserver/config /opt/jumpserver/config/config.txt [ √ ] /opt/jumpserver/config/nginx/lb_rdp_server.conf [ √ ] /opt/jumpserver/config/nginx/lb_ssh_server.conf [ √ ] /opt/jumpserver/config/nginx/cert/server.crt [ √ ] /opt/jumpserver/config/nginx/cert/server.key [ √ ] 完成 2. 备份配置文件 备份至 /opt/jumpserver/config/backup/config.txt.2021-07-15_22-26-13 完成 >>> 安装配置 Docker 1. 安装 Docker 开始下载 Docker 程序 ... 开始下载 Docker Compose 程序 ... 完成 2. 配置 Docker 是否需要自定义 docker 存储目录, 默认将使用目录 /var/lib/docker? (y/n) (默认为 n): n 完成 3. 启动 Docker Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /etc/systemd/system/docker.service. 完成 >>> 加载 Docker 镜像 Docker: Pulling from jumpserver/core:v2.21.0 [ OK ] Docker: Pulling from jumpserver/koko:v2.21.0 [ OK ] Docker: Pulling from jumpserver/web:v2.21.0 [ OK ] Docker: Pulling from jumpserver/redis:6-alpine [ OK ] Docker: Pulling from jumpserver/mysql:5 [ OK ] Docker: Pulling from jumpserver/lion:v2.21.0 [ OK ] >>> 安装配置 JumpServer 1. 配置网络 是否需要支持 IPv6? (y/n) (默认为 n): n 完成 2. 配置加密密钥 SECRETE_KEY: YTE2YTVkMTMtMGE3MS00YzI5LWFlOWEtMTc2OWJlMmIyMDE2 BOOTSTRAP_TOKEN: YTE2YTVkMTMtMGE3 完成 3. 配置持久化目录 是否需要自定义持久化存储, 默认将使用目录 /opt/jumpserver? (y/n) (默认为 n): n 完成 4. 配置 MySQL 是否使用外部 MySQL? (y/n) (默认为 n): y 请输入 MySQL 的主机地址 (无默认值): 192.168.100.11 请输入 MySQL 的端口 (默认为3306): 3306 请输入 MySQL 的数据库(事先做好授权) (默认为jumpserver): jumpserver 请输入 MySQL 的用户名 (无默认值): jumpserver 请输入 MySQL 的密码 (无默认值): KXOeyNgDeTdpeu9q 完成 5. 配置 Redis 是否使用外部 Redis? (y/n) (默认为 n): y 请输入 Redis 的主机地址 (无默认值): 192.168.100.11 请输入 Redis 的端口 (默认为6379): 6379 请输入 Redis 的密码 (无默认值): KXOeyNgDeTdpeu9q 完成 6. 配置对外端口 是否需要配置 JumpServer 对外访问端口? (y/n) (默认为 n): n 完成 7. 初始化数据库 Creating network \"jms_net\" with driver \"bridge\" Creating jms_redis ... done 2021-07-15 22:39:52 Collect static files 2021-07-15 22:39:52 Collect static files done 2021-07-15 22:39:52 Check database structure change ... 2021-07-15 22:39:52 Migrate model change to database ... 475 static files copied to '/opt/jumpserver/data/static'. Operations to perform: Apply all migrations: acls, admin, applications, assets, audits, auth, authentication, captcha, common, contenttypes, django_cas_ng, django_celery_beat, jms_oidc_rp, notifications, ops, orgs, perms, sessions, settings, terminal, tickets, users Running migrations: Applying contenttypes.0001_initial... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0001_initial... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK ... Applying sessions.0001_initial... OK Applying terminal.0032_auto_20210302_1853... OK Applying terminal.0033_auto_20210324_1008... OK Applying terminal.0034_auto_20210406_1434... OK Applying terminal.0035_auto_20210517_1448... OK Applying terminal.0036_auto_20210604_1124... OK Applying terminal.0037_auto_20210623_1748... OK Applying tickets.0008_auto_20210311_1113... OK Applying tickets.0009_auto_20210426_1720... OK >>> 安装完成了 1. 可以使用如下命令启动, 然后访问 cd /root/jumpserver-installer-v2.21.0 ./jmsctl.sh start 2. 其它一些管理命令 ./jmsctl.sh stop ./jmsctl.sh restart ./jmsctl.sh backup ./jmsctl.sh upgrade 更多还有一些命令, 你可以 ./jmsctl.sh --help 来了解 3. Web 访问 http://192.168.100.212:80 默认用户: admin 默认密码: admin 4. SSH/SFTP 访问 ssh -p2222 admin@192.168.100.212 sftp -P2222 admin@192.168.100.212 5. 更多信息 我们的官网: https://www.jumpserver.org/ 我们的文档: https://docs.jumpserver.org/ 启动 JumpServer ./jmsctl.sh start Creating network \"jms_net\" with driver \"bridge\" Creating jms_core ... done Creating jms_celery ... done Creating jms_lion ... done Creating jms_koko ... done Creating jms_magnus ... done Creating jms_web ... done 部署 JumpServer 02 服务器: 192.168.100.22 配置 NFS yum -y install nfs-utils showmount -e 192.168.100.11 # 将 Core 持久化目录挂载到 NFS, 默认 /opt/jumpserver/core/data, 请根据实际情况修改 # JumpServer 持久化目录定义相关参数为 VOLUME_DIR, 在安装 JumpServer 过程中会提示 mkdir /opt/jumpserver/core/data mount -t nfs 192.168.100.11:/data /opt/jumpserver/core/data # 可以写入到 /etc/fstab, 重启自动挂载. 注意: 设置后如果 nfs 损坏或者无法连接该服务器将无法启动 echo \"192.168.100.11:/data /opt/jumpserver/core/data nfs defaults 0 0\" >> /etc/fstab 下载 jumpserver-install cd /opt yum -y install wget wget https://github.com/jumpserver/installer/releases/download/v2.21.0/jumpserver-installer-v2.21.0.tar.gz tar -xf jumpserver-installer-v2.21.0.tar.gz cd jumpserver-installer-v2.21.0 修改配置文件 vi config-example.txt # 修改下面选项, 其他保持默认, 请勿直接复制此处内容 ### 注意: SECRET_KEY 和要其他 JumpServer 服务器一致, 加密的数据将无法解密 # 安装配置 ### 注意持久化目录 VOLUME_DIR, 如果上面 NFS 挂载其他目录, 此处也要修改. 如: NFS 挂载到/data/jumpserver/core/data, 则 DOCKER_DIR=/data/jumpserver VOLUME_DIR=/opt/jumpserver DOCKER_DIR=/var/lib/docker # Core 配置 ### 启动后不能再修改，否则密码等等信息无法解密, 请勿直接复制下面的字符串 SECRET_KEY=kWQdmdCQKjaWlHYpPhkNQDkfaRulM6YnHctsHLlSPs8287o2kW BOOTSTRAP_TOKEN=KXOeyNgDeTdpeu9q LOG_LEVEL=ERROR # SESSION_COOKIE_AGE=86400 SESSION_EXPIRE_AT_BROWSER_CLOSE=true # MySQL 配置 USE_EXTERNAL_MYSQL=1 DB_HOST=192.168.100.11 DB_PORT=3306 DB_USER=jumpserver DB_PASSWORD=KXOeyNgDeTdpeu9q DB_NAME=jumpserver # Redis 配置 USE_EXTERNAL_REDIS=1 REDIS_HOST=192.168.100.11 REDIS_PORT=6379 REDIS_PASSWORD=KXOeyNgDeTdpeu9q # KoKo Lion 配置 SHARE_ROOM_TYPE=redis ./jmsctl.sh install 启动 JumpServer ./jmsctl.sh start Creating network \"jms_net\" with driver \"bridge\" Creating jms_core ... done Creating jms_celery ... done Creating jms_lion ... done Creating jms_koko ... done Creating jms_magnus ... done Creating jms_web ... done 部署 JumpServer 03 服务器: 192.168.100.23 配置 NFS yum -y install nfs-utils showmount -e 192.168.100.11 # 将 Core 持久化目录挂载到 NFS, 默认 /opt/jumpserver/core/data, 请根据实际情况修改 # JumpServer 持久化目录定义相关参数为 VOLUME_DIR, 在安装 JumpServer 过程中会提示 mkdir /opt/jumpserver/core/data mount -t nfs 192.168.100.11:/data /opt/jumpserver/core/data # 可以写入到 /etc/fstab, 重启自动挂载. 注意: 设置后如果 nfs 损坏或者无法连接该服务器将无法启动 echo \"192.168.100.11:/data /opt/jumpserver/core/data nfs defaults 0 0\" >> /etc/fstab 下载 jumpserver-install cd /opt yum -y install wget wget https://github.com/jumpserver/installer/releases/download/v2.21.0/jumpserver-installer-v2.21.0.tar.gz tar -xf jumpserver-installer-v2.21.0.tar.gz cd jumpserver-installer-v2.21.0 修改配置文件 vi config-example.txt # 修改下面选项, 其他保持默认, 请勿直接复制此处内容 ### 注意: SECRET_KEY 和要其他 JumpServer 服务器一致, 加密的数据将无法解密 # 安装配置 ### 注意持久化目录 VOLUME_DIR, 如果上面 NFS 挂载其他目录, 此处也要修改. 如: NFS 挂载到/data/jumpserver/core/data, 则 DOCKER_DIR=/data/jumpserver VOLUME_DIR=/opt/jumpserver DOCKER_DIR=/var/lib/docker # Core 配置 ### 启动后不能再修改，否则密码等等信息无法解密, 请勿直接复制下面的字符串 SECRET_KEY=kWQdmdCQKjaWlHYpPhkNQDkfaRulM6YnHctsHLlSPs8287o2kW BOOTSTRAP_TOKEN=KXOeyNgDeTdpeu9q LOG_LEVEL=ERROR # SESSION_COOKIE_AGE=86400 SESSION_EXPIRE_AT_BROWSER_CLOSE=true # MySQL 配置 USE_EXTERNAL_MYSQL=1 DB_HOST=192.168.100.11 DB_PORT=3306 DB_USER=jumpserver DB_PASSWORD=KXOeyNgDeTdpeu9q DB_NAME=jumpserver # Redis 配置 USE_EXTERNAL_REDIS=1 REDIS_HOST=192.168.100.11 REDIS_PORT=6379 REDIS_PASSWORD=KXOeyNgDeTdpeu9q # KoKo Lion 配置 SHARE_ROOM_TYPE=redis REUSE_CONNECTION=false ./jmsctl.sh install 启动 JumpServer ./jmsctl.sh start Creating network \"jms_net\" with driver \"bridge\" Creating jms_core ... done Creating jms_lion ... done Creating jms_koko ... done Creating jms_celery ... done Creating jms_magnus ... done Creating jms_web ... done 部署 JumpServer 04 服务器: 192.168.100.24 配置 NFS yum -y install nfs-utils showmount -e 192.168.100.11 # 将 Core 持久化目录挂载到 NFS, 默认 /opt/jumpserver/core/data, 请根据实际情况修改 # JumpServer 持久化目录定义相关参数为 VOLUME_DIR, 在安装 JumpServer 过程中会提示 mkdir /opt/jumpserver/core/data mount -t nfs 192.168.100.11:/data /opt/jumpserver/core/data # 可以写入到 /etc/fstab, 重启自动挂载. 注意: 设置后如果 nfs 损坏或者无法连接该服务器将无法启动 echo \"192.168.100.11:/data /opt/jumpserver/core/data nfs defaults 0 0\" >> /etc/fstab 下载 jumpserver-install cd /opt yum -y install wget wget https://github.com/jumpserver/installer/releases/download/v2.21.0/jumpserver-installer-v2.21.0.tar.gz tar -xf jumpserver-installer-v2.21.0.tar.gz cd jumpserver-installer-v2.21.0 修改配置文件 vi config-example.txt # 修改下面选项, 其他保持默认, 请勿直接复制此处内容 ### 注意: SECRET_KEY 和要其他 JumpServer 服务器一致, 加密的数据将无法解密 # 安装配置 ### 注意持久化目录 VOLUME_DIR, 如果上面 NFS 挂载其他目录, 此处也要修改. 如: NFS 挂载到/data/jumpserver/core/data, 则 DOCKER_DIR=/data/jumpserver VOLUME_DIR=/opt/jumpserver DOCKER_DIR=/var/lib/docker # Core 配置 ### 启动后不能再修改，否则密码等等信息无法解密, 请勿直接复制下面的字符串 SECRET_KEY=kWQdmdCQKjaWlHYpPhkNQDkfaRulM6YnHctsHLlSPs8287o2kW BOOTSTRAP_TOKEN=KXOeyNgDeTdpeu9q LOG_LEVEL=ERROR # SESSION_COOKIE_AGE=86400 SESSION_EXPIRE_AT_BROWSER_CLOSE=true # MySQL 配置 USE_EXTERNAL_MYSQL=1 DB_HOST=192.168.100.11 DB_PORT=3306 DB_USER=jumpserver DB_PASSWORD=KXOeyNgDeTdpeu9q DB_NAME=jumpserver # Redis 配置 USE_EXTERNAL_REDIS=1 REDIS_HOST=192.168.100.11 REDIS_PORT=6379 REDIS_PASSWORD=KXOeyNgDeTdpeu9q # KoKo Lion 配置 SHARE_ROOM_TYPE=redis REUSE_CONNECTION=false ./jmsctl.sh install 启动 JumpServer ./jmsctl.sh start Creating network \"jms_net\" with driver \"bridge\" Creating jms_core ... done Creating jms_celery ... done Creating jms_lion ... done Creating jms_koko ... done Creating jms_magnus ... done Creating jms_web ... done 部署 HAProxy 服务 服务器: 192.168.100.100 安装依赖 yum -y install epel-release 安装 HAProxy yum install -y haproxy 配置 HAProxy vi /etc/haproxy/haproxy.cfg global # to have these messages end up in /var/log/haproxy.log you will # need to: # # 1) configure syslog to accept network log events. This is done # by adding the '-r' option to the SYSLOGD_OPTIONS in # /etc/sysconfig/syslog # # 2) configure local2 events to go to the /var/log/haproxy.log # file. A line like the following can be added to # /etc/sysconfig/syslog # # local2.* /var/log/haproxy.log # log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon # turn on stats unix socket stats socket /var/lib/haproxy/stats #--------------------------------------------------------------------- # common defaults that all the 'listen' and 'backend' sections will # use if not designated in their block #--------------------------------------------------------------------- defaults log global option dontlognull option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000 listen stats bind *:8080 mode http stats enable stats uri /haproxy # 监控页面, 请自行修改. 访问地址为 http://192.168.100.100:8080/haproxy stats refresh 5s stats realm haproxy-status stats auth admin:KXOeyNgDeTdpeu9q # 账户密码, 请自行修改. 访问 http://192.168.100.100:8080/haproxy 会要求输入 #--------------------------------------------------------------------- # check 检活参数说明 # inter 间隔时间, 单位: 毫秒 # rise 连续成功的次数, 单位: 次 # fall 连续失败的次数, 单位: 次 # 例: inter 2s rise 2 fall 3 # 表示 2 秒检查一次状态, 连续成功 2 次服务正常, 连续失败 3 次服务异常 # # server 服务参数说明 # server 192.168.100.21 192.168.100.21:80 weight 1 cookie web01 # 第一个 192.168.100.21 做为页面展示的标识, 可以修改为其他任意字符串 # 第二个 192.168.100.21:80 是实际的后端服务端口 # weight 为权重, 多节点时安装权重进行负载均衡 # cookie 用户侧的 cookie 会包含此标识, 便于区分当前访问的后端节点 # 例: server db01 192.168.100.21:3306 weight 1 cookie db_01 #--------------------------------------------------------------------- listen jms-web bind *:80 # 监听 80 端口 mode http # redirect scheme https if !{ ssl_fc } # 重定向到 https # bind *:443 ssl crt /opt/ssl.pem # https 设置 option httpclose option forwardfor option httpchk GET /api/health/ # Core 检活接口 cookie SERVERID insert indirect hash-type consistent fullconn 500 balance leastconn server 192.168.100.21 192.168.100.21:80 weight 1 cookie web01 check inter 2s rise 2 fall 3 # JumpServer 服务器 server 192.168.100.22 192.168.100.22:80 weight 1 cookie web02 check inter 2s rise 2 fall 3 server 192.168.100.23 192.168.100.23:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 server 192.168.100.23 192.168.100.24:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 listen jms-ssh bind *:2222 mode tcp option tcp-check fullconn 500 balance source server 192.168.100.21 192.168.100.21:2222 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.22 192.168.100.22:2222 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.23 192.168.100.23:2222 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.24 192.168.100.23:2222 weight 1 check inter 2s rise 2 fall 3 send-proxy listen jms-koko mode http option httpclose option forwardfor option httpchk GET /koko/health/ HTTP/1.1\\r\\nHost:\\ 192.168.100.100 # KoKo 检活接口, host 填写 HAProxy 的 ip 地址 cookie SERVERID insert indirect hash-type consistent fullconn 500 balance leastconn server 192.168.100.21 192.168.100.21:80 weight 1 cookie web01 check inter 2s rise 2 fall 3 server 192.168.100.22 192.168.100.22:80 weight 1 cookie web02 check inter 2s rise 2 fall 3 server 192.168.100.23 192.168.100.23:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 server 192.168.100.24 192.168.100.23:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 listen jms-lion mode http option httpclose option forwardfor option httpchk GET /lion/health/ HTTP/1.1\\r\\nHost:\\ 192.168.100.100 # Lion 检活接口, host 填写 HAProxy 的 ip 地址 cookie SERVERID insert indirect hash-type consistent fullconn 500 balance leastconn server 192.168.100.21 192.168.100.21:80 weight 1 cookie web01 check inter 2s rise 2 fall 3 server 192.168.100.22 192.168.100.22:80 weight 1 cookie web02 check inter 2s rise 2 fall 3 server 192.168.100.23 192.168.100.23:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 server 192.168.100.24 192.168.100.23:80 weight 1 cookie web03 check inter 2s rise 2 fall 3 listen jms-mysql bind *:33060 mode tcp option tcp-check fullconn 500 balance source server 192.168.100.21 192.168.100.21:33060 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.22 192.168.100.22:33060 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.23 192.168.100.23:33060 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.24 192.168.100.23:33060 weight 1 check inter 2s rise 2 fall 3 send-proxy listen jms-mariadb bind *:33061 mode tcp option tcp-check fullconn 500 balance source server 192.168.100.21 192.168.100.21:33061 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.22 192.168.100.22:33061 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.23 192.168.100.23:33061 weight 1 check inter 2s rise 2 fall 3 send-proxy server 192.168.100.24 192.168.100.23:33061 weight 1 check inter 2s rise 2 fall 3 send-proxy 配置 Selinux setsebool -P haproxy_connect_any 1 启动 HAProxy systemctl enable haproxy systemctl start haproxy 配置防火墙 firewall-cmd --permanent --zone=public --add-port=80/tcp firewall-cmd --permanent --zone=public --add-port=443/tcp firewall-cmd --permanent --zone=public --add-port=2222/tcp firewall-cmd --permanent --zone=public --add-port=33060/tcp firewall-cmd --permanent --zone=public --add-port=33061/tcp firewall-cmd --reload 部署 MinIO 服务 服务器: 192.168.100.41 # 集群部署请参考 (http://docs.minio.org.cn/docs/master/minio-erasure-code-quickstart-guide) 安装 Docker yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo yum makecache fast yum -y install docker-ce 配置 Docker mkdir /etc/docker/ vi /etc/docker/daemon.json { \"live-restore\": true, \"registry-mirrors\": [\"https://hub-mirror.c.163.com\", \"https://bmtrgdvx.mirror.aliyuncs.com\", \"http://f1361db2.m.daocloud.io\"], \"log-driver\": \"json-file\", \"log-opts\": {\"max-file\": \"3\", \"max-size\": \"10m\"} } 启动 Docker systemctl enable docker systemctl start docker 下载 MinIO 镜像 docker pull minio/minio:latest latest: Pulling from minio/minio a591faa84ab0: Pull complete 76b9354adec6: Pull complete f9d8746550a4: Pull complete 890b1dd95baa: Pull complete 3a8518c890dc: Pull complete 8053f0501aed: Pull complete 506c41cb8532: Pull complete Digest: sha256:e7a725edb521dd2af07879dad88ee1dfebd359e57ad8d98104359ccfbdb92024 Status: Downloaded newer image for minio/minio:latest docker.io/minio/minio:latest 持久化数据目录 mkdir -p /opt/jumpserver/minio/data /opt/jumpserver/minio/config 启动 MinIO ## 请自行修改账号密码并牢记，丢失后可以删掉容器后重新用新密码创建，数据不会丢失 # 9000 # api 访问端口 # 9001 # console 访问端口 # MINIO_ROOT_USER=minio # minio 账号 # MINIO_ROOT_PASSWORD=KXOeyNgDeTdpeu9q # minio 密码 docker run --name jms_minio -d -p 9000:9000 -p 9001:9001 -e MINIO_ROOT_USER=minio -e MINIO_ROOT_PASSWORD=KXOeyNgDeTdpeu9q -v /opt/jumpserver/minio/data:/data -v /opt/jumpserver/minio/config:/root/.minio --restart=always minio/minio:latest server /data --console-address \":9001\" 设置 MinIO 访问 http://192.168.100.41:9000，输入刚才设置的 MinIO 账号密码登录 点击左侧菜单的 Buckets，选择 Create Bucket 创建桶，Bucket Name 输入 jumpserver，然后点击 Save 保存 设置 JumpServer 访问 JumpServer Web 页面并使用管理员账号进行登录 点击左侧菜单栏的 [终端管理]，在页面的上方选择 [存储配置]，在 [录像存储] 下方选择 [创建] 选择 [Ceph] 根据下方的说明进行填写，保存后在 [终端管理] 页面对所有组件进行 [更新]，录像存储选择 [jms-mino]，提交 选项 参考值 说明 名称 (Name) jms-minio 标识, 不可重复 类型 (Type) Ceph 固定, 不可更改 桶名称 (Bucket) jumpserver Bucket Name Access key minio MINIO_ROOT_USER Secret key KXOeyNgDeTdpeu9q MINIO_ROOT_PASSWORD 端点 (Endpoint) http://192.168.100.41:9000 minio 服务访问地址 默认存储 新组件将自动使用该存储 部署 Elasticsearch 服务 服务器: 192.168.100.51 # 集群部署请参考 (https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html) 安装 Docker yum install -y yum-utils device-mapper-persistent-data lvm2 yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo yum makecache fast yum -y install docker-ce 配置 Docker mkdir /etc/docker/ vi /etc/docker/daemon.json { \"live-restore\": true, \"registry-mirrors\": [\"https://hub-mirror.c.163.com\", \"https://bmtrgdvx.mirror.aliyuncs.com\", \"http://f1361db2.m.daocloud.io\"], \"log-driver\": \"json-file\", \"log-opts\": {\"max-file\": \"3\", \"max-size\": \"10m\"} } 启动 Docker systemctl enable docker systemctl start docker 下载 Elasticsearch 镜像 docker pull docker.elastic.co/elasticsearch/elasticsearch:7.16.1 7a0437f04f83: Pull complete 7718d2f58c47: Pull complete cc5c16bd8bb9: Pull complete e3d829b4b297: Pull complete 1ad944c92c79: Pull complete 373fb8fbaf74: Pull complete 5908d3eb2989: Pull complete Digest: sha256:81c126e4eddbc5576285670cb3e23d7ef7892ee5e757d6d9ba870b6fe99f1219 Status: Downloaded newer image for docker.elastic.co/elasticsearch/elasticsearch:7.16.1 docker.elastic.co/elasticsearch/elasticsearch:7.16.1 持久化数据目录 mkdir -p /opt/jumpserver/elasticsearch/data /opt/jumpserver/elasticsearch/logs 启动 Elasticsearch ## 请自行修改账号密码并牢记，丢失后可以删掉容器后重新用新密码创建，数据不会丢失 # 9200 # Web 访问端口 # 9300 # 集群通信 # discovery.type=single-node # 单节点 # bootstrap.memory_lock=\"true\" # 锁定物理内存, 不使用 swap # xpack.security.enabled=\"true\" # 开启安全模块 # TAKE_FILE_OWNERSHIP=\"true\" # 自动修改挂载文件夹的所属用户 # ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" # JVM 内存大小, 推荐设置为主机内存的一半 # elastic # Elasticsearch 账号 # ELASTIC_PASSWORD=KXOeyNgDeTdpeu9q # Elasticsearch 密码 docker run --name jms_es -d -p 9200:9200 -p 9300:9300 -e cluster.name=docker-cluster -e discovery.type=single-node -e network.host=0.0.0.0 -e bootstrap.memory_lock=\"true\" -e xpack.security.enabled=\"true\" -e TAKE_FILE_OWNERSHIP=\"true\" -e ES_JAVA_OPTS=\"-Xms512m -Xmx512m\" -e ELASTIC_PASSWORD=KXOeyNgDeTdpeu9q -v /opt/jumpserver/elasticsearch/data:/usr/share/elasticsearch/data -v /opt/jumpserver/elasticsearch/logs:/usr/share/elasticsearch/logs --restart=always docker.elastic.co/elasticsearch/elasticsearch:7.16.1 设置 JumpServer 访问 JumpServer Web 页面并使用管理员账号进行登录 点击左侧菜单栏的 [终端管理]，在页面的上方选择 [存储配置]，在 [命令存储] 下方选择 [创建] 选择 [Elasticsearch] 根据下方的说明进行填写，保存后在 [终端管理] 页面对所有组件进行 [更新]，命令存储选择 [jms-es]，提交 选项 参考值 说明 名称 (Name) jms-es 标识, 不可重复 类型 (Type) Elasticsearch 固定, 不可更改 主机 (Hosts) http://elastic:KXOeyNgDeTdpeu9q@192.168.100.51:9200 http://es_host:es_port 索引 (Index) jumpserver 索引 忽略证书认证 https 自签 ssl 需要勾选 默认存储 新组件将自动使用该存储 升级 注意事项 更新前请一定要做好备份工作 升级前请关闭所有 JumpServer 节点 在任意一个 JumpServer 节点按照升级文档完成升级操作 仔细检查该节点升级过程确保无异常 然后按照升级文档对其他 JumpServer 节点升级即可 cd /opt wget https://github.com/jumpserver/installer/releases/download/v2.21.0/jumpserver-installer-v2.21.0.tar.gz tar -xf jumpserver-installer-v2.21.0.tar.gz cd jumpserver-installer-v2.21.0 # 额外节点可以设置 SKIP_BACKUP_DB=1 跳过数据库备份, 第一个升级节点不要跳过备份 export SKIP_BACKUP_DB=1 ./jmsctl.sh upgrade Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 06:56:38 "},"MySQL/国内源.html":{"url":"MySQL/国内源.html","title":"国内源","keywords":"","body":"yum -y localinstall http://mirrors.ustc.edu.cn/mysql-repo/mysql57-community-release-el7.rpm Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 07:16:06 "},"OpenStack/OpenStack-Queens版搭建详解.html":{"url":"OpenStack/OpenStack-Queens版搭建详解.html","title":"OpenStack-Queens版搭建详解","keywords":"","body":"1.基础环境配置 1.1 节点硬件规划 本次搭建使用VMware Workstation虚拟出3台CentOS7虚拟机作为主机节点，节点架构：1个controller控制节点、1个compute计算节点、1个cinder块存储节点。硬件配置具体如下： |节点名称 | CPU | 内存 | 磁盘 | 操作系统镜像| | ------------- |:-------------:| -----:| |controller节点 | 2VCPU | 4GB |50GB |CentOS-7-x86_64-Minimal-1804.iso| |compute1节点 | 2VCPU |4GB |50GB| CentOS-7-x86_64-Minimal-1804.iso| |cinder1节点 |2VCPU |4GB| 50GB系统盘，50GB存储盘| CentOS-7-x86_64-Minimal-1804.iso| 说明：硬件规划可以根据自己需求灵活调整，这里使用CentOS-7-x86_64-Minimal-1804，minimal版占用资源更少，下载地址：https://www.centos.org/。 Vmware Workstation虚拟机开启虚拟化引擎： 查看操作系统及内核版本： [root@controller ~]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) [root@controller ~]# uname -sr Linux 4.16.11-1.el7.elrepo.x86_64 1.2 节点网络规划 本次搭建网络使用linuxbridge+vxlan模式，包含三个网络平面：管理网络，外部网络和租户隧道网络，具体规划如下： 节点名称 网卡编号 网卡名称 网卡模式 虚拟交换机 网络类型 IP地址 网关 controller节点 网卡1 ens33 仅主机模式 vmnet1 管理网络 192.168.90.70 无 网卡2 ens37 仅主机模式 vmnet2 隧道网络 192.168.91.70 无 网卡3 ens38 NAT模式 vmnet8 外部网络 192.168.92.70 192.168.92.2/24 compute1节点 网卡1 ens33 仅主机模式 vmnet1 管理网络 192.168.90.71 无 网卡2 ens37 仅主机模式 vmnet2 隧道网络 192.168.91.71 无 网卡3 ens38 NAT模式 vmnet8 部署网络 192.168.92.71 192.168.92.2/24 cinder1节点 网卡1 ens33 仅主机模式 vmnet1 管理网络 192.168.90.72 无 网卡2 ens37 NAT模式 vmnet8 部署网络 192.168.92.72 192.168.92.2/24 VMware Workstation虚拟网络编辑器配置信息，这里新创建VMnet2作为隧道网络： 网络规划说明： 控制节点3块网卡，计算节点3块网卡，存储节点2块网卡。特别注意，计算节点和存储节点的最后一块网卡仅用于连接互联网部署Oenstack软件包，如果搭建有本地yum源，这两块网卡是不需要的，不属于openstack架构体系中的网络。 管理网络配置为仅主机模式，官方解释通过管理网络访问互联网安装软件包，如果搭建的有内部yum源，管理网络是不需要访问互联网的，配置成hostonly模式也可以。 隧道网络配置为仅主机模式，因为隧道网络不需要访问互联网，仅用来承载openstack内部租户的网络流量。 外部网络配置为NAT模式，控制节点的外部网络主要是实现openstack租户网络对外网的访问，另外openstack软件包的部署安装也走这个网络， 特别注意：计算节点和存储节点的外部网络仅用来部署openstack软件包，没有其他用途。 三种网络平面说明： 管理网络（management/API网络）： 提供系统管理相关功能，用于节点之间各服务组件内部通信以及对数据库服务的访问，所有节点都需要连接到管理网络，这里管理网络也承载了API网络的流量，将API网络和管理网络合并，OpenStack各组件通过API网络向用户暴露API服务。 隧道网络（tunnel网络或self-service网络）： 提供租户虚拟网络的承载网络（VXLAN or GRE）。openstack里面使用gre或者vxlan模式，需要有隧道网络；隧道网络采用了点到点通信协议代替了交换连接，在openstack里，这个tunnel就是虚拟机走网络数据流量用的。这个网络所承载的网络和官方文档Networking Option 2: Self-service networks相对应。 外部网络(external网络或者provider网络)：openstack网络至少要包括一个外部网络，这个网络能够访问OpenStack安装环境之外的网络，并且非openstack环境中的设备能够访问openstack外部网络的某个IP。另外外部网络为OpenStack环境中的虚拟机提供浮动IP，实现openstack外部网络对内部虚拟机实例的访问。这个网络和官方文档Networking Option 1: Provider networks相对应。 注意，这里没有规划存储平面网络，cinder存储节点使用管理网络承载存储网络数据。 本次搭建Openstack网络结构图： 本次搭建环境整体网络图： 搭建完成后的内部网络图： 1.3 关闭防火墙 1.关闭selinux # sed -i 's/enforcing/disabled/g' /etc/selinux/config # setenforce 0 2.关闭firewalld防火墙 # systemctl stop firewalld.service && systemctl disable firewalld.service # firewall-cmd --state #查看是否关闭 1.4 配置yum源 以下操作在所有节点执行 配置国内阿里云yum源以获取更快的下载速度： 1.备份CentOS官方源： # mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2.下载阿里云yum源： # wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3.测试yum源是否正常 # yum clean all && yum makecache 也可以搭建本地yum源，参考链接：https://blog.csdn.net/networken/article/details/80729234 1.5 配置节点IP 1.控制节点网络配置： [root@controller ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens33 ONBOOT=yes ##################### IPADDR=192.168.90.70 PREFIX=24 [root@controller ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens37 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens37 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens37 ONBOOT=yes ##################### IPADDR=192.168.91.70 PREFIX=24 [root@controller ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens38 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens38 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens38 ONBOOT=yes ##################### IPADDR=192.168.92.70 PREFIX=24 GATEWAY=192.168.92.2 DNS1=114.114.114.114 DNS2=1.1.1.1 [root@controller ~]# ip a 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:cb:a5:19 brd ff:ff:ff:ff:ff:ff inet 192.168.90.70/24 brd 192.168.90.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::2801:f5c2:4e5a:d003/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: ens37: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:cb:a5:23 brd ff:ff:ff:ff:ff:ff inet 192.168.91.70/24 brd 192.168.91.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::8af8:8b5c:793f:e719/64 scope link noprefixroute valid_lft forever preferred_lft forever 4: ens38: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:cb:a5:2d brd ff:ff:ff:ff:ff:ff inet 192.168.92.70/24 brd 192.168.92.255 scope global noprefixroute ens38 valid_lft forever preferred_lft forever inet6 fe80::e8d3:6442:89c0:cd4a/64 scope link noprefixroute valid_lft forever preferred_lft forever 2.计算节点网络配置： [root@compute1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens33 ONBOOT=yes ##################### IPADDR=192.168.90.71 PREFIX=24 [root@compute1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens37 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens37 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens37 ONBOOT=yes ##################### IPADDR=192.168.91.71 PREFIX=24 [root@compute1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens38 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens38 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens38 ONBOOT=yes ##################### IPADDR=192.168.92.71 PREFIX=24 GATEWAY=192.168.92.2 DNS1=114.114.114.114 DNS2=1.1.1.1 [root@compute1 ~]# ip a 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:c7:ba:9b brd ff:ff:ff:ff:ff:ff inet 192.168.90.71/24 brd 192.168.90.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::ffb5:9b12:f911:89ec/64 scope link noprefixroute valid_lft forever preferred_lft forever inet6 fe80::b01a:e132:1923:175/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever inet6 fe80::2801:f5c2:4e5a:d003/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever 3: ens37: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:c7:ba:a5 brd ff:ff:ff:ff:ff:ff inet 192.168.91.71/24 brd 192.168.91.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::e8fe:eea6:f4f:2d85/64 scope link noprefixroute valid_lft forever preferred_lft forever inet6 fe80::8af8:8b5c:793f:e719/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever 4: ens38: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:c7:ba:af brd ff:ff:ff:ff:ff:ff inet 192.168.92.71/24 brd 192.168.92.255 scope global noprefixroute ens38 valid_lft forever preferred_lft forever inet6 fe80::e64:a89f:4312:ea34/64 scope link noprefixroute valid_lft forever preferred_lft forever inet6 fe80::e8d3:6442:89c0:cd4a/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever 3.存储节点网络配置： [root@cinder1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens33 ONBOOT=yes ##################### IPADDR=192.168.90.72 PREFIX=24 [root@cinder1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens37 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=none DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens37 #UUID=162a12c5-b271-4a13-865e-0fdb876e64b8 DEVICE=ens37 ONBOOT=yes ##################### IPADDR=192.168.92.72 PREFIX=24 GATEWAY=192.168.92.2 DNS1=114.114.114.114 DNS2=1.1.1.1 [root@cinder1 ~]# ip a 1: lo: mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:97:4f:52 brd ff:ff:ff:ff:ff:ff inet 192.168.90.72/24 brd 192.168.90.255 scope global noprefixroute ens33 valid_lft forever preferred_lft forever inet6 fe80::b01a:e132:1923:175/64 scope link noprefixroute valid_lft forever preferred_lft forever inet6 fe80::2801:f5c2:4e5a:d003/64 scope link tentative noprefixroute dadfailed valid_lft forever preferred_lft forever 3: ens37: mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:97:4f:5c brd ff:ff:ff:ff:ff:ff inet 192.168.92.72/24 brd 192.168.92.255 scope global noprefixroute ens37 valid_lft forever preferred_lft forever inet6 fe80::8af8:8b5c:793f:e719/64 scope link noprefixroute valid_lft forever preferred_lft forever 4.验证网络是否正常： [root@controller ~]# ping –c 4 openstack.org #控制节点访问互联网 [root@compute1 ~]# ping –c 4 openstack.org #计算节点访问互联网 [root@cinder1 ~]# ping –c 4 openstack.org #存储节点访问互联网 [root@controller ~]# ping –c 4 192.168.90.71 #访问计算节点管理网络 [root@controller ~]# ping –c 4 192.168.91.71 #访问计算节点隧道网络 [root@controller ~]# ping –c 4 192.168.92.71 #访问计算节点外部网络 1.6 配置主机名 控制节点执行： [root@localhost ~]# hostnamectl set-hostname controller 计算节点执行： [root@localhost ~]# hostnamectl set-hostname compute1 存储节点执行： [root@localhost ~]# hostnamectl set-hostname cinder1 所有节点执行，注销账号重新登录，验证主机名是否配置成功： [root@localhost ~]# exit 1.7 配置主机名解析 所有节点执行，配置相同，注意这里使用管理网络IP地址： [root@controller ~]# cat /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 # controller 192.168.90.70 controller # compute1 192.168.90.71 compute1 #cinder1 192.168.90.72 cinder1 2.验证主机名解析是否正常： ping计算节点： [root@controller ~]# ping -c 4 compute1 PING compute1 (190.168.90.71) 56(84) bytes of data. 64 bytes from compute1 (190.168.90.71): icmp_seq=1 ttl=64 time=0.301 ms 64 bytes from compute1 (190.168.90.71): icmp_seq=2 ttl=64 time=0.990 ms 64 bytes from compute1 (190.168.90.71): icmp_seq=3 ttl=64 time=0.376 ms 64 bytes from compute1 (190.168.90.71): icmp_seq=4 ttl=64 time=0.321 ms --- compute1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3102ms rtt min/avg/max/mdev = 0.301/0.497/0.990/0.285 ms ping存储节点： [root@controller ~]# ping -c 4 cinder1 PING cinder1 (190.168.90.72) 56(84) bytes of data. 64 bytes from cinder1 (190.168.90.72): icmp_seq=1 ttl=64 time=0.262 ms 64 bytes from cinder1 (190.168.90.72): icmp_seq=2 ttl=64 time=0.388 ms 64 bytes from cinder1 (190.168.90.72): icmp_seq=3 ttl=64 time=1.11 ms 64 bytes from cinder1 (190.168.90.72): icmp_seq=4 ttl=64 time=0.796 ms --- cinder1 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3057ms rtt min/avg/max/mdev = 0.262/0.640/1.115/0.338 ms 1.8 配置NTP服务 以下在控制节点进行配置 1.安装软件包： [root@controller ~]# yum install chrony 2.修改配置文件： [root@controller ~]# vim /etc/chrony.conf allow 192.168.0.0/16 去掉注释，允许其他节点网段同步时间，请配置为对应网段 3.重启服务并加入开机启动项： [root@controller ~]# systemctl enable chronyd.service && systemctl start chronyd.service 4查看时间同步状态: MS列中包含^*的行，指明NTP服务当前同步的服务器。当前同步的源为time5.aliyun.com： [root@controller ~]# chronyc sources 210 Number of sources = 4 MS Name/IP address Stratum Poll Reach LastRx Last sample =============================================================================== ^? 85.199.214.101 1 6 3 36 -24ms[ -24ms] +/- 114ms ^* time5.aliyun.com 2 6 77 37 +4343us[ +22ms] +/- 43ms ^- ntp1.ams1.nl.leaseweb.net 2 6 77 35 -43ms[ -43ms] +/- 367ms ^? ntp.de.fdw.no 0 8 0 - +0ns[ +0ns] +/- 0ns 5.查看当前时间是否准确，其中NTP synchronized: yes说明同步成功 [root@controller ~]# timedatectl Local time: Fri 2018-06-08 10:36:39 CST Universal time: Fri 2018-06-08 8:36:39 UTC RTC time: Fri 2018-06-08 8:36:39 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: yes NTP synchronized: yes RTC in local TZ: no DST active: n/a 以下在计算节点进行配置： 1.安装软件包： [root@compute1 ~]# yum install chrony 2.修改配置文件，使计算节点与控制节点同步时间： [root@compute1 ~]# vim /etc/chrony.conf #注释3-6行，并增加第7行内容 1 # Use public servers from the pool.ntp.org project. 2 # Please consider joining the pool (http://www.pool.ntp.org/join.html). 3 #server 0.centos.pool.ntp.org iburst 4 #server 1.centos.pool.ntp.org iburst 5 #server 2.centos.pool.ntp.org iburst 6 #server 3.centos.pool.ntp.org iburst 7 server 192.168.92.70 iburst 3.重启服务并设置开机启动 [root@compute1 ~]# systemctl enable chronyd.service && systemctl start chronyd.service 4.查看时间同步状态，当前同步的源为controller [root@compute1 ~]# chronyc sources 210 Number of sources = 1 MS Name/IP address Stratum Poll Reach LastRx Last sample ^* controller 3 6 377 21 +7732us[+9937us] +/- 24ms 5.查看时间是否与控制节点一致 [root@compute1 ~]# timedatectl Local time: Sat 2018-06-09 10:09:32 CST Universal time: Fri 2018-06-08 8:09:32 UTC RTC time: Fri 2018-06-08 8:09:32 Time zone: Asia/Shanghai (CST, +0800) NTP enabled: yes NTP synchronized: yes RTC in local TZ: no DST active: n/a 存储节点配置同计算节点，这里省略 NTP的其他操作命令： # timedatectl set-ntp yes #启用ntp同步服务 # timedatectl set-timezone Asia/Shanghai #设置时区 # yum install –y ntpdate #安装时间同步工具 # ntpdate 0.centos.pool.ntp.org #强制与网络NTP服务器同步时间 # ntpdate 192.168.92.70 #强制与控制节点同步时间 注意：各个节点时间不同步后续可能出现各种问题，建议配置准确在进行后续操作。 2.安装基础软件包 2.1 安装OpenStack软件包 以下操作在所有节点执行 1.启用OpenStack存储库，安装queens版本的存储库 # yum install centos-release-openstack-queens 2.升级所有软件包，如果升级后内核更新，请重启节点启用新内核。 # yum upgrade 3.安装openstack客户端 # yum install python-openstackclient 4.安装 openstack-selinux软件包以自动管理OpenStack服务的安全策略： # yum install openstack-selinux 2.2 安装mariadb数据库 以下操作在控制节点执行 大多数OpenStack服务使用SQL数据库来存储信息。数据库通常在控制器节点上运行。本次搭建使用MariaDB数据库， OpenStack服务还支持其他SQL数据库，包括 PostgreSQL等。 1.安装软件包 # yum install mariadb mariadb-server python2-PyMySQL 2.创建并编辑/etc/my.cnf.d/openstack.cnf文件并完成以下操作： 配置以下内容， bind-address设置为控制节点的管理IP地址，以使其他节点能够通过管理网络进行访问： [root@controller ~]# vim /etc/my.cnf.d/openstack.cnf [mysqld] bind-address = 192.168.90.70 default-storage-engine = innodb innodb_file_per_table = on max_connections = 4096 collation-server = utf8_general_ci character-set-server = utf8 3.启动数据库服务并设置服务开机启动： # systemctl start mariadb.service && systemctl enable mariadb.service 4.运行mysql_secure_installation 脚本初始化数据库服务，并为数据库root帐户设置密码(这里设为123456)： [root@controller ~]# mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we'll need the current password for the root user. If you've just installed MariaDB, and you haven't set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. Set root password? [Y/n] Y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] Y ... Success! Normally, root should only be allowed to connect from 'localhost'. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] Y ... Success! By default, MariaDB comes with a database named 'test' that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] Y ... Success! Cleaning up... All done! If you've completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! 2.3 安装RabbitMQ消息队列 以下在控制节点执行 OpenStack使用消息队列（Message queue）来协调服务之间的操作和状态信息，消息队列服务通常在控制节点上运行，OpenStack支持多种消息队列服务，包括RabbitMQ， Qpid和ZeroMQ。 1．安装软件包： # yum install rabbitmq-server 2.启动消息队列服务并设置服务开机启动 # systemctl enable rabbitmq-server.service && systemctl start rabbitmq-server.service 3.添加openstack 用户，并设置密码，这里设置为123456 # rabbitmqctl add_user openstack 123456 4.为openstack用户增加配置、读取及写入相关权限 # rabbitmqctl set_permissions openstack \".*\" \".*\" \".*\" Setting permissions for user \"openstack\" in vhost \"/\" ... 2.4 安装Memcached缓存数据库 以下在控制节点执行 身份认证服务使用Memcached缓存令牌，memcached服务通常在控制节点上运行。 1.安装软件包 # yum install memcached python-memcached 2.编辑/etc/sysconfig/memcached文件并完成以下操作： 使用控制节点的管理IP地址配置服务。这使其他节点能够通过管理网络进行访问： [root@controller ~]# vim /etc/sysconfig/memcached PORT=\"11211\" USER=\"memcached\" MAXCONN=\"1024\" CACHESIZE=\"64\" OPTIONS=\"-l 192.168.90.70,::1\" #增加一行 3.启动Memcached服务并将其配置为在系统引导时启动： # systemctl enable memcached.service && systemctl start memcached.service 2.5 安装Etcd服务 以下操作在控制节点执行 OpenStack服务可能使用Etcd，这是一个可靠的分布式键值存储，用于分布式密钥锁定，存储配置，跟踪服务的实时性和其他场景。 1.安装软件包 [root@controller ~]# yum install etcd 2.编辑/etc/etcd/etcd.conf文件，以控制节点管理IP地址设置相关选项，以使其他节点通过管理网络进行访问 [root@controller ~]# vim /etc/etcd/etcd.conf #[Member] #ETCD_CORS=\"\" ETCD_DATA_DIR=\"/var/lib/etcd/default.etcd\" #ETCD_WAL_DIR=\"\" ETCD_LISTEN_PEER_URLS=\"http://192.168.90.70:2380\" ETCD_LISTEN_CLIENT_URLS=\"http://192.168.90.70:2379\" #ETCD_MAX_SNAPSHOTS=\"5\" #ETCD_MAX_WALS=\"5\" ETCD_NAME=\"controller\" #ETCD_SNAPSHOT_COUNT=\"100000\" #ETCD_HEARTBEAT_INTERVAL=\"100\" #ETCD_ELECTION_TIMEOUT=\"1000\" #ETCD_QUOTA_BACKEND_BYTES=\"0\" #ETCD_MAX_REQUEST_BYTES=\"1572864\" #ETCD_GRPC_KEEPALIVE_MIN_TIME=\"5s\" #ETCD_GRPC_KEEPALIVE_INTERVAL=\"2h0m0s\" #ETCD_GRPC_KEEPALIVE_TIMEOUT=\"20s\" # #[Clustering] ETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://192.168.90.70:2380\" ETCD_ADVERTISE_CLIENT_URLS=\"http://192.168.90.70:2379\" #ETCD_DISCOVERY=\"\" #ETCD_DISCOVERY_FALLBACK=\"proxy\" #ETCD_DISCOVERY_PROXY=\"\" #ETCD_DISCOVERY_SRV=\"\" ETCD_INITIAL_CLUSTER=\"controller=http://192.168.90.70:2380\" ETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster-01\" ETCD_INITIAL_CLUSTER_STATE=\"new\" #ETCD_STRICT_RECONFIG_CHECK=\"true\" #ETCD_ENABLE_V2=\"true\" 3.启动etcd服务并设为开机启动： [root@controller ~]# systemctl enable etcd && systemctl start etcd 3 安装OpenStack服务 1.Openstack Queens部署时至少需要安装以下服务，按照下面指定的顺序安装服务： 认证服务（Identity service）– keystone installation for Queens 镜像服务（Image service）– glance installation for Queens 计算服务（Compute service）– nova installation for Queens 网络服务（Networking service）– neutron installation for Queens 2.我们建议在最小部署以上服务后也安装以下组件： 仪表盘（Dashboard）– horizon installation for Queens 块存储服务（Block Storage service）– cinder installation for Queens 3.1 安装keystone服务 以下在控制节点执行 本节描述如何在控制节点上安装和配置OpenStack身份认证服务，即称为keystone。出于可扩展性的目的，此配置部署了Fernet tokens和Apache HTTP服务器来处理请求。 3.1.1 认证服务概述  OpenStack认证服务提供单一的集成点，用于管理身份验证、授权和服务目录。  认证服务通常是用户与之交互的第一个服务。一旦经过身份验证，最终用户可以使用其身份来访问其他OpenStack服务。同样，其他OpenStack服务利用认证服务来确保用户是他们本人，并且发现部署中的其他服务在哪里。认证服务还可以与一些外部用户管理系统（如LDAP）集成。  用户和服务可以通过使用由认证服务管理的服务目录来定位其他服务。顾名思义，服务目录是OpenStack部署中可用服务的集合。每个服务可以有一个或多个端点，每个端点可以是三种类型之一：管理员、内部或公共。在生产环境中，出于安全原因，不同的端点类型可能驻留在暴露给不同类型用户的单独网络上。例如，公共API网络可能从因特网上可见，因此客户可以管理他们的云。管理API网络可能局限于管理云基础设施的组织内的操作员。内部API网络可能局限于包含OpenStack服务的主机。此外，OpenStack支持多个区域的可扩展性。为了简单起见，本指南使用管理网络来实现所有端点类型和默认的TrimOne区域。在认证服务中创建的区域、服务和端点一起构成部署的服务目录。部署中的每个OpenStack服务需要一个服务条目，其中存储在标识服务中的相应端点。这一切都可以在认证服务安装和配置之后完成。 认证服务包含这些组件： Server 一个中央服务器使用RESTful接口提供认证和授权服务。 Drivers 驱动程序或服务后端集成到中央服务器。它们用于访问OpenStack外部的库中的身份信息，并且可能已经存在于部署OpenStack的基础设施中（例如，SQL数据库或LDAP服务器）。 Modules 中间件模块运行在使用认证服务的OpenStack组件的地址空间中。这些模块拦截服务请求，提取用户凭据，并将其发送到集中式服务器进行授权。中间件模块和OpenStack组件之间的集成使用Python Web服务器网关接口。 3.1.2 安装和配置keystone 创建keystone数据库 1.以root用户连接到数据库服务器： $ mysql -u root -p 2.创建keystone数据库： MariaDB [(none)]> CREATE DATABASE keystone; 3.授予keystone数据库适当的访问权限： MariaDB [(none)]> GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON keystone.* TO 'keystone'@'%' \\ IDENTIFIED BY '123456'; 注意：这里密码设置为123456 安装和配置keystone组件 1.安装软件包 # yum install openstack-keystone httpd mod_wsgi 2.编辑并修改/etc/keystone/keystone.conf配置文件 [root@controller ~]# vim /etc/keystone/keystone.conf 在 [database]部分, 配置数据库访问权限: [database] # ... connection = mysql+pymysql://keystone:123456@controller/keystone 注意这里的密码为123456 在[token] 部分, 配置Fernet token provider [token] # ... provider = fernet 3.同步认证服务数据库： # su -s /bin/sh -c \"keystone-manage db_sync\" keystone 4.初始化Fernet key库： # keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone # keystone-manage credential_setup --keystone-user keystone --keystone-group keystone 5.引导身份认证服务： # keystone-manage bootstrap --bootstrap-password 123456 \\ --bootstrap-admin-url http://controller:35357/v3/ \\ --bootstrap-internal-url http://controller:5000/v3/ \\ --bootstrap-public-url http://controller:5000/v3/ \\ --bootstrap-region-id RegionOne 替换ADMIN_PASS为管理用户的合适密码，这里为123456 配置apache http服务 1.编辑/etc/httpd/conf/httpd.conf文件并配置ServerName选项以引用控制节点： [root@controller ~]# vim /etc/httpd/conf/httpd.conf ServerName controller 2.创建到/usr/share/keystone/wsgi-keystone.conf文件的链接： [root@controller ~]# ln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/ 3.启动Apache HTTP服务并配置开机启动 [root@controller ~]# systemctl enable httpd.service && systemctl start httpd.service 4.配置administrative 账户 export OS_USERNAME=admin export OS_PASSWORD=123456 export OS_PROJECT_NAME=admin export OS_USER_DOMAIN_NAME=Default export OS_PROJECT_DOMAIN_NAME=Default export OS_AUTH_URL=http://controller:35357/v3 export OS_IDENTITY_API_VERSION=3 注意这里admin密码为123456，这里的密码要和keystone-manage bootstrap命令中使用的密码相同 3.1.3 创建项目和用户 身份服务为每个OpenStack服务提供身份验证服务。身份验证服务使用域，项目，用户和角色的组合（domain, projects, users, and roles）。 1.创建域,尽管上面keystone-manage bootstrap步骤已经存在“default”域，但创建新域的正式方法是： [root@controller ~]# openstack domain create --description \"Domain\" example +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | Domain | | enabled | True | | id | 2cb7b71c381c49179ad106c53fc78f20 | | name | example | | tags | [] | +-------------+----------------------------------+ 2.创建服务项目，本指南使用一个服务项目，其中包含您添加到环境中的每项服务的唯一用户。 [root@controller ~]# openstack project create - -domain default \\ -description \"Service Project\" service [root@controller ~]# openstack project create --domain default \\ > --description \"Service Project\" service +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | Service Project | | domain_id | default | | enabled | True | | id | 2699a653508e4300946837b129c3dcac | | is_domain | False | | name | service | | parent_id | default | | tags | [] | +-------------+----------------------------------+ 3.创建平台demon项目，普通（非管理员）任务应该使用非特权项目和用户。 作为示例，这里创建演示项目和用户。创建演示项目： [root@controller ~]# openstack project create - -domain default \\ -description \"Demo Project\" demo 执行结果： [root@controller ~]# openstack project create --domain default \\ > --description \"Demo Project\" demo +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | Demo Project | | domain_id | default | | enabled | True | | id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | is_domain | False | | name | demo | | parent_id | default | | tags | [] | +-------------+----------------------------------+ 4.创建demo用户 [root@controller ~]# openstack user create - -domain default \\ -password-prompt demo 执行结果： [root@controller ~]# openstack user create --domain default \\ > --password-prompt demo User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | a331e97f2ac6444484371a70e1299636 | | name | demo | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 5.创建用户角色： [root@controller ~]# openstack role create user +-----------+----------------------------------+ | Field | Value | +-----------+----------------------------------+ | domain_id | None | | id | 8e50219ae4a44daea5fba43dc3a3bdbc | | name | user | +-----------+----------------------------------+ 6.将用户角色添加到demo项目和用户： $ openstack role add --project demo --user demo user 注意：该命令没有输出，另外您可以重复此过程来创建其他项目和用户。 3.1.4 验证认证服务操作 1.取消设置临时OS_AUTH_URL和OS_PASSWORD环境变量： $ unset OS_AUTH_URL OS_PASSWORD 2.作为管理员用户，请求身份验证令牌 [root@controller ~]# openstack --os-auth-url http://controller:35357/v3 \\ --os-project-domain-name Default --os-user-domain-name Default \\ --os-project-name admin --os-username admin token issue 执行结果： ```bash [root@controller ~]# openstack --os-auth-url http://controller:35357/v3 \\ > --os-project-domain-name Default --os-user-domain-name Default \\ > --os-project-name admin --os-username admin token issue Password: +------------+----------------------------------------------------------------------- | Field | Value | +------------+----------------------------------------------------------------------- | expires | 2018-06-09T04:16:32+0000 | | id | gAAAAABbG0aQ7FW5iNpQsV6GeG3MScdTa-5R1X6P50quK1upikbaaRjGLyHjJ9DGAhYxwIRS5EQbFowGM48ihU--S5okbkP97my7WftHu3R13KV1aOClwT9zYKPziyoHuL4jUKLABtxAfDktz4He1BDrzA5EuQUnFlVTIv6plTWUJQUVHIpSGGs | | project_id | 9a8169bc534e4705816e97bff4d2866b | | user_id | fd008b033f4f48e2a17fc88686d89e88 | +------------+----------------------------------------------------------------------- 3.作为demo用户，请求身份验证令牌： [root@controller ~]# openstack --os-auth-url http://controller:5000/v3 \\ -os-project-domain-name Default --os-user-domain-name Default \\ -os-project-name demo --os-username demo token issue 执行结果： [root@controller ~]# openstack --os-auth-url http://controller:5000/v3 \\ > --os-project-domain-name Default --os-user-domain-name Default \\ > --os-project-name demo --os-username demo token issue Password: +------------+----------------------------------------------------------------------- | Field | Value | +------------+----------------------------------------------------------------------- | expires | 2018-06-09T04:17:53+0000 | | id | gAAAAABbG0bhmKyZk9WcBA79JucaEcdhkKh0Da5Fu1QfyukeajZEfHPb3ElV1wuRzn59qeL0Oz-AbzScWWodoAYiYRuRFPCL1aesbItKeBGDFSbd54bng4lsHmqSMmZ-lViOEkAZAcKNAU5Tp-sd4LmGSMsHC2mgffhjOFim4gcLFoWVT2Kq2u8 | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | user_id | a331e97f2ac6444484371a70e1299636 | +------------+----------------------------------------------------------------------- 注意：此命令使用演示用户和API端口5000的密码，该端口只允许对Identity Service API进行常规（非管理员）访问。 3.1.5 创建客户端环境脚本 前面几节使用了环境变量和命令选项的组合，通过openstack客户端与Identity服务进行交互。 为了提高客户端操作的效率，OpenStack支持简单的客户端环境脚本，也称为OpenRC文件。 这些脚本通常包含所有客户端的常用选项，但也支持独特的选项。 创建脚本 为管理员和演示项目和用户创建客户端环境脚本。后续所有操作将引用这些脚本来为客户端操作加载适当的凭据。 1.创建并编辑admin-openrc文件并添加以下内容： [root@controller ~]# vim admin-openrc export OS_PROJECT_DOMAIN_NAME=Default export OS_USER_DOMAIN_NAME=Default export OS_PROJECT_NAME=admin export OS_USERNAME=admin export OS_PASSWORD=123456 export OS_AUTH_URL=http://controller:5000/v3 export OS_IDENTITY_API_VERSION=3 export OS_IMAGE_API_VERSION=2 注意这里的admin用户密码为123456，替换为您在Identity Service中为admin用户设置的密码。 2.创建并编辑demo-openrc文件并添加以下内容： [root@controller ~]# vim demo-openrc export OS_PROJECT_DOMAIN_NAME=Default export OS_USER_DOMAIN_NAME=Default export OS_PROJECT_NAME=demo export OS_USERNAME=demo export OS_PASSWORD=123456 export OS_AUTH_URL=http://controller:5000/v3 export OS_IDENTITY_API_VERSION=3 export OS_IMAGE_API_VERSION=2 注意这里的demo用户密码为123456，替换为您在Identity Service中为demo用户设置的密码。 完成以后如下，我这里创建在/root目录下： [root@controller ~]# ll -rw-r--r-- 1 root root 262 Jun 9 11:20 admin-openrc -rw-r--r-- 1 root root 259 Jun 9 11:22 demo-openrc 使用脚本 要以特定项目和用户身份运行客户端，只需在运行客户端环境脚本之前加载相关的客户端环境脚本即可。 例如： 1.加载admin-openrc文件以使用Identity服务的位置以及管理项目和用户凭据执行环境变量： [root@controller ~]# . admin-openrc Request an authentication token: 2.请求身份验证令牌： [root@controller ~]# openstack token issue +------------+----------------------------------------------------------------------- | Field | Value | +------------+----------------------------------------------------------------------- | expires | 2018-06-09T04:25:27+0000 | | id | gAAAAABbG0inBBbRy30qPo674Pg5b6bxWNqRvtaOtc4j4U_88qtk_4U9xViPO3au2e_cGQw8s7b0mst9abScy6dEUVsEzQ042XgYnxarB-V7mAVXUevJCn9OV-FQdMlULZXcM0d4w4iVosOLpLdfsS27ZsVwYs_-r1_AohNGKAYAN2g77AOE_OY | | project_id | 9a8169bc534e4705816e97bff4d2866b | | user_id | fd008b033f4f48e2a17fc88686d89e88 | +------------+----------------------------------------------------------------------- 3.2 安装Glance服务 以下操作在控制节点执行 本节介绍如何在控制节点上安装和配置镜像服务，即glance。 为了简单起见，该配置将镜像存储在本地文件系统上。 3.2.1 镜像服务概述  镜像服务（glance）使用户能够发现，注册和检索虚拟机镜像。 它提供了一个REST API，使您可以查询虚拟机镜像元数据并检索实际镜像。 您可以将通过镜像服务提供的虚拟机映像存储在各种位置，从简单的文件系统到对象存储系统（如OpenStack对象存储）。  为了简单起见，本指南描述了将Image服务配置为使用文件后端，该后端上载并存储在托管Image服务的控制节点上的目录中。 默认情况下，该目录是/ var / lib / glance / images /。 OpenStack Image服务是基础架构即服务（IaaS）的核心。 它接受磁盘或服务器映像的API请求，以及来自最终用户或OpenStack Compute组件的元数据定义。 它还支持在各种存储库类型（包括OpenStack对象存储）上存储磁盘或服务器映像。 OpenStack镜像服务包括以下组件： glance-api 接受镜像API调用以进行镜像发现，检索和存储。 glance-registry 存储，处理和检索有关镜像的元数据。 元数据包括例如大小和类型等项目。 Database 存储镜像元数据，您可以根据自己的喜好选择数据库。 大多数部署使用MySQL或SQLite。 Storage repository for image files（镜像文件的存储库） 支持各种存储库类型，包括常规文件系统（或安装在glance-api控制节点上的任何文件系统），Object Storage，RADOS块设备，VMware数据存储和HTTP。 请注意，某些存储库仅支持只读用法。 Metadata definition service（元数据定义服务） 用于供应商，管理员，服务和用户的通用API来有意义地定义他们自己的定制元数据。 此元数据可用于不同类型的资源，如镜像，开发，卷，定制和聚合。 定义包括新属性的关键字，描述，约束和它可以关联的资源类型。 3.2.2 创建glance数据库 1.创建glance数据库 以root用户连接到数据库： # mysql -u root -p 创建glance数据库： MariaDB [(none)]> CREATE DATABASE glance; 授予对glance数据库的正确访问权限： MariaDB [(none)]> GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON glance.* TO 'glance'@'%' \\ IDENTIFIED BY '123456'; 2.获取admin用户的环境变量 $ . admin-openrc 3.要创建服务凭据，请完成以下步骤 创建glance用户： [root@controller ~]# openstack user create --domain default --password-prompt glance User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | 5480c338e19f42e59b35c7965d950fa6 | | name | glance | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 把admin角色添加到glance用户和项目中 $ openstack role add --project service --user glance admin 说明：此条命令执行不返回信息 创建glance服务实体： [root@controller ~]# openstack service create --name glance \\ --description \"OpenStack Image\" image 执行结果： [root@controller ~]# openstack service create --name glance --description \"OpenStack Image\" image +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | OpenStack Image | | enabled | True | | id | f776846b998a41859d7f93cac56cf4c0 | | name | glance | | type | image | +-------------+----------------------------------+ 4.创建镜像服务API端点 [root@controller ~]# openstack endpoint create --region RegionOne \\ image public http://controller:9292 [root@controller ~]# openstack endpoint create --region RegionOne \\ image internal http://controller:9292 [root@controller ~]# openstack endpoint create --region RegionOne \\ image admin http://controller:9292 执行结果： [root@controller ~]# openstack endpoint create --region RegionOne image public http://controller:9292 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 253e29a9b76648b1919d374eb10e152f | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | f776846b998a41859d7f93cac56cf4c0 | | service_name | glance | | service_type | image | | url | http://controller:9292 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > image internal http://controller:9292 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | a4e5834004af45279b20008f16bcb4b9 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | f776846b998a41859d7f93cac56cf4c0 | | service_name | glance | | service_type | image | | url | http://controller:9292 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > image admin http://controller:9292 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 46707abe74924e5096b150b70056247c | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | f776846b998a41859d7f93cac56cf4c0 | | service_name | glance | | service_type | image | | url | http://controller:9292 | +--------------+----------------------------------+ 3.2.3 安装和配置组件 1.安装软件包： # yum install openstack-glance 2.编辑/etc/glance/glance-api.conf文件，完成以下操作 # vim /etc/glance/glance-api.conf 在[database] 部分，配置数据库访问： [database] #.. connection = mysql+pymysql://glance:123456@controller/glance 在[keystone_authtoken] and [paste_deploy]部分,配置认证服务访问： [keystone_authtoken] auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = glance password = 123456 [paste_deploy] flavor = keystone 在 [glance_store]部分, 配置本地文件系统存储和映像文件的位置： [glance_store] stores = file,http default_store = file filesystem_store_datadir = /var/lib/glance/images/ 3.编辑/etc/glance/glance-registry.conf配置文件 # vim /etc/glance/glance-registry.conf 在[database]部分, 配置数据库访问： [database] connection = mysql+pymysql://glance:123456@controller/glance 在[keystone_authtoken] 和 [paste_deploy] 部分, 配置认证服务访问： [keystone_authtoken] auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = glance password = 123456 [paste_deploy] flavor = keystone 4.同步镜像服务数据库 # su -s /bin/sh -c \"glance-manage db_sync\" glance 5.完成安装,启动镜像服务并设为开机启动： # systemctl enable openstack-glance-api.service \\ openstack-glance-registry.service # systemctl start openstack-glance-api.service \\ openstack-glance-registry.service 3.2.4 验证操作 使用CirrOS验证Image服务的操作，这是一个小型Linux映像，可帮助您测试OpenStack部署。 有关如何下载和构建映像的更多信息，请参阅OpenStack虚拟机映像指南https://docs.openstack.org/image-guide/。有关如何管理映像的信息，请参阅OpenStack最终用户指南https://docs.openstack.org/queens/user/ 1.获取admin用户的环境变量 # . admin-openrc 2.下载镜像 # wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img 3.将镜像上传到image服务，指定磁盘格式为QCOW2，指定裸容器格式和公开可见性，以便所有项目都可以访问它： [root@controller ~]# openstack image create \"cirros\" --file cirros-0.4.0-x86_64-disk.img --disk-format qcow2 --container-format bare --public 执行结果： [root@controller ~]# openstack image create \"cirros\" \\ > --file cirros-0.4.0-x86_64-disk.img \\ > --disk-format qcow2 --container-format bare \\ > --public +------------------+------------------------------------------------------+ | Field | Value | +------------------+------------------------------------------------------+ | checksum | 443b7623e27ecf03dc9e01ee93f67afe | | container_format | bare | | created_at | 2018-06-09T07:25:34Z | | disk_format | qcow2 | | file | /v2/images/de140769-4ce3-4a1b-9651-07a915b21caa/file | | id | de140769-4ce3-4a1b-9651-07a915b21caa | | min_disk | 0 | | min_ram | 0 | | name | cirros | | owner | 9a8169bc534e4705816e97bff4d2866b | | protected | False | | schema | /v2/schemas/image | | size | 12716032 | | status | active | | tags | | | updated_at | 2018-06-09T07:25:34Z | | virtual_size | None | | visibility | public | +------------------+------------------------------------------------------+ 3.查看上传的镜像，镜像状态应为active状态 [root@controller ~]# openstack image list +--------------------------------------+--------+--------+ | ID | Name | Status | +--------------------------------------+--------+--------+ | de140769-4ce3-4a1b-9651-07a915b21caa | cirros | active | +--------------------------------------+--------+--------+ glance具体配置选项可参考： https://docs.openstack.org/glance/queens/configuration/index.html 3.3 安装compute服务 本节介绍如何在控制节点上安装和配置计算服务，代号为nova 3.3.1 计算服务概述  使用OpenStack Compute来托管和管理云计算系统。OpenStack Compute是基础架构即服务（IaaS）系统的重要组成部分。主要模块是用Python实现的。  OpenStack Compute与OpenStack Identity进行交互以进行身份验证; 用于磁盘和服务器映像的OpenStack映像服务; 和用于用户和管理界面的OpenStack Dashboard。镜像访问受到项目和用户的限制; 每个项目的限额是有限的（例如，实例的数量）。OpenStack Compute可以在标准硬件上水平扩展，并下载映像以启动实例。 OpenStack Compute包含以下内容及组件： nova-api service 接受并响应最终用户计算API调用。该服务支持OpenStack Compute API。它执行一些策略并启动大多数编排活动，例如运行实例。 nova-api-metadata service 接受来自实例的元数据请求。nova-api-metadata通常在nova-network 安装多主机模式下运行时使用该服务。有关详细信息，请参阅计算管理员指南中的元数据服务。 nova-compute service 通过管理程序API创建和终止虚拟机实例的工作守护程序。例如： XenAPI for XenServer/XCP libvirt for KVM or QEMU VMwareAPI for VMware 处理相当复杂。基本上，守护进程接受来自队列的动作并执行一系列系统命令，例如启动KVM实例并更新其在数据库中的状态。 nova-placement-api service 跟踪每个提供者的库存和使用情况。有关详情，请参阅 Placement API。 nova-scheduler service 从队列中获取虚拟机实例请求，并确定它在哪个计算服务器主机上运行。 nova-conductor module 调解nova-compute服务和数据库之间的交互。它消除了由nova-compute服务直接访问云数据库的情况 。该nova-conductor模块水平缩放。但是，请勿将其部署到nova-compute运行服务的节点上。有关更多信息，请参阅配置选项中的conductor部分 。 nova-consoleauth daemon（守护进程） 为控制台代理提供的用户授权令牌。见 nova-novncproxy和nova-xvpvncproxy。此服务必须运行以使控制台代理正常工作。您可以在群集配置中针对单个nova-consoleauth服务运行任一类型的代理。有关信息，请参阅关于nova-consoleauth。 nova-novncproxy daemon 提供通过VNC连接访问正在运行的实例的代理。支持基于浏览器的novnc客户端。 nova-spicehtml5proxy daemon 提供通过SPICE连接访问正在运行的实例的代理。支持基于浏览器的HTML5客户端。 nova-xvpvncproxy daemon 提供通过VNC连接访问正在运行的实例的代理。支持OpenStack特定的Java客户端。 The queue队列 守护进程之间传递消息的中心集线器。通常用RabbitMQ实现 ，也可以用另一个AMQP消息队列实现，例如ZeroMQ。 SQL database 存储云基础架构的大部分构建时间和运行时状态，其中包括： Available instance types 可用的实例类型 Instances in use 正在使用的实例 Available networks 可用的网络 Projects 项目 理论上，OpenStack Compute可以支持SQLAlchemy支持的任何数据库。通用数据库是用于测试和开发工作的SQLite3，MySQL，MariaDB和PostgreSQL。 3.3.2 安装和配置控制节点 以下在控制节点执行 3.3.2.1 创建数据库 1.以root账户登录数据库 # mysql -u root –p 2.创建nova_api, nova, nova_cell0数据库 MariaDB [(none)]> CREATE DATABASE nova_api; MariaDB [(none)]> CREATE DATABASE nova; MariaDB [(none)]> CREATE DATABASE nova_cell0; 数据库登录授权 MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'%' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'%' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'%' \\ IDENTIFIED BY '123456'; 2.执行admin-openrc凭证 [root@controller ~]# . admin-openrc 3.创建计算服务凭证 创建nova用户： [root@controller ~]# openstack user create --domain default --password-prompt nova User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | fb6776d19862405ba0c42ec91b6282a0 | | name | nova | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 为nova用户添加admin角色： # openstack role add --project service --user nova admin 创建nova服务端点： [root@controller ~]# openstack service create --name nova \\ -description \"OpenStack Compute\" compute 执行结果： [root@controller ~]# openstack service create --name nova \\ > --description \"OpenStack Compute\" compute +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | OpenStack Compute | | enabled | True | | id | f162653676dd41a2a4faa98ae64c33f1 | | name | nova | | type | compute | +-------------+----------------------------------+ 4.创建compute API 服务端点： [root@controller ~]# openstack endpoint create --region RegionOne \\ compute public http://controller:8774/v2.1 [root@controller ~]# openstack endpoint create --region RegionOne \\ compute admin http://controller:8774/v2.1 [root@controller ~]# openstack endpoint create --region RegionOne \\ compute admin http://controller:8774/v2.1 执行结果： [root@controller ~]# openstack endpoint create --region RegionOne \\ > compute public http://controller:8774/v2.1 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 84b34dc0bedc483990e32c48830368ab | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | f162653676dd41a2a4faa98ae64c33f1 | | service_name | nova | | service_type | compute | | url | http://controller:8774/v2.1 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > compute internal http://controller:8774/v2.1 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 2c253051b30444d9807a37bdb05c4c66 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | f162653676dd41a2a4faa98ae64c33f1 | | service_name | nova | | service_type | compute | | url | http://controller:8774/v2.1 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > compute admin http://controller:8774/v2.1 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 5aefc27a9f0440e2a95f1189e25f3822 | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | f162653676dd41a2a4faa98ae64c33f1 | | service_name | nova | | service_type | compute | | url | http://controller:8774/v2.1 | +--------------+----------------------------------+ 5.创建一个placement服务用户 [root@controller ~]# openstack user create --domain default --password-prompt placement User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | eb7cae6117f74fa6990f8e234efc9c82 | | name | placement | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 6.添加placement用户为项目服务admin角色 # openstack role add --project service --user placement admin 7.在服务目录中创建Placement API条目： [root@controller ~]# openstack service create --name placement --description \"Placement API\" placement +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | Placement API | | enabled | True | | id | 656007c5c64d4c3f91fd0dff1a32a754 | | name | placement | | type | placement | +-------------+----------------------------------+ 8.创建Placement API服务端点 [root@controller ~]# openstack endpoint create --region RegionOne placement public http://controller:8778 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 4a5b28fe29a94c03a4059d37388f88f1 | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | 656007c5c64d4c3f91fd0dff1a32a754 | | service_name | placement | | service_type | placement | | url | http://controller:8778 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne placement internal http://controller:8778 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 0f554f27f16c4387ac6a88e9f98697c4 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | 656007c5c64d4c3f91fd0dff1a32a754 | | service_name | placement | | service_type | placement | | url | http://controller:8778 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne placement admin http://controller:8778 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 3aa80b39dc244907a034bf6b4fcd12e2 | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | 656007c5c64d4c3f91fd0dff1a32a754 | | service_name | placement | | service_type | placement | | url | http://controller:8778 | +--------------+----------------------------------+ 3.3.2.2 安装和配置组件 1.安装软件包 # yum install openstack-nova-api openstack-nova-conductor \\ openstack-nova-console openstack-nova-novncproxy \\ openstack-nova-scheduler openstack-nova-placement-api 2.编辑 /etc/nova/nova.conf文件并完成以下操作 # vim /etc/nova/nova.conf 在 [DEFAULT] 部分, 只启用计算和元数据API： [DEFAULT] # ... enabled_apis = osapi_compute,metadata 在[api_database] 和 [database] 部分, 配置数据库访问: [api_database] # ... connection = mysql+pymysql://nova:123456@controller/nova_api [database] # ... connection = mysql+pymysql://nova:123456@controller/nova 在 [DEFAULT] 部分, 配置RabbitMQ 消息队列访问: [DEFAULT] # ... transport_url = rabbit://openstack:123456@controller 在[api] 和 [keystone_authtoken] 部分, 配置认证服务访问: [api] # ... auth_strategy = keystone [keystone_authtoken] # ... auth_url = http://controller:5000/v3 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = nova password = 123456 在[DEFAULT] 部分,使用控制节点的管理接口IP地址配置my_ip选项： [DEFAULT] # ... my_ip = 192.168.90.70 在[DEFAULT] 部分, 启用对网络服务的支持： [DEFAULT] # ... use_neutron = True firewall_driver = nova.virt.firewall.NoopFirewallDriver 在 [vnc] 部分,使用控制节点的管理接口IP地址配置VNC代理： [vnc] enabled = true # ... server_listen = $my_ip server_proxyclient_address = $my_ip 在[glance] 部分, 配置Image服务API的位置： [glance] # ... api_servers = http://controller:9292 在 [oslo_concurrency] 部分, 配置锁定路径： [oslo_concurrency] # ... lock_path = /var/lib/nova/tmp 在 [placement] 部分, 配置 Placement API: [placement] # ... os_region_name = RegionOne project_domain_name = Default project_name = service auth_type = password user_domain_name = Default auth_url = http://controller:5000/v3 username = placement password = 123456 由于软件包的一个bug，需要在/etc/httpd/conf.d/00-nova-placement-api.conf文件中添加如下配置，来启用对Placement API的访问： = 2.4> Require all granted Order allow,deny Allow from all 添加配置： [root@controller ~]# vim /etc/httpd/conf.d/00-nova-placement-api.conf Listen 8778 WSGIProcessGroup nova-placement-api WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On WSGIDaemonProcess nova-placement-api processes=3 threads=1 user=nova group=nova WSGIScriptAlias / /usr/bin/nova-placement-api = 2.4> ErrorLogFormat \"%M\" ErrorLog /var/log/nova/nova-placement-api.log #这里放在此行之后 = 2.4> Require all granted Order allow,deny Allow from all #SSLEngine On #SSLCertificateFile ... #SSLCertificateKeyFile ... Alias /nova-placement-api /usr/bin/nova-placement-api SetHandler wsgi-script Options +ExecCGI WSGIProcessGroup nova-placement-api WSGIApplicationGroup %{GLOBAL} WSGIPassAuthorization On 重新启动httpd服务 systemctl restart httpd 3.同步nova-api数据库 [root@controller ~]# su -s /bin/sh -c \"nova-manage api_db sync\" nova /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning 忽略此输出中的任何弃用消息。 4.注册cell0数据库 [root@controller ~]# su -s /bin/sh -c \"nova-manage cell_v2 map_cell0\" nova /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning 5.创建cell1 cell [root@controller ~]# su -s /bin/sh -c \"nova-manage cell_v2 create_cell --name=cell1 --verbose\" nova /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning f1c7672c-8127-4bc0-9f60-acc5364222dc 6.同步nova数据库 [root@controller ~]# su -s /bin/sh -c \"nova-manage db sync\" nova /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning /usr/lib/python2.7/site-packages/pymysql/cursors.py:166: Warning: (1831, u'Duplicate index `block_device_mapping_instance_uuid_virtual_name_device_name_idx`. This is deprecated and will be disallowed in a future release.') result = self._query(query) /usr/lib/python2.7/site-packages/pymysql/cursors.py:166: Warning: (1831, u'Duplicate index `uniq_instances0uuid`. This is deprecated and will be disallowed in a future release.') result = self._query(query) 7.验证 nova、 cell0、 cell1数据库是否注册正确 [root@controller ~]# nova-manage cell_v2 list_cells /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning +-------+--------------------------------------+------------------------------------ | Name | UUID | Transport URL | Database Connection | +-------+--------------------------------------+------------------------------------ | cell0 | 00000000-0000-0000-0000-000000000000 | none:/ | mysql+pymysql://nova:****@controller/nova_cell0 | | cell1 | f1c7672c-8127-4bc0-9f60-acc5364222dc | rabbit://openstack:****@controller | mysql+pymysql://nova:****@controller/nova | +-------+--------------------------------------+------------------------------------ 3.3.2.3 完成安装启动服务 启动计算服务并配置为开机启动 # systemctl enable openstack-nova-api.service \\ openstack-nova-consoleauth.service openstack-nova-scheduler.service \\ openstack-nova-conductor.service openstack-nova-novncproxy.service # systemctl start openstack-nova-api.service \\ openstack-nova-consoleauth.service openstack-nova-scheduler.service \\ openstack-nova-conductor.service openstack-nova-novncproxy.service 3.3.3 安装和配置计算节点 以下操作在计算节点执行 3.3.3.1 安装和配置组件 1.安装软件包 # yum install openstack-nova-compute 2.编辑/etc/nova/nova.conf配置文件并完成以下操作 # vim /etc/nova/nova.conf 在[DEFAULT] 部分, 只启用计算和元数据API： [DEFAULT] # ... enabled_apis = osapi_compute,metadata 在[DEFAULT] 部分, 配置RabbitMQ 消息队列访问: [DEFAULT] # ... transport_url = rabbit://openstack:123456@controller 在[api] 和 [keystone_authtoken] 部分, 配置认证服务访问: [api] # ... auth_strategy = keystone [keystone_authtoken] # ... auth_url = http://controller:5000/v3 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = nova password = 123456 在[DEFAULT] 部分, 配置 my_ip选项: [DEFAULT] # ... my_ip = 192.168.90.71 这里使用计算节点管理IP地址 在 [DEFAULT] 部分, 启用对网络服务的支持： [DEFAULT] # ... use_neutron = True firewall_driver = nova.virt.firewall.NoopFirewallDriver 在 [vnc] 部分, 启用和配置远程控制台访问： [vnc] # ... enabled = True server_listen = 0.0.0.0 server_proxyclient_address = $my_ip novncproxy_base_url = http://controller:6080/vnc_auto.html 服务器组件侦听所有IP地址，并且代理组件只侦听计算节点的管理接口IP地址。 基本URL指示您可以使用Web浏览器访问此计算节点上实例的远程控制台的位置。 如果用于访问远程控制台的Web浏览器驻留在无法解析控制器主机名的主机上，则必须用控制节点的管理接口IP地址替换控制器。 在 [glance] 部分, 配置Image服务API的位置： [glance] # ... api_servers = http://controller:9292 在 [oslo_concurrency]部分, 配置锁定路径： [oslo_concurrency] # ... lock_path = /var/lib/nova/tmp 在 [placement] 部分, 配置 Placement API: [placement] # ... os_region_name = RegionOne project_domain_name = Default project_name = service auth_type = password user_domain_name = Default auth_url = http://controller:5000/v3 username = placement password = 123456 3.3.3.2 完成配置启动服务 1.确定您的计算节点是否支持虚拟机的硬件加速： $ egrep -c '(vmx|svm)' /proc/cpuinfo 如果此命令返回值为1或更大，则您的计算节点支持通常不需要额外配置的硬件加速。 如果此命令返回零值，则您的计算节点不支持硬件加速，并且您必须配置libvirt才能使用QEMU而不是KVM。（我这里返回值为2，所有并没有执行下面这一步，配置文件未做任何更改） 在/etc/nova/nova.conf文件中编辑 [libvirt] 部分: # vim /etc/nova/nova.conf [libvirt] # ... virt_type = qemu 2.启动计算服务（包括其相关性），并将其配置为在系统引导时自动启动： # systemctl enable libvirtd.service openstack-nova-compute.service # systemctl start libvirtd.service openstack-nova-compute.service 注意：如果NOVA计算服务无法启动，检查/var/log/nova/nova-compute.log。控制节点上的错误消息AMQP服务器：5672是不可达的，可能指示控制节点上的防火墙阻止对端口5672的访问。配置防火墙以打开控制节点上的端口5672，并重新启动计算节点上的Nova计算服务。 如果想要清除防火墙规则执行以下命令： # iptables -F # iptables -X # iptables -Z 3.3.3.3 添加compute节点到cell数据库 以下在控制节点上执行 执行admin-openrc，验证有几个计算节点在数据库中 [root@controller ~]. admin-openrc [root@controller ~]# openstack compute service list --service nova-compute +----+--------------+----------+------+---------+-------+---------------------------- | ID | Binary | Host | Zone | Status | State | Updated At | +----+--------------+----------+------+---------+-------+----------------------------+ | 7 | nova-compute | compute1 | nova | enabled | up | 2018-06-09T16:57:28.000000 | +----+--------------+----------+------+---------+-------+---------------------------- 2.发现计算节点 [root@controller ~]# su -s /bin/sh -c \"nova-manage cell_v2 discover_hosts --verbose\" nova /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning Found 2 cell mappings. Skipping cell0 since it does not contain hosts. Getting computes from cell 'cell1': f1c7672c-8127-4bc0-9f60-acc5364222dc Checking host mapping for compute host 'compute1': 8ca1dfdc-5ed4-456b-a10e-a74b645fdbf8 Creating host mapping for compute host 'compute1': 8ca1dfdc-5ed4-456b-a10e-a74b645fdbf8 Found 1 unmapped computes in cell: f1c7672c-8127-4bc0-9f60-acc5364222dc 添加新计算节点时，必须在控制节点上运行nova-manage cell_v2 discover_hosts以注册这些新计算节点。 或者，您可以在/etc/nova/nova.conf中设置适当的时间间隔： [scheduler] discover_hosts_in_cells_interval = 300 3.3.4 验证计算服务操作 以下操作在控制节点执行 1.列出服务组件以验证每个进程成功启动和注册： [root@controller ~]#. admin-openrc [root@controller ~]# openstack compute service list +----+------------------+------------+----------+---------+-------+------------------ | ID | Binary | Host | Zone | Status | State | Updated At | +----+------------------+------------+----------+---------+-------+------------------ | 1 | nova-consoleauth | controller | internal | enabled | up | 2018-06-09T17:02:22.000000 | | 2 | nova-scheduler | controller | internal | enabled | up | 2018-06-09T17:02:14.000000 | | 3 | nova-conductor | controller | internal | enabled | up | 2018-06-09T17:02:23.000000 | | 7 | nova-compute | compute1 | nova | enabled | up | 2018-06-09T17:02:18.000000 | +----+------------------+------------+----------+---------+-------+------------------ 此输出应显示在控制节点上启用三个服务组件，并在计算节点上启用一个服务组件。 2.列出身份服务中的API端点以验证与身份服务的连接： [root@controller ~]# openstack catalog list +-----------+-----------+-----------------------------------------+ | Name | Type | Endpoints | +-----------+-----------+-----------------------------------------+ | keystone | identity | RegionOne | | | | admin: http://controller:35357/v3/ | | | | RegionOne | | | | public: http://controller:5000/v3/ | | | | RegionOne | | | | internal: http://controller:5000/v3/ | | | | | | placement | placement | RegionOne | | | | internal: http://controller:8778 | | | | RegionOne | | | | admin: http://controller:8778 | | | | RegionOne | | | | public: http://controller:8778 | | | | | | nova | compute | RegionOne | | | | internal: http://controller:8774/v2.1 | | | | RegionOne | | | | admin: http://controller:8774/v2.1 | | | | RegionOne | | | | public: http://controller:8774/v2.1 | | | | | | glance | image | RegionOne | | | | public: http://controller:9292 | | | | RegionOne | | | | admin: http://controller:9292 | | | | RegionOne | | | | internal: http://controller:9292 | | | | | +-----------+-----------+-----------------------------------------+ 3.列出Image服务中的镜像以验证与Image服务的连通性： [root@controller ~]# openstack image list +--------------------------------------+--------+--------+ | ID | Name | Status | +--------------------------------------+--------+--------+ | de140769-4ce3-4a1b-9651-07a915b21caa | cirros | active | +--------------------------------------+--------+--------+ 4.检查cells和placement API是否正常运行 [root@controller ~]# nova-status upgrade check /usr/lib/python2.7/site-packages/oslo_db/sqlalchemy/enginefacade.py:332: NotSupportedWarning: Configuration option(s) ['use_tpool'] not supported exception.NotSupportedWarning Option \"os_region_name\" from group \"placement\" is deprecated. Use option \"region-name\" from group \"placement\". +---------------------------+ | Upgrade Check Results | +---------------------------+ | Check: Cells v2 | | Result: Success | | Details: None | +---------------------------+ | Check: Placement API | | Result: Success | | Details: None | +---------------------------+ | Check: Resource Providers | | Result: Success | | Details: None | +---------------------------+ nova配置参考：https://docs.openstack.org/nova/queens/admin/index.html 3.4 安装neutron服务 3.4.1 网络服务概述  OpenStack Networking（neutron）允许您创建由其他OpenStack服务管理的接口设备并将其连接到网络。可以实现插件以适应不同的网络设备和软件，为OpenStack架构和部署提供灵活性。 网络服务包含以下组件： neutron-server 接受API请求并将其路由到适当的OpenStack Networking插件以便采取行动。 OpenStack Networking plug-ins and agents 插拔端口，创建网络或子网，并提供IP地址。这些插件和代理根据特定云中使用的供应商和技术而有所不同。OpenStack Networking带有用于思科虚拟和物理交换机，NEC OpenFlow产品，Open vSwitch，Linux桥接和VMware NSX产品的插件和代理。 通用代理是L3（第3层），DHCP（动态主机IP寻址）和插件代理。 Messaging queue 大多数OpenStack Networking安装用于在neutron-server和各种代理之间路由信息。还充当存储特定插件的网络状态的数据库。 OpenStack Networking主要与OpenStack Compute进行交互，为其实例提供网络和连接。 3.4.3 安装和配置controller节点 以下操作在控制节点执行 3.4.3.1 创建数据库 要创建数据库，需要完成以下操作 以root用户使用数据库连接客户端连接到数据库服务器： $ mysql -u root –p 创建neutron数据库: MariaDB [(none)] CREATE DATABASE neutron; 授予neutron数据库适当访问权，这里密码为123456: MariaDB [(none)]> GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'%' \\ IDENTIFIED BY '123456'; 2.加载管理员凭据以获得仅管理员访问的CLI命令： $ . admin-openrc 3.创建服务凭证，完成以下操作 创建neutron用户 [root@controller ~]# openstack user create --domain default --password-prompt neutron User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | 988aa6330c27474bb54b662aeb7173a7 | | name | neutron | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 添加admin角色到neutron用户 # openstack role add --project service --user neutron admin 创建neutron服务实体 [root@controller ~]# openstack service create --name neutron \\ -description \"OpenStack Networking\" network 执行结果： [root@controller ~]# openstack service create --name neutron \\ > --description \"OpenStack Networking\" network +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | OpenStack Networking | | enabled | True | | id | 2547ba8ceeb1436184e78e29017f8930 | | name | neutron | | type | network | +-------------+----------------------------------+ 4.创建网络服务API端点 $ openstack endpoint create --region RegionOne \\ network public http://controller:9696 $ openstack endpoint create --region RegionOne \\ network internal http://controller:9696 $ openstack endpoint create --region RegionOne \\ network admin http://controller:9696 执行结果： [root@controller ~]# openstack endpoint create --region RegionOne network public http://controller:9696 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 4008ce59ae324f59a1bcafd3d68df1b2 | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | cd9f54256386473b9a98a9422e274c5a | | service_name | neutron | | service_type | network | | url | http://controller:9696 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne network internal http://controller:9696 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 8d8aed23061a48f3a7b0a8aefb8d5681 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | cd9f54256386473b9a98a9422e274c5a | | service_name | neutron | | service_type | network | | url | http://controller:9696 | +--------------+----------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne network admin http://controller:9696 +--------------+----------------------------------+ | Field | Value | +--------------+----------------------------------+ | enabled | True | | id | 4bdb3e41746e4b2cbeadcf1fc5227363 | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | cd9f54256386473b9a98a9422e274c5a | | service_name | neutron | | service_type | network | | url | http://controller:9696 | +--------------+----------------------------------+ 3.4.3.2 配置网络部分 您可以使用选项1和2所代表的两种体系结构之一来部署网络服务。 选项1部署了仅支持将实例附加到提供者（外部）网络的最简单的可能架构。 没有自助服务（专用）网络，路由器或浮动IP地址。 只有管理员或其他特权用户才能管理提供商网络。 选项2增加了选项1，其中支持将实例附加到自助服务网络的第3层服务。 演示或其他非特权用户可以管理自助服务网络，包括提供自助服务和提供商网络之间连接的路由器。此外，浮动IP地址可提供与使用来自外部网络（如Internet）的自助服务网络的实例的连接。 自助服务网络通常使用隧道网络。隧道网络协议（如VXLAN），选项2还支持将实例附加到提供商网络。 以下两项配置二选一：  Networking Option 1: Provider networks  Networking Option 2: Self-service networks 这里选择Networking Option 2: Self-service networks 1.安装组件 # yum install openstack-neutron openstack-neutron-ml2 \\ openstack-neutron-linuxbridge ebtables 2.配置服务组件 编辑/etc/neutron/neutron.conf配置文件，并完成以下操作： # vim /etc/neutron/neutron.conf 在[database]部分, 配置数据库访问: [database] connection = mysql+pymysql://neutron:123456@controller/neutron 在[DEFAULT]部分, 启用模块化第2层（ML2）插件，路由器服务和overlapping IP addresses： [DEFAULT] # ... core_plugin = ml2 service_plugins = router allow_overlapping_ips = true 在 [DEFAULT] 部分, 配置RabbitMQ消息队列访问: [DEFAULT] # ... transport_url = rabbit://openstack:123456@controller 在 [DEFAULT]和 [keystone_authtoken]部分, 配置认证服务访问: [DEFAULT] # ... auth_strategy = keystone [keystone_authtoken] # ... auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = neutron password = 123456 在 [DEFAULT] 和[nova] 部分, 配置网络通知计算网络拓扑更改： [DEFAULT] # ... notify_nova_on_port_status_changes = true notify_nova_on_port_data_changes = true [nova] # ... auth_url = http://controller:35357 auth_type = password project_domain_name = default user_domain_name = default region_name = RegionOne project_name = service username = nova password = 123456 在 [oslo_concurrency] 部分,配置锁定路径： [oslo_concurrency] # ... lock_path = /var/lib/neutron/tmp 3.配置网络二层插件 ML2插件使用Linux桥接机制为实例构建第2层（桥接和交换）虚拟网络基础结构。 编辑/etc/neutron/plugins/ml2/ml2_conf.ini 文件并完成以下操作: # vim /etc/neutron/plugins/ml2/ml2_conf.ini 在 [ml2]部分,启用 flat, VLAN, and VXLAN 网络: [ml2] # ... type_drivers = flat,vlan,vxlan 在 [ml2]部分,启用VXLAN 自助服务网络: [ml2] # ... tenant_network_types = vxlan 在 [ml2]部分, 启用Linux网桥和第2层集群机制： [ml2] # ... mechanism_drivers = linuxbridge,l2population 在 [ml2]部分, 启用端口安全扩展驱动程序： [ml2] # ... extension_drivers = port_security 在 [ml2_type_flat] 部分, 将提供者虚拟网络配置为扁平网络： [ml2_type_flat] # ... flat_networks = provider 在 [ml2_type_vxlan] 部分, 为自助服务网络配置VXLAN网络标识符范围： [ml2_type_vxlan] # ... vni_ranges = 1:1000 在 [securitygroup] 部分, 启用ipset以提高安全组规则的效率： [securitygroup] # ... enable_ipset = true 4.配置linux网桥代理 Linux桥接代理为实例构建层-2（桥接和交换）虚拟网络基础结构，并处理安全组 编辑/etc/neutron/plugins/ml2/linuxbridge_agent.ini 文件并完成以下操作: # vim /etc/neutron/plugins/ml2/linuxbridge_agent.ini 在 [linux_bridge]部分, 将提供者虚拟网络映射到提供者物理网络接口 [linux_bridge] physical_interface_mappings = provider:ens38 注意：这里的ens38物理网卡是外部网络的网卡(underlying provider physical network interface)。 在[vxlan]部分中，启用vxlan隧道网络，配置处理隧道网络的物理网络接口的IP地址，并启用 layer-2 population： [vxlan] enable_vxlan = true local_ip = 192.168.91.70 l2_population = true 注意这里的ip地址192.168.91.70为隧道网络的ip地址（IP address of the underlying physical network interface that handles overlay networks） 在 [securitygroup]部分, 启用安全组并配置Linux网桥iptables防火墙驱动程序： [securitygroup] # enable_security_group = true firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver 通过验证下列所有SysTL值设置为1以确保Linux操作系统内核支持网桥过滤器： net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables $ vim /usr/lib/sysctl.d/00-system.conf net.bridge.bridge-nf-call-iptables=1 net.bridge.bridge-nf-call-ip6tables=1 $ sysctl -p 5.配置三层代理 Layer-3（L3）代理为自助虚拟网络提供路由和NAT服务。 编辑/etc/neutron/l3_agent.ini 文件并完成以下操作： $ vim /etc/neutron/l3_agent.ini 在 [DEFAULT]部分, 配置Linux网桥接口驱动程序和外部网络桥接器： [DEFAULT] interface_driver = linuxbridge 7.配置DHCP代理 DHCP代理为虚拟网络提供DHCP服务。 编辑/etc/neutron/dhcp_agent.ini文件并完成以下操作： $ vim /etc/neutron/dhcp_agent.ini 在[DEFAULT]部分，配置Linux网桥接口驱动程序，Dnsmasq DHCP驱动程序，并启用隔离的元数据，以便提供商网络上的实例可以通过网络访问元数据： [DEFAULT] # ... interface_driver = linuxbridge dhcp_driver = neutron.agent.linux.dhcp.Dnsmasq enable_isolated_metadata = true 3.4.3.5 配置metadata 元数据代理为实例提供配置信息，例如凭据。 编辑 /etc/neutron/metadata_agent.ini文件并完成以下操作： # vim /etc/neutron/metadata_agent.ini [DEFAULT] nova_metadata_host = controller metadata_proxy_shared_secret = 123456 3.4.3.6 配置计算服务使用网络服务 编辑/etc/nova/nova.conf文件并执行以下操作： # vim /etc/nova/nova.conf 在[neutron]部分，配置访问参数，启用元数据代理并配置秘密： [neutron] url = http://controller:9696 auth_url = http://controller:35357 auth_type = password project_domain_name = default user_domain_name = default region_name = RegionOne project_name = service username = neutron password = 123456 service_metadata_proxy = true metadata_proxy_shared_secret = 123456 3.4.3.7 完成安装启动服务 1.网络服务初始化脚本需要一个指向ML2插件配置文件/etc/neutron/plugins/ml2/ml2_conf.ini的符号链接/etc/neutron/plugin.ini。 如果此符号链接不存在，请使用以下命令创建它： # ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini 2.同步数据库 # su -s /bin/sh -c \"neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head\" neutron 3.重启compute API服务 #systemctl restart openstack-nova-api.service 4.启动网络服务并设为开机启动 # systemctl enable neutron-server.service \\ neutron-linuxbridge-agent.service neutron-dhcp-agent.service \\ neutron-metadata-agent.service # systemctl start neutron-server.service \\ neutron-linuxbridge-agent.service neutron-dhcp-agent.service \\ neutron-metadata-agent.service 5.对于联网选项2，还启用并启动第三层服务： # systemctl enable neutron-l3-agent.service && systemctl start neutron-l3-agent.service 3.4.4 安装和配置compute节点 以下操作在计算节点执行 计算节点处理实例的连接和安全组。 3.4.4.1 安装和配置组件 1.安装组件 # yum install openstack-neutron-linuxbridge ebtables ipset 2.配置公共组件 网络通用组件配置包括身份验证机制，消息队列和插件。 编辑/etc/neutron/neutron.conf文件并完成以下操作： 在[database]部分，注释掉任何connection选项，因为计算节点不直接访问数据库。 # vim /etc/neutron/neutron.conf 在[DEFAULT]部分中，配置RabbitMQ 消息队列访问： [DEFAULT] ... transport_url = rabbit://openstack:123456@controller 在[DEFAULT]和[keystone_authtoken]部分中，配置身份服务访问： [DEFAULT] ＃... auth_strategy = keystone [keystone_authtoken] ＃... auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_name = default user_domain_name = default project_name = service username = neutron password = 123456 在[oslo_concurrency]部分中，配置锁定路径： [oslo_concurrency] ＃... lock_path = /var/lib/neutron/tmp 3.4.4.2 配置网络部分 选择您为控制器节点选择的相同网络选项以配置特定的服务。 之后，返回此处并继续配置计算服务以使用网络服务。  网络选项1：提供商网络  网络选项2：自助服务网络 这里选择网络选项2：自助服务网络 1.配置Linux网桥 编辑/etc/neutron/plugins/ml2/linuxbridge_agent.ini文件并完成以下操作： # vim /etc/neutron/plugins/ml2/linuxbridge_agent.ini 在[vxlan]部分中，启用VXLAN隧道网络，配置处理隧道网络的物理网络接口的IP地址，并启用第2层群体： [vxlan] enable_vxlan = true local_ip = 192.168.91.71 l2_population = true 注意：这里的192.168.91.71为计算节点隧道网络的IP地址（underlying physical network interface that handles overlay networks） 在[securitygroup]节中，启用安全组并配置Linux网桥iptables防火墙驱动程序： [securitygroup] # ... enable_security_group = true firewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver 配置计算服务使用网络服务 编辑/etc/nova/nova.conf vim /etc/nova/nova.conf [neutron] url = http://controller:9696 auth_url = http://controller:35357 auth_type = password project_domain_name = default user_domain_name = default region_name = RegionOne project_name = service username = neutron password = 123456 确保您的Linux操作系统内核支持网桥过滤器，方法是验证以下所有sysctl值均设置为1： net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables $ vim /usr/lib/sysctl.d/00-system.conf net.bridge.bridge-nf-call-iptables=1 net.bridge.bridge-nf-call-ip6tables=1 $ sysctl -p 3.4.4.5 完成安装启动服务 1.重启compute服务 # systemctl restart openstack-nova-compute.service 2.设置网桥服务开机启动 # systemctl enable neutron-linuxbridge-agent.service && systemctl start neutron-linuxbridge-agent.service 3.5 安装Horizon服务 以下操作在控制节点执行 本节介绍如何在控制节点上安装和配置仪表板。 仪表板所需的唯一核心服务是身份服务。 您可以将仪表板与其他服务结合使用，例如镜像服务，计算和网络。 您还可以在具有独立服务（如对象存储）的环境中使用仪表板。 3.5.1 安装和配置组件 1.安装软件包 # yum install openstack-dashboard -y 2.编辑 /etc/openstack-dashboard/local_settings 文件并完成以下操作： # vim /etc/openstack-dashboard/local_settings 配置仪表板以在controller节点上使用OpenStack服务 ： OPENSTACK_HOST = \"controller\" 允许您的主机访问仪表板： ALLOWED_HOSTS = ['*'] 或者ALLOWED_HOSTS = ['one.example.com', 'two.example.com'] ALLOWED_HOSTS也可以['*']接受所有主机。这对开发工作可能有用，但可能不安全，不应用于生产。 配置memcache会话存储服务： SESSION_ENGINE = 'django.contrib.sessions.backends.cache' CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', 'LOCATION': 'controller:11211', } } 注释掉任何其他会话存储配置。 开启身份认证API 版本v3 OPENSTACK_KEYSTONE_URL = \"http://%s:5000/v3\" % OPENSTACK_HOST 启用对域的支持： OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True 配置API版本: OPENSTACK_API_VERSIONS = { \"identity\": 3, \"image\": 2, \"volume\": 2, } 配置Default为您通过仪表板创建的用户的默认域： OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = \"Default\" 将用户配置为通过仪表板创建的用户的默认角色： OPENSTACK_KEYSTONE_DEFAULT_ROLE = \"user\" 配置时区（可选） TIME_ZONE = \"Asia/Shanghai\" 4.如果未包括，则将以下行添加到/etc/httpd/conf.d/openstack-dashboard.conf。 # vim /etc/httpd/conf.d/openstack-dashboard.conf WSGIApplicationGroup %{GLOBAL} 3.5.2 完成安装启动服务 1.完成安装，重启web服务和会话存储 # systemctl restart httpd.service memcached.service 3.5.3 登录web验证配置 在浏览器中输入http://192.168.90.70/dashboard.,访问openstack的dashboard界面， domain:default 用户名（管理员）:admin（管理员），demo(租户) 密码:123456 登录界面如下： 当前的项目信息： 当前上传的镜像： 3.6 安装Cinder服务  块存储服务（cinder）为访客实例提供块存储设备。 存储配置和使用的方法由块存储驱动程序确定，或者在多后端配置的情况下由驱动程序确定。 有多种可用的驱动程序：NAS / SAN，NFS，iSCSI，Ceph等。  块存储API和调度程序服务通常在控制节点上运行。 根据所使用的驱动程序，卷服务可以在控制节点，计算节点或独立存储节点上运行。  一旦能够在OpenStack环境中“启动实例”，请按照以下说明将Cinder添加到基本环境。 3.6.1 块存储服务概述  OpenStack块存储服务（Cinder）将持久性存储添加到虚拟机。块存储为管理卷提供基础架构，并与OpenStack Compute进行交互以提供实例卷。该服务还支持管理卷快照和卷类型。 块存储服务包含以下组件： cinder-api 接受API请求，并将它们路由到cinder-volume操作。 cinder-volume 直接与Block Storage服务进行交互，以及诸如cinder-scheduler。它也通过消息队列与这些进程交互。该cinder-volume服务响应发送到块存储服务的读取和写入请求以保持状态。它可以通过驱动程序架构与各种存储提供商进行交互。 cinder-scheduler daemon守护进程 选择要在其上创建卷的最佳存储提供者节点。 与nova-scheduler类似的组件。 cinder-backup daemon守护进程 该cinder-backup服务可将任何类型的卷备份到备份存储提供程序。与cinder-volume服务一样，它可以通过驱动程序体系结构与各种存储提供商进行交互。 Messaging queue消息队列 路由块存储过程之间的信息。 3.6.2 安装和配置cinder节点 以下操作在cinder节点执行 3.6.2.1 安装配置LVM  本节介绍如何为Block Storage服务安装和配置存储节点。 为简单起见，此配置引用具有空本地块存储设备的一个存储节点。 这些指令使用/ dev / sdb，但您可以将特定节点的值替换为不同的值。  该服务使用LVM驱动程序在该设备上配置逻辑卷，并通过iSCSI传输将其提供给实例。 您可以按照这些说明进行小的修改，以便使用其他存储节点水平扩展您的环境。 1.安装支持的软件包 安装LVM软件包 # yum install lvm2 device-mapper-persistent-data 启动LVM元数据服务并将其配置为在系统引导时启动： # systemctl enable lvm2-lvmetad.service && systemctl start lvm2-lvmetad.service 说明：一些发行版默认包含LVM。 2.创建LVM物理逻辑卷/dev/sdb [root@cinder1 ~]# pvcreate /dev/sdb Physical volume \"/dev/sdb\" successfully created. 3.创建cinder-volumes逻辑卷组 [root@cinder ~]# vgcreate cinder-volumes /dev/sdb Volume group \"cinder-volumes\" successfully created 4 .只有实例才能访问块存储卷。 但是，底层操作系统管理与卷关联的设备。 默认情况下，LVM卷扫描工具会扫描包含卷的块存储设备的/ dev目录。 如果项目在其卷上使用LVM，则扫描工具将检测这些卷并尝试缓存它们，这可能会导致底层操作系统和项目卷出现各种问题。 您必须重新配置LVM以仅扫描包含cinder-volumes卷组的设备。 编辑/etc/lvm/lvm.conf文件并完成以下操作： 在devices部分中，添加一个接受/ dev / sdb设备的过滤器并拒绝所有其他设备： # vim /etc/lvm/lvm.conf devices { ... filter = [ \"a/sdb/\", \"r/.*/\"] Each item in the filter array begins with a for accept or r for reject and includes a regular expression for the device name. The array must end with r/./ to reject any remaining devices. You can use the vgs -vvvv command to test filters. 过滤器数组中的每个项目都以for接受或r为拒绝开头，并包含设备名称的正则表达式。 该阵列必须以r /./结尾以拒绝任何剩余的设备。 您可以使用vgs -vvvv命令来测试过滤器。 如果您的存储节点在操作系统磁盘上使用LVM，则还必须将关联的设备添加到过滤器。 例如，如果/ dev / sda设备包含操作系统： filter = [ \"a/sda/\", \"a/sdb/\", \"r/.*/\"] 同样，如果您的计算节点在操作系统磁盘上使用LVM，则还必须修改这些节点上/etc/lvm/lvm.conf文件中的筛选器以仅包含操作系统磁盘。 例如，如果/ dev / sda设备包含操作系统： filter = [ \"a/sda/\", \"r/.*/\"] 3.6.2.2 安装和配置组件 1.安装软件包 # yum install openstack-cinder targetcli python-keystone -y 编辑/etc/cinder/cinder.conf文件并完成以下操作： # vim /etc/cinder/cinder.conf 在[database]部分中，配置数据库访问： [database] connection = mysql+pymysql://cinder:123456@controller/cinder 在该[DEFAULT]部分中，配置RabbitMQ 消息队列访问： [DEFAULT] transport_url = rabbit://openstack:123456@controller 在[DEFAULT]和[keystone_authtoken]部分中，配置身份服务访问： [DEFAULT] auth_strategy = keystone [keystone_authtoken] auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_id = default user_domain_id = default project_name = service username = cinder password = 123456 在[DEFAULT]部分中，配置my_ip选项： my_ip = 192.168.90.72 注意这里的192.168.90.72为存储节点上管理网络接口的IP地址 在[lvm]部分中，使用LVM驱动程序，cinder-volumes卷组，iSCSI协议和相应的iSCSI服务配置LVM后端。如果该[lvm]部分不存在，请创建它： [lvm] volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver volume_group = cinder-volumes iscsi_protocol = iscsi iscsi_helper = lioadm 在[DEFAULT]部分中，启用LVM后端： [DEFAULT] ＃... enabled_backends = lvm 后端名称是任意的。作为示例，本指南使用驱动程序的名称作为后端的名称。 在[DEFAULT]部分中，配置Image Service API的位置： [DEFAULT] ＃... glance_api_servers = http://controller:9292 在[oslo_concurrency]部分中，配置锁定路径： [oslo_concurrency] ＃... lock_path = /var/lib/cinder/tmp 3.6.2.3 完成安装启动服务 设置存储服务开机启动 # systemctl enable openstack-cinder-volume.service target.service # systemctl start openstack-cinder-volume.service target.service 3.6.3 安装和配置controller节点 本节介绍如何在控制节点上安装和配置代码为cinder的块存储服务。 此服务至少需要一个为实例提供卷的额外存储节点。 以下操作在控制节点执行 3.6.3.1 创建cinder数据库 在安装和配置块存储服务之前，您必须创建数据库，服务凭据和API端点。 要创建数据库，请完成以下步骤： 1.使用数据库访问客户端以root用户身份连接到数据库服务器： $ mysql -u root -p 创建cinder数据库： MariaDB [(none)]> CREATE DATABASE cinder; 授予对cinder数据库的适当访问权限： MariaDB [(none)]> GRANT ALL PRIVILEGES ON cinder.* TO 'cinder'@'localhost' \\ IDENTIFIED BY '123456'; MariaDB [(none)]> GRANT ALL PRIVILEGES ON cinder.* TO 'cinder'@'%' \\ IDENTIFIED BY '123456'; 2.加载admin凭据 $ . admin-openrc 3.要创建服务凭据，请完成以下步骤： 创建一个cinder用户： [root@controller ~]# openstack user create --domain default --password-prompt cinder User Password: Repeat User Password: +---------------------+----------------------------------+ | Field | Value | +---------------------+----------------------------------+ | domain_id | default | | enabled | True | | id | 2df1d57dd00a418080d3b5ed8eb4c2a0 | | name | cinder | | options | {} | | password_expires_at | None | +---------------------+----------------------------------+ 添加admin角色到cinder用户： $ openstack role add --project service --user cinder admin 注意，此命令无输出结果 创建cinderv2和cinderv3服务实体： # openstack service create --name cinderv2 \\ - -description \"OpenStack Block Storage\" volumev2 # openstack service create --name cinderv3 \\ - -description \"OpenStack Block Storage\" volumev3 执行结果： [root@controller ~]# openstack service create --name cinderv2 \\ > --description \"OpenStack Block Storage\" volumev2 +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | OpenStack Block Storage | | enabled | True | | id | 3644ab2053cb4ab5b5e754548f6276fa | | name | cinderv2 | | type | volumev2 | +-------------+----------------------------------+ [root@controller ~]# openstack service create --name cinderv3 \\ > --description \"OpenStack Block Storage\" volumev3 +-------------+----------------------------------+ | Field | Value | +-------------+----------------------------------+ | description | OpenStack Block Storage | | enabled | True | | id | a220c2f4900c4622a6cd65a5f093cddb | | name | cinderv3 | | type | volumev3 | +-------------+----------------------------------+ 注意：块存储服务需要两个服务实体。 4.创建块存储服务API端点： [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev2 public http://controller:8776/v2/%\\(project_id\\)s [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev2 internal http://controller:8776/v2/%\\(project_id\\)s [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev2 admin http://controller:8776/v2/%\\(project_id\\)s [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev3 public http://controller:8776/v3/%\\(project_id\\)s [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev3 internal http://controller:8776/v3/%\\(project_id\\)s [root@controller ~]# openstack endpoint create --region RegionOne \\ volumev3 admin http://controller:8776/v3/%\\(project_id\\)s 执行结果： [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev2 public http://controller:8776/v2/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | d79c21958c104b73998b8a0a2656ac1a | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | 3644ab2053cb4ab5b5e754548f6276fa | | service_name | cinderv2 | | service_type | volumev2 | | url | http://controller:8776/v2/%(project_id)s | +--------------+------------------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev2 internal http://controller:8776/v2/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | f267e9427c8d4087b457a5ec7342ace4 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | 3644ab2053cb4ab5b5e754548f6276fa | | service_name | cinderv2 | | service_type | volumev2 | | url | http://controller:8776/v2/%(project_id)s | +--------------+------------------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev2 admin http://controller:8776/v2/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | c89c663ccee14ecd826f3402446f9f74 | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | 3644ab2053cb4ab5b5e754548f6276fa | | service_name | cinderv2 | | service_type | volumev2 | | url | http://controller:8776/v2/%(project_id)s | +--------------+------------------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev3 public http://controller:8776/v3/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | 03ffabf166eb4d51959f9bafd9b75ad4 | | interface | public | | region | RegionOne | | region_id | RegionOne | | service_id | a220c2f4900c4622a6cd65a5f093cddb | | service_name | cinderv3 | | service_type | volumev3 | | url | http://controller:8776/v3/%(project_id)s | +--------------+------------------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev3 internal http://controller:8776/v3/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | 8aca3fa06384499fbcec3f6ed5fb6299 | | interface | internal | | region | RegionOne | | region_id | RegionOne | | service_id | a220c2f4900c4622a6cd65a5f093cddb | | service_name | cinderv3 | | service_type | volumev3 | | url | http://controller:8776/v3/%(project_id)s | +--------------+------------------------------------------+ [root@controller ~]# openstack endpoint create --region RegionOne \\ > volumev3 admin http://controller:8776/v3/%\\(project_id\\)s +--------------+------------------------------------------+ | Field | Value | +--------------+------------------------------------------+ | enabled | True | | id | 3cef8b97ec5543a1a3435c6f2df133db | | interface | admin | | region | RegionOne | | region_id | RegionOne | | service_id | a220c2f4900c4622a6cd65a5f093cddb | | service_name | cinderv3 | | service_type | volumev3 | | url | http://controller:8776/v3/%(project_id)s | +--------------+------------------------------------------+ 3.6.3.2 安装和配置组件 1.安装软件包： # yum install openstack-cinder 2.编辑/etc/cinder/cinder.conf文件并完成以下操作： # vim /etc/cinder/cinder.conf 在[database]部分中，配置数据库访问： [database] # ... connection = mysql+pymysql://cinder:123456@controller/cinder 在[DEFAULT]部分中，配置RabbitMQ 消息队列访问： [DEFAULT] # ... transport_url = rabbit://openstack:123456@controller 在[DEFAULT]和[keystone_authtoken]部分中，配置身份服务访问： [DEFAULT] # ... auth_strategy = keystone [keystone_authtoken] # ... auth_uri = http://controller:5000 auth_url = http://controller:35357 memcached_servers = controller:11211 auth_type = password project_domain_id = default user_domain_id = default project_name = service username = cinder password = 123456 在[DEFAULT]部分中，将该my_ip选项配置为使用控制节点的管理接口IP地址： [DEFAULT] # ... my_ip = 192.168.90.70 在该[oslo_concurrency]部分中，配置锁定路径： [oslo_concurrency] ＃... lock_path = /var/lib/cinder/tmp 4.同步块存储数据库： # su -s /bin/sh -c \"cinder-manage db sync\" cinder Option \"logdir\" from group \"DEFAULT\" is deprecated. Use option \"log-dir\" from group \"DEFAULT\". 忽略此输出中的任何弃用消息。 3.6.3.3 配置计算服务使用块存储 编辑/etc/nova/nova.conf文件并添加以下内容： # vim /etc/nova/nova.conf [cinder] os_region_name = RegionOne 3.6.3.4 完成安装启动服务 重新启动Compute API服务： # systemctl restart openstack-nova-api.service 启动块存储服务并将其配置为在系统引导时启动： # systemctl enable openstack-cinder-api.service openstack-cinder-scheduler.service # systemctl start openstack-cinder-api.service openstack-cinder-scheduler.service 3.6.4 验证cinder配置 验证Cinder操作,在控制器节点上执行这些命令。 1.输入管理员凭据以访问仅限管理员的CLI命令： $ . admin-openrc 列出服务组件以验证每个进程的成功启动： [root@controller ~]# openstack volume service list +------------------+-------------+------+---------+-------+-------------------------- | Binary | Host | Zone | Status | State | Updated At | +------------------+-------------+------+---------+-------+-------------------------- | cinder-volume | cinder1@lvm | nova | enabled | up | 2018-06-10T10:35:37.000000 | | cinder-scheduler | controller | nova | enabled | up | 2018-06-10T10:35:38.000000 | +------------------+-------------+------+---------+-------+-------------------------- 4 创建虚拟机实例 创建过程: 1) 创建虚拟网络 2) 创建m1.nano规格的主机（相等于定义虚拟机的硬件配置） 3) 生成一个密钥对（openstack的原理是不使用密码连接，而是使用密钥对进行连接） 4) 增加安全组规则（用iptables做的安全组） 5) 启动一个实例（启动虚拟机有三种类型：1.命令CLI 2.api 3.Dashboard）实际上Dashboard也是通过api进行操作 6) 虚拟网络分为提供者网络和私有网络，提供者网络就是跟主机在同一个网络里，私有网络自定义路由器等，跟主机不在一个网络 4.1 创建外部网络 以下所有操作在控制节点执行 为配置Neutron时选择的网络选项创建虚拟网络。 如果您选择选项1，则只创建提供商网络。 如果您选择了选项2，请创建提供商和自助服务网络。  Provider network  Self-service network 在为您的环境创建适当的网络后，您可以继续准备环境以启动实例。 提供者网络-provider网络 在启动实例之前，您必须创建必要的虚拟网络基础结构,管理员或其他特权用户必须创建此网络，因为它直接连接到物理网络基础结构。 4.1.1 创建provider外部网络 在控制节点上，获取admin用户凭证以访问仅管理员的CLI命令： $ . admin-openrc 创建虚拟网络（网络名为provider）： $ openstack network create --share --external \\ --provider-physical-network provider \\ --provider-network-type flat provider 执行结果： [root@controller ~]# openstack network create --share --external \\ > --provider-physical-network provider \\ > --provider-network-type flat provider +---------------------------+--------------------------------------+ | Field | Value | +---------------------------+--------------------------------------+ | admin_state_up | UP | | availability_zone_hints | | | availability_zones | | | created_at | 2018-06-10T14:25:42Z | | description | | | dns_domain | None | | id | 891787bb-ce4a-4b41-b222-1493ec30035c | | ipv4_address_scope | None | | ipv6_address_scope | None | | is_default | False | | is_vlan_transparent | None | | mtu | 1500 | | name | provider | | port_security_enabled | True | | project_id | 9a8169bc534e4705816e97bff4d2866b | | provider:network_type | flat | | provider:physical_network | provider | | provider:segmentation_id | None | | qos_policy_id | None | | revision_number | 5 | | router:external | External | | segments | None | | shared | True | | status | ACTIVE | | subnets | | | tags | | | updated_at | 2018-06-10T14:25:43Z | +---------------------------+--------------------------------------+ 参数说明： -share选项允许所有项目使用虚拟网络。 -external选项将虚拟网络定义为外部。 如果你想创建一个内部网络，你可以使用--internal代替。 默认值是内部的。 --provider-physical-network提供者和--provider-network-type平面选项使用来自以下文件的信息将扁平虚拟网络连接到主机上eth1接口上的扁平（本地/非标记）物理网络： ml2_conf.ini: [ml2_type_flat] flat_networks = provider linuxbridge_agent.ini: [linux_bridge] physical_interface_mappings = provider:ens38 使用命令查看创建的网络： [root@controller ~]# openstack network list +--------------------------------------+----------+--------------------------------------+ | ID | Name | Subnets | +--------------------------------------+----------+--------------------------------------+ | 891787bb-ce4a-4b41-b222-1493ec30035c | provider | 20b98341-041f-4b66-973d-ebb3a42415a2 | +--------------------------------------+----------+--------------------------------------+ 以admin用户登录dashboard查看创建的网络： 查看网络拓扑图： 4.1.2 网络中创建子网 在外部网络上创建一个子网： # openstack subnet create --network provider \\ --allocation-pool start=192.168.92.80,end=192.168.92.90 \\ --dns-nameserver 114.114.114.114 --gateway 192.168.92.2 \\ --subnet-range 192.168.92.0/24 provider 执行结果： [root@controller ~]# openstack subnet create --network provider \\ > --allocation-pool start=192.168.92.80,end=192.168.92.90 \\ > --dns-nameserver 114.114.114.114 --gateway 192.168.92.2 \\ > --subnet-range 192.168.92.0/24 provider +-------------------+--------------------------------------+ | Field | Value | +-------------------+--------------------------------------+ | allocation_pools | 192.168.92.80-192.168.92.90 | | cidr | 192.168.92.0/24 | | created_at | 2018-06-10T14:48:05Z | | description | | | dns_nameservers | 114.114.114.114 | | enable_dhcp | True | | gateway_ip | 192.168.92.2 | | host_routes | | | id | 639dcbb3-9bdf-4db8-9734-c4556f1e7972 | | ip_version | 4 | | ipv6_address_mode | None | | ipv6_ra_mode | None | | name | provider | | network_id | 891787bb-ce4a-4b41-b222-1493ec30035c | | project_id | 9a8169bc534e4705816e97bff4d2866b | | revision_number | 0 | | segment_id | None | | service_types | | | subnetpool_id | None | | tags | | | updated_at | 2018-06-10T14:48:05Z | +-------------------+--------------------------------------+ 参数说明 用CIDR表示法将PROVIDER_NETWORK_CIDR替换为提供商物理网络上的子网。 将START_IP_ADDRESS和END_IP_ADDRESS替换为要为实例分配的子网内范围的第一个和最后一个IP地址。 该范围不得包含任何现有的活动IP地址。 将DNS_RESOLVER替换为DNS解析器的IP地址。 在大多数情况下，您可以使用主机上/etc/resolv.conf文件中的一个。 将PROVIDER_NETWORK_GATEWAY替换为提供商网络上的网关IP地址，通常为“.1”IP地址。 -network，指定创建的子网名称 -subnet-range 后边的provider为要创建子网的网络（要跟上面创建网络的名称对应起来） 查看创建的子网 [root@controller ~]# openstack subnet list +--------------------------------------+----------+---------------------------------- | ID | Name | Network | Subnet | +--------------------------------------+----------+---------------------------------- | 639dcbb3-9bdf-4db8-9734-c4556f1e7972 | provider | 891787bb-ce4a-4b41-b222-1493ec30035c | 192.168.92.0/24 | +--------------------------------------+----------+---------------------------------- 以admin用户登录dashboard查看创建的子网 查看网络拓扑图变化： 4.1.3 查看节点网卡变化 OpenStack中创建的实例想要访问外网必须要创建外部网络（即provider network），然后通过虚拟路由器连接外部网络和租户网络，Neutron网桥的方式实现外网的访问，当Neutron创建外部网络并创建子网后会创建一个新的网桥，并且将ens38这块外部网卡加入网桥，执行ifconfig可以看到多了一个brq891787bb-ce的网桥： [root@controller ~]# ifconfig brq891787bb-ce: flags=4163 mtu 1500 inet 192.168.92.70 netmask 255.255.255.0 broadcast 192.168.92.255 inet6 fe80::ad:b4ff:fedb:b57d prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:2d txqueuelen 1000 (Ethernet) RX packets 156 bytes 17533 (17.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 252 bytes 17252 (16.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: flags=4163 mtu 1500 inet 192.168.90.70 netmask 255.255.255.0 broadcast 192.168.90.255 inet6 fe80::ffb5:9b12:f911:89ec prefixlen 64 scopeid 0x20 inet6 fe80::b01a:e132:1923:175 prefixlen 64 scopeid 0x20 inet6 fe80::2801:f5c2:4e5a:d003 prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:19 txqueuelen 1000 (Ethernet) RX packets 21335 bytes 7687186 (7.3 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 24227 bytes 20874223 (19.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163 mtu 1500 inet 192.168.91.70 netmask 255.255.255.0 broadcast 192.168.91.255 inet6 fe80::e8fe:eea6:f4f:2d85 prefixlen 64 scopeid 0x20 inet6 fe80::8af8:8b5c:793f:e719 prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:23 txqueuelen 1000 (Ethernet) RX packets 22 bytes 3098 (3.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 61 bytes 5818 (5.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens38: flags=4163 mtu 1500 inet6 fe80::e64:a89f:4312:ea34 prefixlen 64 scopeid 0x20 inet6 fe80::e8d3:6442:89c0:cd4a prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:2d txqueuelen 1000 (Ethernet) RX packets 2750 bytes 234108 (228.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4445 bytes 4676164 (4.4 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 查看该网桥信息，其中，该网桥的 tapcf05d8bf-49和 tapf7f21425-dd接口分别连接了ens38物理网卡和dhcp节点 [root@controller ~]# brctl show bridge name bridge id STP enabled interfaces brq891787bb-ce 8000.000c29cba52d no ens38 tapcf05d8bf-49 tapf7f21425-dd 4.2 创建租户网络 如果选择联网选项2，则还可以创建通过NAT连接到物理网络基础结构的自助服务（专用）网络。该网络包括一个为实例提供IP地址的DHCP服务器。此网络上的实例可以自动访问外部网络，如Internet。但是，从外部网络（例如Internet）访问此网络上的实例需要浮动IP地址 这个demo或其他非特权用户可以创建这个网络，因为它仅提供与demo项目内实例的连接。 Warning 您必须在自助服务网络之前创建提供商网络。 4.2.1 创建self-service网络 1.在控制节点上，获取凭据demo-openrc： $ . demo-openrc 2.创建网络： [root@controller ~]# openstack network create selfservice1 +---------------------------+--------------------------------------+ | Field | Value | +---------------------------+--------------------------------------+ | admin_state_up | UP | | availability_zone_hints | | | availability_zones | | | created_at | 2018-06-13T06:14:20Z | | description | | | dns_domain | None | | id | 0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 | | ipv4_address_scope | None | | ipv6_address_scope | None | | is_default | False | | is_vlan_transparent | None | | mtu | 1450 | | name | selfservice1 | | port_security_enabled | True | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | provider:network_type | None | | provider:physical_network | None | | provider:segmentation_id | None | | qos_policy_id | None | | revision_number | 2 | | router:external | Internal | | segments | None | | shared | False | | status | ACTIVE | | subnets | | | tags | | | updated_at | 2018-06-13T06:14:20Z | +---------------------------+--------------------------------------+ 非特权用户通常不能为该命令提供额外的参数。该服务使用来自以下文件的信息自动选择参数： # cat /etc/neutron/plugins/ml2/ml2_conf.ini ml2_conf.ini: [ml2] tenant_network_types = vxlan [ml2_type_vxlan] vni_ranges = 1:1000 创建的内部网络类型是由tenant_network_types中指定，为vxlan。该配置能指定内部网络类型，如flat，vlan，gre等。 查看创建的网络： [root@controller ~]# openstack network list +--------------------------------------+-------------+------------------------------- | ID | Name | Subnets | +--------------------------------------+-------------+------------------------------- | 891787bb-ce4a-4b41-b222-1493ec30035c | provider | 639dcbb3-9bdf-4db8-9734-c4556f1e7972 | | a248893f-0267-4aa4-8766-ac87e525a057 | selfservice1 | | +--------------------------------------+-------------+------------------------------- 在dashboard上查看创建的网络： 4.2.2 网络中创建子网 在网络上创建子网： $ openstack subnet create --network selfservice1 \\ --dns-nameserver 114.114.114.114 --gateway 172.16.1.1 \\ --subnet-range 172.16.1.0/24 selfservice1-net1 执行结果： [root@controller ~]# openstack subnet create --network selfservice1 \\ > --dns-nameserver 114.114.114.114 --gateway 172.16.1.1 \\ > --subnet-range 172.16.1.0/24 selfservice1-net1 +-------------------+--------------------------------------+ | Field | Value | +-------------------+--------------------------------------+ | allocation_pools | 172.16.1.2-172.16.1.254 | | cidr | 172.16.1.0/24 | | created_at | 2018-06-13T06:16:13Z | | description | | | dns_nameservers | 114.114.114.114 | | enable_dhcp | True | | gateway_ip | 172.16.1.1 | | host_routes | | | id | e96f6670-3208-40bb-a4f8-21beb37382db | | ip_version | 4 | | ipv6_address_mode | None | | ipv6_ra_mode | None | | name | selfservice1-net1 | | network_id | 0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | revision_number | 0 | | segment_id | None | | service_types | | | subnetpool_id | None | | tags | | | updated_at | 2018-06-13T06:16:13Z | +-------------------+--------------------------------------+ 查看创建的子网： [root@controller ~]# openstack subnet list +--------------------------------------+-------------+------------------------------- | ID | Name | Network | Subnet | +--------------------------------------+-------------+------------------------------- | 639dcbb3-9bdf-4db8-9734-c4556f1e7972 | provider | 891787bb-ce4a-4b41-b222-1493ec30035c | 192.168.92.0/24 | | b378617e-8ba0-439b-95a9-b4d2c5df10aa | selfservice | a248893f-0267-4aa4-8766-ac87e525a057 | 172.16.1.0/24 | +--------------------------------------+-------------+------------------------------- 切换到demo用户登录dashboard查看网络拓扑图： 查看计算节点网卡变化 [root@compute1 ~]# ifconfig brq891787bb-ce: flags=4163 mtu 1500 inet 192.168.91.71 netmask 255.255.255.0 broadcast 192.168.91.255 ether 00:0c:29:c7:ba:a5 txqueuelen 1000 (Ethernet) RX packets 107 bytes 15563 (15.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 130 bytes 17653 (17.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: flags=4163 mtu 1500 inet 192.168.90.71 netmask 255.255.255.0 broadcast 192.168.90.255 inet6 fe80::b01a:e132:1923:175 prefixlen 64 scopeid 0x20 inet6 fe80::2801:f5c2:4e5a:d003 prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:9b txqueuelen 1000 (Ethernet) RX packets 2591 bytes 1036598 (1012.3 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2555 bytes 2019296 (1.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163 mtu 1500 inet6 fe80::8af8:8b5c:793f:e719 prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:a5 txqueuelen 1000 (Ethernet) RX packets 105 bytes 16893 (16.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 165 bytes 21265 (20.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens38: flags=4163 mtu 1500 inet 192.168.92.71 netmask 255.255.255.0 broadcast 192.168.92.255 inet6 fe80::e8d3:6442:89c0:cd4a prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:af txqueuelen 1000 (Ethernet) RX packets 110 bytes 12508 (12.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 173 bytes 12172 (11.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 4.2.3 创建路由器 自助服务网络使用通常执行双向NAT的虚拟路由器连接到提供商网络。每个路由器至少包含一个自助服务网络上的接口和提供商网络上的网关。 提供商网络必须包含router:external选项以使自助服务路由器能够使用它来连接到外部网络，例如互联网。这个admin或其他特权用户必须在网络创建期间包含此选项或稍后添加它。在这种情况下，该 router:external选项--external在创建provider网络时通过使用该参数进行设置。 1.在控制节点上，demo获取凭据以访问仅限用户的CLI命令： $ . demo-openrc 2.创建路由器: [root@controller ~]# openstack router create router +-------------------------+--------------------------------------+ | Field | Value | +-------------------------+--------------------------------------+ | admin_state_up | UP | | availability_zone_hints | | | availability_zones | | | created_at | 2018-06-11T04:58:58Z | | description | | | distributed | False | | external_gateway_info | None | | flavor_id | None | | ha | False | | id | be1a4882-bc3f-43b4-9570-1414e1fae952 | | name | router | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | revision_number | 1 | | routes | | | status | ACTIVE | | tags | | | updated_at | 2018-06-11T04:58:58Z | +-------------------------+--------------------------------------+ 查看创建的路由器： [root@controller ~]# openstack router list +--------------------------------------+--------+--------+-------+-------------+----- | ID | Name | Status | State | Distributed | HA | Project | +--------------------------------------+--------+--------+-------+-------------+----- | be1a4882-bc3f-43b4-9570-1414e1fae952 | router | ACTIVE | UP | False | False | f3f0c1a2a9f74aa6ac030671f4c7ec33 | +--------------------------------------+--------+--------+-------+-------------+----- 登录dashboard查看创建的路由器: 4.2.4 租户网络添加到路由器 将自助服务网络子网添加为路由器上的接口： [root@controller ~]# neutron router-interface-add router selfservice neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. Added interface d6ef6924-a4a2-4746-9bf7-9c7c1b13f32c to router router. 4.2.5 路由器连接到外部网络 在路由器上的提供商网络上设置网关： [root@controller ~]# neutron router-gateway-set router provider neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. Set gateway for router router 切换demo用户登录dashboard查看网络拓扑图变化： 4.2.6 验证操作 我们建议您在继续之前验证操作并解决所有问题。 以下步骤使用网络和子网创建示例中的IP地址范围。 1.在控制器节点上，输入管理员凭据以访问仅限管理员的CLI命令： $ . admin-openrc 2.列出网络名称空间。你应该看到一个qrouter命名空间和两个 qdhcp命名空间。 [root@controller ~]# ip netns qrouter-be1a4882-bc3f-43b4-9570-1414e1fae952 (id: 2) qdhcp-a248893f-0267-4aa4-8766-ac87e525a057 (id: 1) qdhcp-891787bb-ce4a-4b41-b222-1493ec30035c (id: 0) List ports on the router to determine the gateway IP address on the provider network: 3.列出路由器上的端口以确定提供商网络上的网关IP地址： [root@controller ~]# neutron router-port-list router neutron CLI is deprecated and will be removed in the future. Use openstack CLI instead. +--------------------------------------+------+----------------------------------+--- | id | name | tenant_id | mac_address | fixed_ips | +--------------------------------------+------+----------------------------------+--- | d6ef6924-a4a2-4746-9bf7-9c7c1b13f32c | | f3f0c1a2a9f74aa6ac030671f4c7ec33 | fa:16:3e:c1:7a:17 | {\"subnet_id\": \"b378617e-8ba0-439b-95a9-b4d2c5df10aa\", \"ip_address\": \"172.16.1.1\"} | | f7f21425-dd38-435c-85a7-4842106e1d7a | | | fa:16:3e:d5:3e:63 | {\"subnet_id\": \"639dcbb3-9bdf-4db8-9734-c4556f1e7972\", \"ip_address\": \"192.168.92.90\"} | +--------------------------------------+------+----------------------------------+--- 4.从控制节点或物理提供商网络上的任何主机ping此IP地址： [root@controller ~]# ping -c 4 192.168.92.90 PING 192.168.92.90 (192.168.92.90) 56(84) bytes of data. 64 bytes from 192.168.92.90: icmp_seq=1 ttl=64 time=0.136 ms 64 bytes from 192.168.92.90: icmp_seq=2 ttl=64 time=0.052 ms 64 bytes from 192.168.92.90: icmp_seq=3 ttl=64 time=0.062 ms 64 bytes from 192.168.92.90: icmp_seq=4 ttl=64 time=0.053 ms --- 192.168.92.90 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 3108ms rtt min/avg/max/mdev = 0.052/0.075/0.136/0.036 ms 4.3 创建实例类型 最小的默认flavor消耗每个实例512 MB的内存。 对于包含少于4 GB内存的计算节点的环境，我们建议创建每个实例仅需要64 MB的m1.nano特征。 为了测试目的，请仅将CirrOS图像用于此flavor。 [root@controller ~]# openstack flavor create --id 0 --vcpus 1 --ram 64 --disk 1 m1.nano +----------------------------+---------+ | Field | Value | +----------------------------+---------+ | OS-FLV-DISABLED:disabled | False | | OS-FLV-EXT-DATA:ephemeral | 0 | | disk | 1 | | id | 0 | | name | m1.nano | | os-flavor-access:is_public | True | | properties | | | ram | 64 | | rxtx_factor | 1.0 | | swap | | | vcpus | 1 | +----------------------------+---------+ 这里创建两种规格的实例类型： [root@controller ~]# openstack flavor create --id 1 --vcpus 1 --ram 1024 --disk 10 m2.nano +----------------------------+---------+ | Field | Value | +----------------------------+---------+ | OS-FLV-DISABLED:disabled | False | | OS-FLV-EXT-DATA:ephemeral | 0 | | disk | 10 | | id | 1 | | name | m2.nano | | os-flavor-access:is_public | True | | properties | | | ram | 1024 | | rxtx_factor | 1.0 | | swap | | | vcpus | 1 | +----------------------------+---------+ 参数说明： openstack flavor create 创建主机 -id 主机ID -vcpus cpu数量 -ram 64（默认是MB，可以写成G） -disk 磁盘（默认单位是G） 查看创建的实例类型： [root@controller ~]# openstack flavor list +----+---------+------+------+-----------+-------+-----------+ | ID | Name | RAM | Disk | Ephemeral | VCPUs | Is Public | +----+---------+------+------+-----------+-------+-----------+ | 0 | m1.nano | 64 | 1 | 0 | 1 | True | | 1 | m2.nano | 1024 | 10 | 0 | 1 | True | +----+---------+------+------+-----------+-------+-----------+ 切换到admin用户查看创建的实例类型： 4.4 生成秘钥对 大多数云镜像支持公钥认证，而不是传统的密码认证。 在启动实例之前，您必须将公钥添加到Compute服务。 1.加载demo项目凭证： $ . demo-openrc 2.生成密钥对并添加公钥： 生成密钥文件（一个公钥文件和一个私钥文件），保存在/root/.ssh/id [root@controller ~]# ssh-keygen -q -N \"\" Enter file in which to save the key (/root/.ssh/id_rsa): [root@controller ~]# ll /root/.ssh/ total 12 -rw------- 1 root root 1675 Jun 11 13:26 id_rsa #生成的私钥文件 -rw-r--r-- 1 root root 397 Jun 11 13:26 id_rsa.pub #生成的公钥文件 创建秘钥对，并将生成的公钥文件添加到秘钥对： [root@controller ~]# openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey +-------------+-------------------------------------------------+ | Field | Value | +-------------+-------------------------------------------------+ | fingerprint | 6a:2a:05:f3:a8:98:c8:23:65:00:92:6d:24:ee:60:f4 | | name | mykey | | user_id | a331e97f2ac6444484371a70e1299636 | +-------------+-------------------------------------------------+ 3.验证密钥对是否添加成功： [root@controller ~]# openstack keypair list +-------+-------------------------------------------------+ | Name | Fingerprint | +-------+-------------------------------------------------+ | mykey | 6a:2a:05:f3:a8:98:c8:23:65:00:92:6d:24:ee:60:f4 | +-------+-------------------------------------------------+ 登录dashboard查看创建的秘钥对： 4.5 添加安全组规则 默认情况下，默认安全组适用于所有实例，并包含拒绝对实例进行远程访问的防火墙规则。 对于像CirrOS这样的Linux映像，我们建议至少允许ICMP（ping）和安全shell（SSH）。 向default安全组添加规则： 1.允许ICMP（ping）： [root@controller ~]# openstack security group rule create --proto icmp default +-------------------+--------------------------------------+ | Field | Value | +-------------------+--------------------------------------+ | created_at | 2018-06-11T05:32:26Z | | description | | | direction | ingress | | ether_type | IPv4 | | id | 30510627-2cfc-4028-9e38-a99a2a581f16 | | name | None | | port_range_max | None | | port_range_min | None | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | protocol | icmp | | remote_group_id | None | | remote_ip_prefix | 0.0.0.0/0 | | revision_number | 0 | | security_group_id | f2a06fdc-0799-4289-b758-eeec43c16a55 | | updated_at | 2018-06-11T05:32:26Z | +-------------------+--------------------------------------+ 2.允许安全shell（SSH）访问： [root@controller ~]# openstack security group rule create --proto tcp --dst-port 22 default +-------------------+--------------------------------------+ | Field | Value | +-------------------+--------------------------------------+ | created_at | 2018-06-11T05:33:30Z | | description | | | direction | ingress | | ether_type | IPv4 | | id | 0f19058a-0bfd-424e-bedd-6249e00d7043 | | name | None | | port_range_max | 22 | | port_range_min | 22 | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | protocol | tcp | | remote_group_id | None | | remote_ip_prefix | 0.0.0.0/0 | | revision_number | 0 | | security_group_id | f2a06fdc-0799-4289-b758-eeec43c16a55 | | updated_at | 2018-06-11T05:33:30Z | +-------------------+--------------------------------------+ 查看安全组及创建的安全组规则： [root@controller ~]# openstack security group list +--------------------------------------+---------+------------------------+---------- | ID | Name | Description | Project | +--------------------------------------+---------+------------------------+---------- | f2a06fdc-0799-4289-b758-eeec43c16a55 | default | Default security group | f3f0c1a2a9f74aa6ac030671f4c7ec33 | +--------------------------------------+---------+------------------------+---------- [root@controller ~]# openstack security group rule list +--------------------------------------+-------------+-----------+------------+------ | ID | IP Protocol | IP Range | Port Range | Remote Security Group | Security Group | +--------------------------------------+-------------+-----------+------------+------ | 0f19058a-0bfd-424e-bedd-6249e00d7043 | tcp | 0.0.0.0/0 | 22:22 | None | f2a06fdc-0799-4289-b758-eeec43c16a55 | | 20b109d3-bdf1-419e-87d7-1836313b208b | None | None | | f2a06fdc-0799-4289-b758-eeec43c16a55 | f2a06fdc-0799-4289-b758-eeec43c16a55 | | 30510627-2cfc-4028-9e38-a99a2a581f16 | icmp | 0.0.0.0/0 | | None | f2a06fdc-0799-4289-b758-eeec43c16a55 | | 6772b2c2-c5fc-4eea-bfe3-b9f2a8dad0cb | None | None | | None | f2a06fdc-0799-4289-b758-eeec43c16a55 | | 97e3620d-6f2a-459a-b712-257fa6e31f9d | None | None | | f2a06fdc-0799-4289-b758-eeec43c16a55 | f2a06fdc-0799-4289-b758-eeec43c16a55 | | e7dcfc28-924f-455b-b8dd-cfe3e1325c9f | None | None | | None | f2a06fdc-0799-4289-b758-eeec43c16a55 | +--------------------------------------+-------------+-----------+------------+------ 切换到demo用户登录dashboard查看创建的安全组规则： 4.6 确认实例选项 要启动实例，必须至少指定flavor、镜像名称、网络、安全组、密钥和实例名称。 1.在控制器节点上，获取演示凭据以访问仅限用户的CLI命令： $ . demo-openrc 2.flavor指定了包括处理器，内存和存储的虚拟资源分配概要文件。 列出可用的flavor： [root@controller ~]# openstack flavor list +----+---------+------+------+-----------+-------+-----------+ | ID | Name | RAM | Disk | Ephemeral | VCPUs | Is Public | +----+---------+------+------+-----------+-------+-----------+ | 0 | m1.nano | 64 | 1 | 0 | 1 | True | | 1 | m2.nano | 1024 | 10 | 0 | 1 | True | +----+---------+------+------+-----------+-------+-----------+ 3.列出镜像 [root@controller ~]# openstack image list +--------------------------------------+--------+--------+ | ID | Name | Status | +--------------------------------------+--------+--------+ | de140769-4ce3-4a1b-9651-07a915b21caa | cirros | active | +--------------------------------------+--------+--------+ 本实例使用cirros镜像 4.列出可用的网络 [root@controller ~]# openstack network list +--------------------------------------+--------------+------------------------------ | ID | Name | Subnets | +--------------------------------------+--------------+------------------------------ | 0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 | selfservice1 | e96f6670-3208-40bb-a4f8-21beb37382db | | 891787bb-ce4a-4b41-b222-1493ec30035c | provider | 639dcbb3-9bdf-4db8-9734-c4556f1e7972 | | ded70080-a8d2-41fc-8351-2cf2eb45c308 | selfservice2 | 5137d1b5-f697-4e9a-b0ea-8981e1f1dd3d | +--------------------------------------+--------------+------------------------------ 这个实例使用provider提供者网络。但是，您必须使用ID而不是名称来引用此网络。 如果您选择了选项2，则输出还应包含 selfservice自助服务网络。 5.列出可用的安全组： [root@controller ~]# openstack security group list +--------------------------------------+---------+------------------------+---------- | ID | Name | Description | Project | +--------------------------------------+---------+------------------------+---------- | 0b8e6943-af2e-4b16-9f06-da3ceb17e105 | default | Default security group | 07f75876b05945e0816b6e219ee6c9f7 | +--------------------------------------+---------+------------------------+---------- 此实例使用default安全组。 6.列出可用的秘钥对： [root@controller ~]# openstack keypair list +-------+-------------------------------------------------+ | Name | Fingerprint | +-------+-------------------------------------------------+ | mykey | 6a:2a:05:f3:a8:98:c8:23:65:00:92:6d:24:ee:60:f4 | +-------+-------------------------------------------------+ 4.7 创建实例 租户网络selfservice1上创建实例： $ openstack server create --flavor m1.nano --image cirros \\ --nic net-id=0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 --security-group default \\ --key-name mykey selfservice1-cirros1 执行结果： [root@controller ~]# openstack server create --flavor m1.nano --image cirros \\ > --nic net-id=0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 --security-group default \\ > --key-name mykey selfservice1-cirros1 +-----------------------------+-----------------------------------------------+ | Field | Value | +-----------------------------+-----------------------------------------------+ | OS-DCF:diskConfig | MANUAL | | OS-EXT-AZ:availability_zone | | | OS-EXT-STS:power_state | NOSTATE | | OS-EXT-STS:task_state | scheduling | | OS-EXT-STS:vm_state | building | | OS-SRV-USG:launched_at | None | | OS-SRV-USG:terminated_at | None | | accessIPv4 | | | accessIPv6 | | | addresses | | | adminPass | tBi28a8xEiQ9 | | config_drive | | | created | 2018-06-14T06:59:03Z | | flavor | m1.nano (0) | | hostId | | | id | 497b11d9-711d-467d-a1d0-acbebee22f6b | | image | cirros (de140769-4ce3-4a1b-9651-07a915b21caa) | | key_name | mykey | | name | selfservice1-cirros1 | | progress | 0 | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | properties | | | security_groups | name='f2a06fdc-0799-4289-b758-eeec43c16a55' | | status | BUILD | | updated | 2018-06-14T06:59:05Z | | user_id | a331e97f2ac6444484371a70e1299636 | | volumes_attached | | +-----------------------------+-----------------------------------------------+ 参数说明： openstack server create 创建实例 --flavor 主机类型名称 --image 镜像名称 --nic net-id=网络ID --security-group 安全组名称 --key-name key名称 最后一个是自定义实例名称 检查实例状态： [root@controller ~]# openstack server list +--------------------------------------+----------------------+--------+------------- | ID | Name | Status | Networks | Image | Flavor | +--------------------------------------+----------------------+--------+------------- | 23f3ac0c-4e6f-46be-8a3d-9e291343b441 | selfservice2-cirros2 | ACTIVE | selfservice2=172.16.2.6 | cirros | m1.nano | | 31f2e6ac-3743-43f6-b6b2-49e22d63373b | selfservice2-cirros1 | ACTIVE | selfservice2=172.16.2.9 | cirros | m1.nano | | 025d22b8-fd71-4eae-912e-6f54ee4e956f | selfservice1-cirros2 | ACTIVE | selfservice1=172.16.1.5 | cirros | m1.nano | | 497b11d9-711d-467d-a1d0-acbebee22f6b | selfservice1-cirros1 | ACTIVE | selfservice1=172.16.1.8 | cirros | m1.nano | +--------------------------------------+----------------------+--------+------------- 目前实例地址无法ping通 4.8 虚拟控制台访问实例 加载demo-openrc环境 $ . demo-openrc 为您的实例获取虚拟网络计算（VNC）会话URL并从Web浏览器访问它： [root@controller ~]# openstack console url show selfservice1-cirros1 +-------+---------------------------------------------------------------------------- | Field | Value | +-------+---------------------------------------------------------------------------- | type | novnc | | url | http://controller:6080/vnc_auto.html?token=5dcf9b77-297c-4d6d-9445-f6ba77cb8a18 | +-------+---------------------------------------------------------------------------- 如果您的Web浏览器在无法解析控制器主机名的主机上运行，则可以使用控制节点上的管理接口的IP地址替换控制器。 测试实例对外网的访问：  ping 172.16.1.1 租户网络网关  ping 192.168.92.2 本地外部网络网关  ping www.baidu.com 外部互联网 测试全部能够正常ping通 CirrOS映像包含传统的用户名/密码认证，并在登录提示符处提供这些凭据。 登录到CirrOS后，我们建议您使用ping验证网络连接。默认用户名cirros，默认密码gocubsgo 4.9 为实例分配浮动IP地址 如果想通过外网远程连接到实例，需要在外部网络上创建浮动IP地址，并将浮动ip地址关联到实例上，然后通过访问外部的浮动ip地址来访问实例： 1.在外部网络上生成浮动ip地址： [root@controller ~]# openstack floating ip create provider +---------------------+--------------------------------------+ | Field | Value | +---------------------+--------------------------------------+ | created_at | 2018-06-14T07:27:59Z | | description | | | fixed_ip_address | None | | floating_ip_address | 192.168.92.86 | | floating_network_id | 891787bb-ce4a-4b41-b222-1493ec30035c | | id | 0aa48060-ed79-4f60-baa7-0cba7be74ac2 | | name | 192.168.92.86 | | port_id | None | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | qos_policy_id | None | | revision_number | 0 | | router_id | None | | status | DOWN | | subnet_id | None | | updated_at | 2018-06-14T07:27:59Z | +---------------------+--------------------------------------+ 2.将浮动IP地址与实例关联 $ openstack server add floating ip selfservice1-cirros1 192.168.92.86 3.检查浮动IP地址的关联状态 [root@controller ~]# openstack server list +--------------------------------------+----------------------+--------+------------- | ID | Name | Status | Networks | Image | Flavor | +--------------------------------------+----------------------+--------+------------- | 23f3ac0c-4e6f-46be-8a3d-9e291343b441 | selfservice2-cirros2 | ACTIVE | selfservice2=172.16.2.6 | cirros | m1.nano | | 31f2e6ac-3743-43f6-b6b2-49e22d63373b | selfservice2-cirros1 | ACTIVE | selfservice2=172.16.2.9 | cirros | m1.nano | | 025d22b8-fd71-4eae-912e-6f54ee4e956f | selfservice1-cirros2 | ACTIVE | selfservice1=172.16.1.5 | cirros | m1.nano | | 497b11d9-711d-467d-a1d0-acbebee22f6b | selfservice1-cirros1 | ACTIVE | selfservice1=172.16.1.8, 192.168.92.86 | cirros | m1.nano | +--------------------------------------+----------------------+--------+------------- 依次生成多个浮动ip对其他实例进行相同操作 3.在控制节点或者外部网络上通过floating IP验证对实例的访问是否正常： 通过来自控制器节点或供应商物理网络上的任何主机的浮动IP地址验证与实例的连接性： 控制节点测试： [root@controller ~]# ping 192.168.92.86 PING 192.168.92.86 (192.168.92.86) 56(84) bytes of data. 64 bytes from 192.168.92.86: icmp_seq=1 ttl=63 time=1.59 ms 64 bytes from 192.168.92.86: icmp_seq=2 ttl=63 time=0.856 ms 本地主机测试： C:\\Users\\zwpos>ping 192.168.92.86 正在 Ping 192.168.92.86 具有 32 字节的数据:bash 来自 192.168.92.86 的回复: 字节=32 时间=1ms TTL=63 来自 192.168.92.86 的回复: 字节=32 时间=1ms TTL=63 4.10 远程SSH访问实例 通过控制节点或者远程主机登录实例： [root@controller ~]# ssh cirros@192.168.92.86 The authenticity of host '192.168.92.86 (192.168.92.86)' can't be established. ECDSA key fingerprint is SHA256:GiuwydTpzXUrQ0K7DYTv7+sJXA5afNJpCnU+t/xsgvE. ECDSA key fingerprint is MD5:20:a9:81:33:16:0b:34:8e:2f:b6:42:8f:d2:3b:72:7c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.92.86' (ECDSA) to the list of known hosts. $ $ $ ifconfig eth0 Link encap:Ethernet HWaddr FA:16:3E:DF:35:7D inet addr:172.16.1.8 Bcast:172.16.1.255 Mask:255.255.255.0 inet6 addr: fe80::f816:3eff:fedf:357d/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:216 errors:0 dropped:0 overruns:0 frame:0 TX packets:219 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:27246 (26.6 KiB) TX bytes:23095 (22.5 KiB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) $ exit Connection to 192.168.92.86 closed [root@controller ~]# 4.11 网卡变化 创建好内部网络和实例之后，vxlan隧道就建立起来。系统会在控制节点创建一个vxlan 的VTEP，在计算节点创建一个vxlan的VTEP。 如下图，第一张为控制节点，创建vxlan21；第二张为计算节点创建也为vxlan21。这两个VTEP设备组成了vxlan隧道的两个端点。 [root@controller ~]# brctl show bridge name bridge id STP enabled interfaces brqa248893f-02 8000.02516746fd7d no tapcae7f217-1e vxlan-21 [root@compute1 ~]# brctl show bridge name bridge id STP enabled interfaces brqa248893f-02 8000.a6aaa0e77f45 no tap8cb57c9e-a7 vxlan-21 通过查看计算节点上vxlan21的详细信息可以看到其连接ens37网卡。 [root@compute1 ~]# ip -d link show dev vxlan-21 10: vxlan-21: mtu 1450 qdisc noqueue master brqa248893f-02 state UNKNOWN mode DEFAULT group default qlen 1000 link/ether a6:aa:a0:e7:7f:45 brd ff:ff:ff:ff:ff:ff promiscuity 1 vxlan id 21 dev ens37 srcport 0 0 dstport 8472 ageing 300 udpcsum noudp6zerocsumtx noudp6zerocsumrx 4.12 块存储 4.12.1 创建一个卷 $ . demo-openrc 创建1GB大小的卷： [root@controller ~]# openstack volume create --size 1 volume1 +---------------------+--------------------------------------+ | Field | Value | +---------------------+--------------------------------------+ | attachments | [] | | availability_zone | nova | | bootable | false | | consistencygroup_id | None | | created_at | 2018-05-15T01:53:57.000000 | | description | None | | encrypted | False | | id | e3d30f58-6c0a-4f13-8433-c274e014fc3f | | multiattach | False | | name | volume1 | | properties | | | replication_status | None | | size | 1 | | snapshot_id | None | | source_volid | None | | status | creating | | type | None | | updated_at | None | | user_id | 19ba7d00b87c4132b4fc0c6ee8555fef | +---------------------+--------------------------------------+ 在短时间内，卷状态应该从创建变为可用： $ openstack volume list [root@controller ~]# openstack volume list +--------------------------------------+---------+-----------+------+-------------+ | ID | Name | Status | Size | Attached to | +--------------------------------------+---------+-----------+------+-------------+ | e3d30f58-6c0a-4f13-8433-c274e014fc3f | volume1 | available | 1 | | +--------------------------------------+---------+-----------+------+-------------+ 4.12.2 将卷添加到实例 $ openstack server add volume INSTANCE_NAME VOLUME_NAME Replace INSTANCE_NAME with the name of the instance and VOLUME_NAME with the name of the volume you want to attach to it. Example Attach the volume1 volume to the provider-instance instance: $ openstack server add volume provider-instance volume1 Note This command provides no output. List volumes: $ openstack volume list [root@controller ~]# openstack server add volume provider-vm3 volume1 [root@controller ~]# openstack volume list +--------------------------------------+------+-----------+------+---------------------------------------------------------------+ | ID | Name | Status | Size | Attached to | +--------------------------------------+------+-----------+------+---------------------------------------------------------------+ | 5e3c9ff9-dd13-402e-9377-065df66c3960 | | in-use | 10 | Attached to cde97911-dc1c-4265-8f14-2bc20ae77973 on /dev/vda | | b59a916f-7663-4bee-825f-1c6c240ac49b | | available | 10 | | +--------------------------------------+------+-----------+------+---------------------------------------------------------------+ Access your instance using SSH and use the fdisk command to verify presence of the volume as the /dev/vdb block storage device: $ sudo fdisk -l [root@provider-vm3 ~]# fdisk -l Disk /dev/vda: 10.7 GB, 10737418240 bytes, 20971520 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000b2f10 Device Boot Start End Blocks Id System /dev/vda1 * 2048 20971486 10484719+ 83 Linux Disk /dev/vdb: 1073 MB, 1073741824 bytes, 2097152 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes [root@provider-vm3 ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 10G 1.1G 9.0G 11% / devtmpfs 476M 0 476M 0% /dev tmpfs 497M 0 497M 0% /dev/shm tmpfs 497M 13M 484M 3% /run tmpfs 497M 0 497M 0% /sys/fs/cgroup tmpfs 100M 0 100M 0% /run/user/0 [root@provider-vm3 ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 10G 0 disk └─vda1 253:1 0 10G 0 part / vdb 253:16 0 1G 0 disk You must create a file system on the device and mount it to use the volume. [root@provider-vm3 ~]# parted /dev/vdb (parted) mkpart primary 0 -1 (parted) toggle 1 lvm [root@provider-vm3 ~]# mkfs.xfs /dev/vdb1 meta-data=/dev/vdb1 isize=512 agcount=4, agsize=65474 blks = sectsz=512 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0 data = bsize=4096 blocks=261895, imaxpct=25 = sunit=0 swidth=0 blks naming =version 2 bsize=4096 ascii-ci=0 ftype=1 log =internal log bsize=4096 blocks=855, version=2 = sectsz=512 sunit=0 blks, lazy-count=1 realtime =none extsz=4096 blocks=0, rtextents=0 [root@provider-vm3 ~]# fdisk -l Disk /dev/vda: 10.7 GB, 10737418240 bytes, 20971520 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: dos Disk identifier: 0x000b2f10 Device Boot Start End Blocks Id System /dev/vda1 * 2048 20971486 10484719+ 83 Linux WARNING: fdisk GPT support is currently new, and therefore in an experimental phase. Use at your own discretion. Disk /dev/vdb: 1073 MB, 1073741824 bytes, 2097152 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk label type: gpt Disk identifier: 8D328EE8-2A24-4F42-954A-3B817470C5AC # Start End Size Type Name 1 34 2095199 1023M Linux LVM primary [root@provider-vm3 ~]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT vda 253:0 0 10G 0 disk └─vda1 253:1 0 10G 0 part / vdb 253:16 0 1G 0 disk └─vdb1 253:17 0 1023M 0 part [root@provider-vm3 ~]# mount /dev/vdb1 /data/ [root@provider-vm3 ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/vda1 10G 1.1G 9.0G 11% / devtmpfs 476M 0 476M 0% /dev tmpfs 497M 0 497M 0% /dev/shm tmpfs 497M 13M 484M 3% /run tmpfs 497M 0 497M 0% /sys/fs/cgroup tmpfs 100M 0 100M 0% /run/user/0 /dev/vdb1 1020M 33M 988M 4% /data For more information about how to manage volumes, see the python-openstackclient documentation for Pike or the python-openstackclient documentation for Queens. Return to Launch an instance. 5 使用官方云镜像创建实例 在openstack中，glance负责image，即镜像相关的服务，镜像是一个已经打包好的文件，内置有操作系统和预先部署好的软件。基于image创建虚拟机，在openstack中是以backing file的形式创建的，即新建的虚拟机和镜像文件之间建立一个连接。 OpenStack 的 instance(实例，就是虚拟机/云主机) 是通过 Glance 镜像部署的，下载clould 镜像使用标准镜像。主流的Linux发行版都提供可以在 OpenStack 中直接使用的cloud镜像。 5.1 下载官方通用云镜像 1、执行环境变量 [root@controller ~]# . admin-openrc 2、centos官网下载qcow2格式的openstack镜像： wget http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud-1802.qcow2c 官方链接：http://cloud.centos.org/centos/7/images 5.2 上传镜像到Glance openstack image create \"CentOS7-image\" \\ --file CentOS-7-x86_64-GenericCloud-1802.qcow2c \\ --disk-format qcow2 --container-format bare \\ --public [root@controller ~]# openstack image create \"CentOS7-image\" \\ > --file CentOS-7-x86_64-GenericCloud-1802.qcow2c \\ > --disk-format qcow2 --container-format bare \\ > --public +------------------+------------------------------------------------------+ | Field | Value | +------------------+------------------------------------------------------+ | checksum | c5e362d0fb6e367ab16a5fbbed2ec1ce | | container_format | bare | | created_at | 2018-06-11T08:40:16Z | | disk_format | qcow2 | | file | /v2/images/5a07a066-31f6-4096-a89c-51e66848523c/file | | id | 5a07a066-31f6-4096-a89c-51e66848523c | | min_disk | 0 | | min_ram | 0 | | name | CentOS7-image | | owner | 9a8169bc534e4705816e97bff4d2866b | | protected | False | | schema | /v2/schemas/image | | size | 394918400 | | status | active | | tags | | | updated_at | 2018-06-11T08:40:20Z | | virtual_size | None | | visibility | public | +------------------+------------------------------------------------------+ 查看上传的镜像 [root@controller ~]# openstack image list +--------------------------------------+---------------+--------+ | ID | Name | Status | +--------------------------------------+---------------+--------+ | 5a07a066-31f6-4096-a89c-51e66848523c | CentOS7-image | active | | de140769-4ce3-4a1b-9651-07a915b21caa | cirros | active | +--------------------------------------+---------------+--------+ 5.3 创建实例 # openstack server create --flavor m2.nano --image CentOS7-image \\ --nic net-id=ded70080-a8d2-41fc-8351-2cf2eb45c308 --security-group default \\ --key-name mykey centos7-cloudvm1 执行结果： [root@controller ~]# openstack server create --flavor m2.nano --image CentOS7-image \\ > --nic net-id=0e728aa4-d9bd-456b-ba0b-dd7df5e15c96 --security-group default \\ > --key-name mykey centos7-cloudvm1 +-----------------------------+------------------------------------------------------+ | Field | Value | +-----------------------------+------------------------------------------------------+ | OS-DCF:diskConfig | MANUAL | | OS-EXT-AZ:availability_zone | | | OS-EXT-STS:power_state | NOSTATE | | OS-EXT-STS:task_state | scheduling | | OS-EXT-STS:vm_state | building | | OS-SRV-USG:launched_at | None | | OS-SRV-USG:terminated_at | None | | accessIPv4 | | | accessIPv6 | | | addresses | | | adminPass | 9AQfV3mbTdT3 | | config_drive | | | created | 2018-06-14T07:40:31Z | | flavor | m2.nano (1) | | hostId | | | id | d1cf9463-13a2-4066-9d9a-9198b94657d3 | | image | CentOS7-image (5a07a066-31f6-4096-a89c-51e66848523c) | | key_name | mykey | | name | centos7-cloudvm1 | | progress | 0 | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | properties | | | security_groups | name='f2a06fdc-0799-4289-b758-eeec43c16a55' | | status | BUILD | | updated | 2018-06-14T07:40:31Z | | user_id | a331e97f2ac6444484371a70e1299636 | | volumes_attached | | +-----------------------------+------------------------------------------------------ 5.4 为实例分配浮动IP地址 1.在外部网络上生成浮动ip地址： [root@controller ~]# openstack floating ip create provider +---------------------+--------------------------------------+ | Field | Value | +---------------------+--------------------------------------+ | created_at | 2018-06-14T07:49:42Z | | description | | | fixed_ip_address | None | | floating_ip_address | 192.168.92.88 | | floating_network_id | 891787bb-ce4a-4b41-b222-1493ec30035c | | id | bd9d50fe-12ae-47bd-b79e-a92b8d6fe742 | | name | 192.168.92.88 | | port_id | None | | project_id | f3f0c1a2a9f74aa6ac030671f4c7ec33 | | qos_policy_id | None | | revision_number | 0 | | router_id | None | | status | DOWN | | subnet_id | None | | updated_at | 2018-06-14T07:49:42Z | +---------------------+--------------------------------------+ 2.将浮动IP地址与实例关联 $ openstack server add floating ip centos7-cloudvm1 192.168.92.88 3.检查浮动IP地址的关联状态 [root@controller ~]# openstack server list +--------------------------------------+----------------------+--------+-----------------------------------------+---------------+---------+ | ID | Name | Status | Networks | Image | Flavor | +--------------------------------------+----------------------+--------+-----------------------------------------+---------------+---------+ | 80fbaee9-e43f-48a0-bbda-c397b0baa9f9 | centos7-cloudvm2 | ACTIVE | selfservice2=172.16.2.5, 192.168.92.87 | CentOS7-image | m2.nano | | d1cf9463-13a2-4066-9d9a-9198b94657d3 | centos7-cloudvm1 | ACTIVE | selfservice1=172.16.1.13, 192.168.92.88 | CentOS7-image | m2.nano | | 23f3ac0c-4e6f-46be-8a3d-9e291343b441 | selfservice2-cirros2 | ACTIVE | selfservice2=172.16.2.6, 192.168.92.83 | cirros | m1.nano | | 31f2e6ac-3743-43f6-b6b2-49e22d63373b | selfservice2-cirros1 | ACTIVE | selfservice2=172.16.2.9, 192.168.92.89 | cirros | m1.nano | | 025d22b8-fd71-4eae-912e-6f54ee4e956f | selfservice1-cirros2 | ACTIVE | selfservice1=172.16.1.5, 192.168.92.85 | cirros | m1.nano | | 497b11d9-711d-467d-a1d0-acbebee22f6b | selfservice1-cirros1 | ACTIVE | selfservice1=172.16.1.8, 192.168.92.86 | cirros | m1.nano | +--------------------------------------+----------------------+--------+-----------------------------------------+---------------+---------+ 3.在控制节点或者外部网络上通过floating IP验证对实例的访问是否正常： 通过来自控制器节点或供应商物理网络上的任何主机的浮动IP地址验证与实例的连接性： 控制节点测试： [root@controller ~]# ping 192.168.92.88 PING 192.168.92.88 (192.168.92.88) 56(84) bytes of data. 64 bytes from 192.168.92.88: icmp_seq=1 ttl=63 time=1.10 ms 64 bytes from 192.168.92.88: icmp_seq=2 ttl=63 time=1.70 ms 本地主机测试： C:\\Users\\zwpos>ping 192.168.92.88 正在 Ping 192.168.92.88 具有 32 字节的数据: 来自 192.168.92.88 的回复: 字节=32 时间=1ms TTL=63 来自 192.168.92.88 的回复: 字节=32 时间=1ms TTL=63 5.5 远程SSH访问实例 通过控制节点登录实例： [root@controller ~]# ssh centos@192.168.92.88 The authenticity of host '192.168.92.88 (192.168.92.88)' can't be established. ECDSA key fingerprint is SHA256:f/E3cmKXJ8b5uq6rdG7uuaYrAIbN3fh5JOiE14DBM1s. ECDSA key fingerprint is MD5:b9:15:3a:e0:a3:fc:02:e3:a5:72:96:db:19:62:d4:5d. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.92.88' (ECDSA) to the list of known hosts. [centos@centos7-cloudvm1 ~]$ [centos@centos7-cloudvm1 ~]$ ifconfig eth0: flags=4163 mtu 1450 inet 172.16.1.13 netmask 255.255.255.0 broadcast 172.16.1.255 inet6 fe80::f816:3eff:feb1:57c7 prefixlen 64 scopeid 0x20 ether fa:16:3e:b1:57:c7 txqueuelen 1000 (Ethernet) RX packets 312 bytes 34866 (34.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 399 bytes 38141 (37.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1 (Local Loopback) RX packets 6 bytes 416 (416.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 6 bytes 416 (416.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [centos@centos7-cloudvm1 ~]$ [centos@centos7-cloudvm1 ~]$ ping www.baidu.com PING www.a.shifen.com (111.13.100.91) 56(84) bytes of data. 64 bytes from 111.13.100.91 (111.13.100.91): icmp_seq=1 ttl=127 time=79.8 ms 64 bytes from 111.13.100.91 (111.13.100.91): icmp_seq=2 ttl=127 time=86.8 ms [centos@centos7-cloudvm1 ~]$ exit logout Connection to 192.168.92.88 closed. [root@controller ~]# 修改实例root密码并开启SSH远程密码登录： [root@controller ~]# ssh centos@192.168.92.88 Last login: Thu Jun 14 08:05:06 2018 from 192.168.92.70 [centos@centos7-cloudvm1 ~]$ [centos@centos7-cloudvm1 ~]$ [centos@centos7-cloudvm1 ~]$ sudo su root [root@centos7-cloudvm1 centos]# passwd root Changing password for user root. New password: BAD PASSWORD: The password is shorter than 8 characters Retype new password: passwd: all authentication tokens updated successfully. [root@centos7-cloudvm1 centos]# vi /etc/ssh/sshd_config 63 PasswordAuthentication yes 64 #PermitEmptyPasswords no 65 #PasswordAuthentication no [root@centos7-cloudvm1 centos]# systemctl restart sshd [root@centos7-cloudvm1 centos]# exit exit [centos@centos7-cloudvm1 ~]$ exit logout Connection to 192.168.92.88 closed. [root@controller ~]# 使用root账号及设置的密码访问实例： 6 查看当前网卡状态 6.1 控制节点 [root@controller ~]# nmcli connection show NAME UUID TYPE DEVICE brq0e728aa4-d9 b29ab3b7-6eb6-40f4-8360-6fea6620ccef bridge brq0e728aa4-d9 brq891787bb-ce 600d2b50-9521-4e6f-a50f-3bf9b3db00bf bridge brq891787bb-ce brqded70080-a8 65dccec5-374e-4a5d-a03f-b2d5b665f089 bridge brqded70080-a8 ens33 c96bc909-188e-ec64-3a96-6a90982b08ad ethernet ens33 ens37 4a5516a4-dfa4-24af-b1c4-e843e312e2fd ethernet ens37 ens38 be9e2b6b-674b-771d-7251-f3b49b3d23e0 ethernet ens38 [root@controller ~]# ifconfig brq0e728aa4-d9: flags=4163 mtu 1450 inet6 fe80::ac39:edff:fec6:c45f prefixlen 64 scopeid 0x20 ether 3a:68:b1:d8:6d:9b txqueuelen 1000 (Ethernet) RX packets 33 bytes 3664 (3.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1306 (1.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 brq891787bb-ce: flags=4163 mtu 1500 inet 192.168.92.70 netmask 255.255.255.0 broadcast 192.168.92.255 inet6 fe80::fc86:9ff:fe03:c43f prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:2d txqueuelen 1000 (Ethernet) RX packets 5719 bytes 557494 (544.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4793 bytes 1033122 (1008.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 brqded70080-a8: flags=4163 mtu 1450 inet6 fe80::6c74:8eff:fe52:6442 prefixlen 64 scopeid 0x20 ether 0a:10:fd:ab:d1:c3 txqueuelen 1000 (Ethernet) RX packets 33 bytes 3664 (3.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1306 (1.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: flags=4163 mtu 1500 inet 192.168.90.70 netmask 255.255.255.0 broadcast 192.168.90.255 inet6 fe80::b01a:e132:1923:175 prefixlen 64 scopeid 0x20 inet6 fe80::2801:f5c2:4e5a:d003 prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:19 txqueuelen 1000 (Ethernet) RX packets 35429 bytes 10882222 (10.3 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 36847 bytes 21538725 (20.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163 mtu 1500 inet 192.168.91.70 netmask 255.255.255.0 broadcast 192.168.91.255 inet6 fe80::e8fe:eea6:f4f:2d85 prefixlen 64 scopeid 0x20 inet6 fe80::8af8:8b5c:793f:e719 prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:23 txqueuelen 1000 (Ethernet) RX packets 2074 bytes 315225 (307.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1955 bytes 300345 (293.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens38: flags=4163 mtu 1500 inet6 fe80::e64:a89f:4312:ea34 prefixlen 64 scopeid 0x20 inet6 fe80::e8d3:6442:89c0:cd4a prefixlen 64 scopeid 0x20 ether 00:0c:29:cb:a5:2d txqueuelen 1000 (Ethernet) RX packets 6508 bytes 707299 (690.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 5151 bytes 1209445 (1.1 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 330429 bytes 152354583 (145.2 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 330429 bytes 152354583 (145.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap14879488-27: flags=4163 mtu 1450 ether 0a:10:fd:ab:d1:c3 txqueuelen 1000 (Ethernet) RX packets 14 bytes 2860 (2.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 43 bytes 4742 (4.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap4ec496dd-eb: flags=4163 mtu 1450 ether f2:c7:25:13:9f:a8 txqueuelen 1000 (Ethernet) RX packets 396 bytes 42433 (41.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 605 bytes 53467 (52.2 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tapab188c3f-b3: flags=4163 mtu 1450 ether 3a:68:b1:d8:6d:9b txqueuelen 1000 (Ethernet) RX packets 1394 bytes 154190 (150.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1349 bytes 158192 (154.4 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tapcf05d8bf-49: flags=4163 mtu 1500 ether 02:58:51:86:86:42 txqueuelen 1000 (Ethernet) RX packets 5 bytes 446 (446.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 506 bytes 67655 (66.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tape509b650-a8: flags=4163 mtu 1450 ether b6:49:0f:82:12:66 txqueuelen 1000 (Ethernet) RX packets 14 bytes 2862 (2.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 45 bytes 4938 (4.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tapf7f21425-dd: flags=4163 mtu 1500 ether be:90:00:50:f1:c7 txqueuelen 1000 (Ethernet) RX packets 1092 bytes 130261 (127.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1618 bytes 195371 (190.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 vxlan-15: flags=4163 mtu 1450 ether 26:1e:8c:c6:00:dd txqueuelen 1000 (Ethernet) RX packets 593 bytes 44165 (43.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 395 bytes 38529 (37.6 KiB) TX errors 0 dropped 13 overruns 0 carrier 0 collisions 0 vxlan-60: flags=4163 mtu 1450 ether 76:a4:93:79:a9:25 txqueuelen 1000 (Ethernet) RX packets 1337 bytes 138474 (135.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1394 bytes 136372 (133.1 KiB) TX errors 0 dropped 12 overruns 0 carrier 0 collisions 0 6.2 计算节点 [root@compute1 ~]# nmcli connection show NAME UUID TYPE DEVICE brq0e728aa4-d9 431e9bbf-693c-4d98-8286-589c7ecbee0d bridge brq0e728aa4-d9 brqded70080-a8 8675b492-79c5-45c8-8400-f3936482954f bridge brqded70080-a8 ens33 c96bc909-188e-ec64-3a96-6a90982b08ad ethernet ens33 ens37 4a5516a4-dfa4-24af-b1c4-e843e312e2fd ethernet ens37 ens38 be9e2b6b-674b-771d-7251-f3b49b3d23e0 ethernet ens38 tap1a3efab6-a1 f5b8cfef-da22-482e-98bf-ee3137e31c9f tun tap1a3efab6-a1 tap408bc2a8-be 4cad16d6-b230-403f-8437-7f2d98058125 tun tap408bc2a8-be tap6b748b48-0d 93d4510d-2561-40e6-8ed9-4562f256ae49 tun tap6b748b48-0d tap6d4494a7-e1 dcc21992-40e3-4518-a886-16e41cb51c45 tun tap6d4494a7-e1 tapcde22017-68 badb01a0-2873-413a-9ad5-b2865015501d tun tapcde22017-68 tape805da2d-7d 8b65da89-d6ef-424b-8399-3c0756c7b4ad tun tape805da2d-7d [root@compute1 ~]# ifconfig brq0e728aa4-d9: flags=4163 mtu 1450 ether 5a:c1:f3:b2:68:3b txqueuelen 1000 (Ethernet) RX packets 37 bytes 3888 (3.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 brqded70080-a8: flags=4163 mtu 1450 ether ea:e2:23:3f:a9:bb txqueuelen 1000 (Ethernet) RX packets 36 bytes 3832 (3.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33: flags=4163 mtu 1500 inet 192.168.90.71 netmask 255.255.255.0 broadcast 192.168.90.255 inet6 fe80::2801:f5c2:4e5a:d003 prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:9b txqueuelen 1000 (Ethernet) RX packets 21122 bytes 8993984 (8.5 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 21860 bytes 13934762 (13.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163 mtu 1500 inet 192.168.91.71 netmask 255.255.255.0 broadcast 192.168.91.255 inet6 fe80::8af8:8b5c:793f:e719 prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:a5 txqueuelen 1000 (Ethernet) RX packets 1950 bytes 300027 (292.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2098 bytes 317035 (309.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens38: flags=4163 mtu 1500 inet 192.168.92.71 netmask 255.255.255.0 broadcast 192.168.92.255 inet6 fe80::e8d3:6442:89c0:cd4a prefixlen 64 scopeid 0x20 ether 00:0c:29:c7:ba:af txqueuelen 1000 (Ethernet) RX packets 857 bytes 81958 (80.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 871 bytes 60043 (58.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 47342 bytes 2485515 (2.3 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 47342 bytes 2485515 (2.3 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap1a3efab6-a1: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:fe31:3c68 prefixlen 64 scopeid 0x20 ether fe:16:3e:31:3c:68 txqueuelen 1000 (Ethernet) RX packets 366 bytes 32031 (31.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 256 bytes 27425 (26.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap408bc2a8-be: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:feeb:f259 prefixlen 64 scopeid 0x20 ether fe:16:3e:eb:f2:59 txqueuelen 1000 (Ethernet) RX packets 117 bytes 10449 (10.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 96 bytes 10262 (10.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap6b748b48-0d: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:fedc:83c4 prefixlen 64 scopeid 0x20 ether fe:16:3e:dc:83:c4 txqueuelen 1000 (Ethernet) RX packets 128 bytes 11365 (11.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 107 bytes 11298 (11.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tap6d4494a7-e1: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:feb1:57c7 prefixlen 64 scopeid 0x20 ether fe:16:3e:b1:57:c7 txqueuelen 1000 (Ethernet) RX packets 986 bytes 120892 (118.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1107 bytes 119680 (116.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tapcde22017-68: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:fef1:bb5f prefixlen 64 scopeid 0x20 ether fe:16:3e:f1:bb:5f txqueuelen 1000 (Ethernet) RX packets 115 bytes 10293 (10.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 95 bytes 10212 (9.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 tape805da2d-7d: flags=4163 mtu 1450 inet6 fe80::fc16:3eff:fedf:357d prefixlen 64 scopeid 0x20 ether fe:16:3e:df:35:7d txqueuelen 1000 (Ethernet) RX packets 228 bytes 25193 (24.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 236 bytes 29034 (28.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 vxlan-15: flags=4163 mtu 1450 ether ea:e2:23:3f:a9:bb txqueuelen 1000 (Ethernet) RX packets 396 bytes 38557 (37.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 596 bytes 44345 (43.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 vxlan-60: flags=4163 mtu 1450 ether 5a:c1:f3:b2:68:3b txqueuelen 1000 (Ethernet) RX packets 1397 bytes 136480 (133.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1340 bytes 138606 (135.3 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 6.3 存储节点 [root@cinder1 ~]# nmcli connection show NAME UUID TYPE DEVICE ens33 c96bc909-188e-ec64-3a96-6a90982b08ad ethernet ens33 ens37 4a5516a4-dfa4-24af-b1c4-e843e312e2fd ethernet ens37 [root@cinder1 ~]# ifconfig ens33: flags=4163 mtu 1500 inet 192.168.90.72 netmask 255.255.255.0 broadcast 192.168.90.255 inet6 fe80::ffb5:9b12:f911:89ec prefixlen 64 scopeid 0x20 inet6 fe80::b01a:e132:1923:175 prefixlen 64 scopeid 0x20 inet6 fe80::2801:f5c2:4e5a:d003 prefixlen 64 scopeid 0x20 ether 00:0c:29:97:4f:52 txqueuelen 1000 (Ethernet) RX packets 26610 bytes 7137357 (6.8 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 32848 bytes 8610398 (8.2 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens37: flags=4163 mtu 1500 inet 192.168.92.72 netmask 255.255.255.0 broadcast 192.168.92.255 inet6 fe80::8af8:8b5c:793f:e719 prefixlen 64 scopeid 0x20 ether 00:0c:29:97:4f:5c txqueuelen 1000 (Ethernet) RX packets 2718 bytes 210586 (205.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1972 bytes 142053 (138.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73 mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10 loop txqueuelen 1000 (Local Loopback) RX packets 95 bytes 8360 (8.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 95 bytes 8360 (8.1 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 06:56:38 "},"RD/C_Language/":{"url":"RD/C_Language/","title":"C Language","keywords":"","body":"C语言学习 翁恺教程 目录和文件说明 note-1 1.c 嵌入式赋值 不利于阅读 容易出现错误 猜数字游戏 100以内的数字最多7次会被猜出来 2^7 rand() % 100 + 1 是1-100 的数字 算最简分数 基础算法 欧几里得算法 note-2 include/function.h 1.c; 求素数 数组与大小计算问题 搜索数组问题 note-3 1.c 数字计数器 note-4 1.c 1.h //swap //min max //指针应用2，函数返回运行状态，指针返回结果 内存分配 释放内存 内存分配实验，最大,可以测试内存+虚拟内存最大 申请了没有free->长时间运行内存逐渐下降 新手： 忘了 老手： 找不到合适的free时机 free过了再free是不行的 地址变过了，直接去free note-5 不能用运算符对字符串进行运算 通过数组的方式可以遍历字符串 唯一特殊的地方是字符串字面量可以用力啊初始化字符数组 s是一个指针，初始化为指向一个字符串变量 由于这个变量所在的地方，所以实际上s是const char * s ，但是由于历史原因，编译器接受不带const的写法 但是试图对s所指的字符串做写入会导致严重后果 两处相同的东西会指向同一个地方 指针还是数组？ 数组： 这个字符串就在这里 作为本地变量空间自动回收 指针： 这个字符串不知道在哪里 处理参数 动态分配空间 字符串的输入和输出 字符串的不安全性 正确写法 printf(\"%7s\",string1); 安全的字符串输入 常见错误 空字符串 细节 **a 和 a[][] [][] 字符串的应用 int main(int argc, char const *argv[]) { int i ; for ( i= 0; i .\\C_Language.exe 123 0:I:\\note-book\\Markdown-notebook\\RD\\C_Language\\cmake-build-debug\\C_Language.exe 1:123 单字符输入输出putchar int main(int argc,char const *argv[]){ int ch; while ((ch = getchar()) != EOF) { putchar(ch); } return 0; } 字符串处理函数strlen //strlen #include \"string.h\" int main(int argc,char *argv[]){ char line[] = \"Hello\"; printf(\"strlen=%u\\n\", strlen(line)); printf(\"sizeof=%u\\n\", sizeof(line)); return 0; } I:\\note-book\\Markdown-notebook\\RD\\C_Language\\cmake-build-debug\\C_Language.exe strlen=5 sizeof=6 进程已结束,退出代码0 //strcmp int main(int argc,char * argv[]){ char s1[ ] = \"abc\"; // char s2[ ] = \"abc\"; char s2[ ] = \"Abc\"; // 因为地址永远不同，所以输出为0 printf(\"%d\\n\",s1 == s2); printf(\"%d\\n\", strcmp(s1,s2)); if (strcmp(s1,s2) == 0 ){ } return 0; } I:\\note-book\\Markdown-notebook\\RD\\C_Language\\cmake-build-debug\\C_Language.exe 0 1 进程已结束,退出代码0 字符串函数strcpy //初级版本 char *mycpy(char *dst, const char *src) { int idx = 0; while (src[idx] != '\\0') { dst[idx] = src[idx]; idx++; } dst[idx] = '\\0'; return dst; } int main(int argc, char *argv[]) { char s1[] = \"abc\"; char s2[] = \"abc\"; mycpy(s1,s2); return 0; } //高级版本 char *mycpy1(char *dst, const char *src) { char * ret = dst; while (*src) *dst++ = *src++; *dst = '0'; return ret; } int main(int argc, char *argv[]) { char s1[] = \"abc\"; char s2[] = \"abc\"; mycpy(s1, s2); return 0; } 复制字符串的过程 先申请内存+1，再cp 字符串处理函数strcat \\\\strcpy和strcat，strcmp 是不安全的，如果目的地址没有内存空间 增加size_t n参数; 字符串搜索函数 int main(int argc, char *argv[]) { char s[] = \"hello\"; char *p = strchr(s, 'l'); char c = *p; *p = '\\0'; p = strchr(p + 1, 'l'); printf(\"p=%s\\n\", p); // 将搜索的结果复制到另外的地方去 char *t = (char *) malloc(strlen(p) + 1); strcpy(t, p); printf(\"t=%s\\n\", t); free(t); // 找到除了搜索外的其他的 char *e = (char *) malloc(strlen(s) + 1); strcpy(e, s); printf(\"e=%s\\n\", e); free(e); *p = c; return 0; } 字符串中找字符串 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-04 23:14:16 "},"RD/python基础/01_认识Python.html":{"url":"RD/python基础/01_认识Python.html","title":"01_认识Python","keywords":"","body":" 认识 Python 人生苦短，我用 Python —— Life is short, you need Python 目标 Python 的起源 为什么要用 Python？ Python 的特点 Python 的优缺点 01. Python 的起源 Python 的创始人为吉多·范罗苏姆（Guido van Rossum） 1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的解释程序，作为 ABC 语言的一种继承（感觉下什么叫牛人） ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是 ABC 语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果 之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者 1991 年，第一个 Python 解释器 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件 1.1 解释器（科普） 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器 编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++ 解释型语言：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行 编译型语言和解释型语言对比 速度 —— 编译型语言比解释型语言执行速度快 跨平台性 —— 解释型语言比编译型语言跨平台性好 1.2 Python 的设计目标 1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标： 一门简单直观的语言并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解 适用于短期开发的日常任务 这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言 1.3 Python 的设计哲学 优雅 明确 简单 在 Python 解释器内运行 `import this` 可以获得完整的列表 --> Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事 如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法 在 Python 社区，吉多被称为“仁慈的独裁者” 02. 为什么选择 Python？ 代码量少 …… 同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python 03. Python 特点 Python 是完全面向对象的语言 函数、模块、数字、字符串都是对象，在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 Python 拥有一个强大的标准库，Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域 面向对象的思维方式 面向对象 是一种 思维方式，也是一门 程序设计技术 要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！ 对象 就是 谁 要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求 04. Python 的优缺点 4.1 优点 简单、易学 免费、开源 面向对象 丰富的库 可扩展性 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们 …… 4.2 缺点 运行速度 国内市场较小 中文资料匮乏 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/02_第一个Python程序.html":{"url":"RD/python基础/02_第一个Python程序.html","title":"02_第一个Python程序","keywords":"","body":"第一个 Python 程序 目标 第一个 HelloPython 程序 Python 2.x 与 3.x 版本简介 执行 Python 程序的三种方式 解释器 —— python / python3 交互式 —— ipython 集成开发环境 —— PyCharm 01. 第一个 HelloPython 程序 1.1 Python 源程序的基本概念 Python 源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做 Python 的开发 Python 程序的 文件扩展名 通常都是 .py 1.2 演练步骤 在桌面下，新建 认识Python 目录 在 认识Python 目录下新建 01-HelloPython.py 文件 使用 gedit 编辑 01-HelloPython.py 并且输入以下内容： print(\"hello python\") print(\"hello world\") 在终端中输入以下命令执行 01-HelloPython.py $ python 01-HelloPython.py print 是 python 中我们学习的第一个 函数 print 函数的作用，可以把 \"\" 内部的内容，输出到屏幕上 1.3 演练扩展 —— 认识错误（BUG） 关于错误 编写的程序不能正常执行，或者执行的结果不是我们期望的 俗称 BUG，是程序员在开发时非常常见的，初学者常见错误的原因包括： 手误 对已经学习过的知识理解还存在不足 对语言还有需要学习和提升的内容 在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法 每一个程序员都是在不断地修改错误中成长的 第一个演练中的常见错误 1> 手误，例如使用 pirnt(\"Hello world\") NameError: name 'pirnt' is not defined 名称错误：'pirnt' 名字没有定义 2> 将多条 print 写在一行 SyntaxError: invalid syntax 语法错误：语法无效 每行代码负责完成一个动作 3> 缩进错误 IndentationError: unexpected indent 缩进错误：不期望出现的缩进 Python 是一个格式非常严格的程序设计语言 目前而言，大家记住每行代码前面都不要增加空格 4> python 2.x 默认不支持中文 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x Python 2.x 默认不支持中文，具体原因，等到介绍 字符编码 时给大家讲解 Python 2.x 的解释器名称是 python Python 3.x 的解释器名称是 python3 SyntaxError: Non-ASCII character '\\xe4' in file 01-HelloPython.py on line 3, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 '\\xe4'，但是没有声明文件编码 请访问 http://python.org/dev/peps/pep-0263/ 了解详细信息 ASCII 字符只包含 256 个字符，不支持中文 有关字符编码的问题，后续会讲 单词列表 * error 错误 * name 名字 * defined 已经定义 * syntax 语法 * invalid 无效 * Indentation 索引 * unexpected 意外的，不期望的 * character 字符 * line 行 * encoding 编码 * declared 声明 * details 细节，详细信息 * ASCII 一种字符编码 02. Python 2.x 与 3​​.x 版本简介 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x 新的 Python 程序建议使用 Python 3.0 版本的语法 Python 2.x 是 过去的版本 解释器名称是 python Python 3.x 是 现在和未来 主流的版本 解释器名称是 python3 相对于 Python 的早期版本，这是一个 较大的升级 为了不带入过多的累赘，Python 3.0 在设计的时候 没有考虑向下兼容 许多早期 Python 版本设计的程序都无法在 Python 3.0 上正常执行 Python 3.0 发布于 2008 年 到目前为止，Python 3.0 的稳定版本已经有很多年了 Python 3.3 发布于 2012 Python 3.4 发布于 2014 Python 3.5 发布于 2015 Python 3.6 发布于 2016 为了照顾现有的程序，官方提供了一个过渡版本 —— Python 2.6 基本使用了 Python 2.x 的语法和库 同时考虑了向 Python 3.0 的迁移，允许使用部分 Python 3.0 的语法与函数 2010 年中推出的 Python 2.7 被确定为 最后一个Python 2.x 版本 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议 先使用 Python 3.0 版本进行开发 然后使用 Python 2.6、Python 2.7 来执行，并且做一些兼容性的处理 03. 执行 Python 程序的三种方式 3.1. 解释器 python / python3 Python 的解释器 # 使用 python 2.x 解释器 $ python xxx.py # 使用 python 3.x 解释器 $ python3 xxx.py 其他解释器（知道） Python 的解释器 如今有多个语言的实现，包括： CPython —— 官方版本的 C 语言实现 Jython —— 可以运行在 Java 平台 IronPython —— 可以运行在 .NET 和 Mono 平台 PyPy —— Python 实现的，支持 JIT 即时编译 3.2. 交互式运行 Python 程序 直接在终端中运行解释器，而不输入要执行的文件名 在 Python 的 Shell 中直接输入 Python 的代码，会立即看到程序执行结果 1) 交互式运行 Python 的优缺点 优点 适合于学习/验证 Python 语法或者局部代码 缺点 代码不能保存 不适合运行太大的程序 2) 退出 官方的解释器 1> 直接输入 exit() >>> exit() 2> 使用热键退出 在 python 解释器中，按热键 ctrl + d 可以退出解释器 3) IPython IPython 中 的 “I” 代表 交互 interactive 特点 IPython 是一个 python 的 交互式 shell，比默认的 python shell 好用得多 支持自动补全 自动缩进 支持 bash shell 命令 内置了许多很有用的功能和函数 IPython 是基于 BSD 开源的 版本 Python 2.x 使用的解释器是 ipython Python 3.x 使用的解释器是 ipython3 要退出解释器可以有以下两种方式： 1> 直接输入 exit In [1]: exit 2> 使用热键退出 在 IPython 解释器中，按热键 ctrl + d，IPython 会询问是否退出解释器 IPython 的安装 $ sudo apt install ipython 3.3. Python 的 IDE —— PyCharm 1） 集成开发环境（IDE） 集成开发环境（IDE，Integrated Development Environment）—— 集成了开发软件需要的所有工具，一般包括以下工具： 图形用户界面 代码编辑器（支持 代码补全／自动缩进） 编译器／解释器 调试器（断点／单步执行） …… 2）PyCharm 介绍 PyCharm 是 Python 的一款非常优秀的集成开发环境 PyCharm 除了具有一般 IDE 所必备功能外，还可以在 Windows、Linux、macOS 下使用 PyCharm 适合开发大型项目 一个项目通常会包含 很多源文件 每个 源文件 的代码行数是有限的，通常在几百行之内 每个 源文件 各司其职，共同完成复杂的业务功能 3）PyCharm 快速体验 文件导航区域 能够 浏览／定位／打开 项目文件 文件编辑区域 能够 编辑 当前打开的文件 控制台区域 能够： 输出程序执行内容 跟踪调试代码的执行 右上角的 工具栏 能够 执行(SHIFT + F10) / 调试(SHIFT + F9) 代码 通过控制台上方的单步执行按钮(F8)，可以单步执行代码 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/04_多文件项目的演练.html":{"url":"RD/python基础/04_多文件项目的演练.html","title":"04_多文件项目的演练","keywords":"","body":"多文件项目的演练 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行 多文件项目演练 在 01_Python基础 项目中新建一个 hm_02_第2个Python程序.py 在 hm_02_第2个Python程序.py 文件中添加一句 print(\"hello\") 点击右键执行 hm_02_第2个Python程序.py 提示 在 PyCharm 中，要想让哪一个 Python 程序能够执行，必须首先通过 鼠标右键的方式执行 一下 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试 对于商业项目而言，通常在一个项目中，只有一个 可以直接执行的 Python 源程序 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/05_注释.html":{"url":"RD/python基础/05_注释.html","title":"05_注释","keywords":"","body":"注释 目标 注释的作用 单行注释（行注释） 多行注释（块注释） 01. 注释的作用 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 02. 单行注释(行注释) 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 示例代码如下： # 这是第一个单行注释 print(\"hello python\") 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字 在代码后面增加的单行注释 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字 但是，需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 示例代码如下： print(\"hello python\") # 输出 `hello python` 03. 多行注释（块注释） 如果希望编写的 注释信息很多，一行无法显示，就可以使用多行注释 要在 Python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以) 示例代码如下： \"\"\" 这是一个多行注释 在多行注释之间，可以写很多很多的内容…… \"\"\" print(\"hello python\") 什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 在一些正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码 关于代码规范 Python 官方提供有一系列 PEP（Python Enhancement Proposals） 文档 其中第 8 篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8 文档地址：https://www.python.org/dev/peps/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/06_算数运算符.html":{"url":"RD/python基础/06_算数运算符.html","title":"06_算数运算符","keywords":"","body":"算数运算符 计算机，顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用 01. 算数运算符 算数运算符是 运算符的一种 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 In [1]: \"-\" * 50 Out[1]: '----------------------------------------' 02. 算数运算符的优先级 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是： 先乘除后加减 同级运算符是 从左至右 计算 可以使用 () 调整计算的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 例如： 2 + 3 * 5 = 17 (2 + 3) * 5 = 25 2 * 3 + 5 = 11 2 * (3 + 5) = 16 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/07_程序执行原理（科普）.html":{"url":"RD/python基础/07_程序执行原理（科普）.html","title":"07_程序执行原理（科普）","keywords":"","body":"程序执行原理（科普） 目标 计算机中的 三大件 程序执行的原理 程序的作用 01. 计算机中的三大件 计算机中包含有较多的硬件，但是一个程序要运行，有 三个 核心的硬件，分别是： CPU 中央处理器，是一块超大规模的集成电路 负责 处理数据／计算 内存 临时 存储数据（断电之后，数据会消失） 速度快 空间小（单位价格高） 硬盘 永久 存储数据 速度慢 空间大（单位价格低） CPU 内存 硬盘 思考题 计算机中哪一个硬件设备负责执行程序？ CPU 内存 的速度快还是 硬盘 的速度快？ 内存 我们的程序是安装在内存中的，还是安装在硬盘中的？ 硬盘 我买了一个内存条，有 500G 的空间！！！，这句话对吗？ 不对，内存条通常只有 4G / 8G / 16G / 32G 计算机关机之后，内存中的数据都会消失，这句话对吗？ 正确 02. 程序执行的原理 程序 运行之前，程序是 保存在硬盘 中的 当要运行一个程序时 操作系统会首先让 CPU 把程序复制到 内存 中 CPU 执行 内存 中的 程序代码 程序要执行，首先要被加载到内存 2.1 Python 程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码 CPU 负责执行翻译完成的代码 Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小 # 1. 确认解释器所在位置 $ which python # 2. 查看 python 文件大小(只是一个软链接) $ ls -lh /usr/bin/python # 3. 查看具体文件大小 $ ls -lh /usr/bin/python2.7 提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本 03. 程序的作用 程序就是 用来处理数据 的！ 新闻软件 提供的 新闻内容、评论…… 是数据 电商软件 提供的 商品信息、配送信息…… 是数据 运动类软件 提供的 运动数据…… 是数据 地图类软件 提供的 地图信息、定位信息、车辆信息…… 是数据 即时通讯软件 提供的 聊天信息、好友信息…… 是数据 …… 3.1 思考 QQ 程序的启动过程 QQ 在运行之前，是保存在 硬盘 中的 运行之后，QQ 程序就会被加载到 内存 中了 3.2 思考 QQ 程序的 登录 过程 读取用户输入的 QQ 号码 读取用户输入的 QQ 密码 将 QQ 号码 和 QQ 密码 发送给腾讯的服务器，等待服务器确认用户信息 思考 1 在 QQ 这个程序将 QQ 号码 和 QQ 密码 发送给服务器之前，是否需要先存储一下 QQ 号码 和 密码? 答案 肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！ 思考 2 QQ 这个程序把 QQ 号码 和 QQ 密码 保存在哪里？ 答案 保存在 内存 中，因为 QQ 程序自己就在内存中 思考 3 QQ 这个程序是怎么保存用户的 QQ 号码 和 QQ 密码 的？ 答案 在内存中为 QQ 号码 和 QQ 密码 各自分配一块空间 在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ 号码 和 QQ 密码 使用一个 别名 标记 QQ 号码 和 QQ 密码 在内存中的位置 在程序内部，为 QQ 号码 和 QQ 密码 在内存中分配的空间就叫做 变量 程序就是用来处理数据的，而变量就是用来存储数据的 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/08_变量的基本使用.html":{"url":"RD/python基础/08_变量的基本使用.html","title":"08_变量的基本使用","keywords":"","body":"变量的基本使用 程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量定义 变量的类型 变量的命名 01. 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 等号（=）用来给变量赋值 = 左边是一个变量名 = 右边是存储在变量中的值 变量名 = 值 变量定义之后，后续就可以直接使用了 1) 变量演练1 —— iPython # 定义 qq_number 的变量用来保存 qq 号码 In [1]: qq_number = \"1234567\" # 输出 qq_number 中保存的内容 In [2]: qq_number Out[2]: '1234567' # 定义 qq_password 的变量用来保存 qq 密码 In [3]: qq_password = \"123\" # 输出 qq_password 中保存的内容 In [4]: qq_password Out[4]: '123' 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数 2) 变量演练 2 —— PyCharm # 定义 qq 号码变量 qq_number = \"1234567\" # 定义 qq 密码变量 qq_password = \"123\" # 在程序中，如果要输出变量的内容，需要使用 print 函数 print(qq_number) print(qq_password) 使用解释器执行，如果要输出变量的内容，必须要要使用 print 函数 3) 变量演练 3 —— 超市买苹果 可以用 其他变量的计算结果 来定义变量 变量定义之后，后续就可以直接使用了 需求 苹果的价格是 8.5 元/斤 买了 7.5 斤 苹果 计算付款金额 # 定义苹果价格变量 price = 8.5 # 定义购买重量 weight = 7.5 # 计算金额 money = price * weight print(money) 思考题 如果 只要买苹果，就返 5 块钱 请重新计算购买金额 # 定义苹果价格变量 price = 8.5 # 定义购买重量 weight = 7.5 # 计算金额 money = price * weight # 只要买苹果就返 5 元 money = money - 5 print(money) 提问 上述代码中，一共定义有几个变量？ 三个：price／weight／money money = money - 5 是在定义新的变量还是在使用变量？ 直接使用之前已经定义的变量 变量名 只有在 第一次出现 才是 定义变量 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量 在程序开发中，可以修改之前定义变量中保存的值吗？ 可以 变量中存储的值，就是可以 变 的 02. 变量的类型 在内存中创建一个变量，会包括： 变量的名称 变量保存的数据 变量存储数据的类型 变量的地址（标示） 2.1 变量类型的演练 —— 个人信息 需求 定义变量保存小明的个人信息 姓名：小明 年龄：18 岁 性别：是男生 身高：1.75 米 体重：75.0 公斤 利用 单步调试 确认变量中保存数据的类型 提问 在演练中，一共有几种数据类型？ 4 种 str —— 字符串 bool —— 布尔（真假） int —— 整数 float —— 浮点数（小数） 在 Python 中定义变量时需要指定类型吗？ 不需要 Python 可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型 2.2 变量的类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 In [1]: type(name) 2.3 不同类型变量之间的计算 1) 数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 演练步骤 定义整数 i = 10 定义浮点数 f = 10.5 定义布尔型 b = True 在 iPython 中，使用上述三个变量相互进行算术运算 2) 字符串变量 之间使用 + 拼接字符串 在 Python 中，字符串之间可以使用 + 拼接生成新的字符串 In [1]: first_name = \"三\" In [2]: last_name = \"张\" In [3]: first_name + last_name Out[3]: '三张' 3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串 In [1]: \"-\" * 50 Out[1]: '--------------------------------------------------' 4) 数字型变量 和 字符串 之间 不能进行其他计算 In [1]: first_name = \"zhang\" In [2]: x = 10 In [3]: x + first_name --------------------------------------------------------------------------- TypeError: unsupported operand type(s) for +: 'int' and 'str' 类型错误：`+` 不支持的操作类型：`int` 和 `str` 2.4 变量的输入 所谓 输入，就是 用代码 获取 用户通过 键盘 输入的信息 例如：去银行取钱，在 ATM 上输入密码 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数 1) 关于函数 一个 提前准备好的功能(别人或者自己写的代码)，可以直接使用，而 不用关心内部的细节 目前已经学习过的函数 函数 说明 print(x) 将 x 输出到控制台 type(x) 查看 x 的变量类型 2) input 函数实现键盘输入 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串 语法如下： 字符串变量 = input(\"提示信息：\") 3) 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 4) 变量输入演练 —— 超市买苹果增强版 需求 收银员输入 苹果的价格，单位：元／斤 收银员输入 用户购买苹果的重量，单位：斤 计算并且 输出 付款金额 演练方式 1 # 1. 输入苹果单价 price_str = input(\"请输入苹果价格：\") # 2. 要求苹果重量 weight_str = input(\"请输入苹果重量：\") # 3. 计算金额 # 1> 将苹果单价转换成小数 price = float(price_str) # 2> 将苹果重量转换成小数 weight = float(weight_str) # 3> 计算付款金额 money = price * weight print(money) 提问 演练中，针对 价格 定义了几个变量？ 两个 price_str 记录用户输入的价格字符串 price 记录转换后的价格数值 思考 —— 如果开发中，需要用户通过控制台 输入 很多个 数字，针对每一个数字都要定义两个变量，方便吗？ 演练方式 2 —— 买苹果改进版 定义 一个 浮点变量 接收用户输入的同时，就使用 float 函数进行转换 price = float(input(\"请输入价格:\")) 改进后的好处： 节约空间，只需要为一个变量分配空间 起名字方便，不需要为中间变量起名字 改进后的“缺点”： 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度 提示 如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！ 2.5 变量的格式化输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 在 Python 中可以使用 print 函数将信息输出到控制台 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 语法格式如下： print(\"格式化字符串\" % 变量1) print(\"格式化字符串\" % (变量1, 变量2...)) 格式化输出演练 —— 基本练习 需求 定义字符串变量 name，输出 我的名字叫 小明，请多多关照！ 定义整数变量 student_no，输出 我的学号是 000001 定义小数 price、weight、money，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 定义一个小数 scale，输出 数据比例是 10.00% print(\"我的名字叫 %s，请多多关照！\" % name) print(\"我的学号是 %06d\" % student_no) print(\"苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元\" % (price, weight, money)) print(\"数据比例是 %.02f%%\" % (scale * 100)) 课后练习 —— 个人名片 需求 在控制台依次提示用户输入：姓名、公司、职位、电话、邮箱 按照以下格式输出： ************************************************** 公司名称 姓名 (职位) 电话：电话 邮箱：邮箱 ************************************************** 实现代码如下： \"\"\" 在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱 \"\"\" name = input(\"请输入姓名：\") company = input(\"请输入公司：\") title = input(\"请输入职位：\") phone = input(\"请输入电话：\") email = input(\"请输入邮箱：\") print(\"*\" * 50) print(company) print() print(\"%s (%s)\" % (name, title)) print() print(\"电话：%s\" % phone) print(\"邮箱：%s\" % email) print(\"*\" * 50) Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/09_变量的命名.html":{"url":"RD/python基础/09_变量的命名.html","title":"09_变量的命名","keywords":"","body":"变量的命名 目标 标识符和关键字 变量的命名规则 0.1 标识符和关键字 1.1 标识符 标示符就是程序员定义的 变量名、函数名 名字 需要有 见名知义 的效果，见下图： 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 思考：下面的标示符哪些是正确的，哪些不正确为什么？ fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt My_tExt _test test!32 haha(da)tt jack_rose jack&rose GUI G.U.I 1.2 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发者 不允许定义和关键字相同的名字的标示符 通过以下命令可以查看 Python 中的关键字 In [1]: import keyword In [2]: print(keyword.kwlist) 提示：关键字的学习及使用，会在后面的课程中不断介绍 import 关键字 可以导入一个 “工具包” 在 Python 中不同的工具包，提供有不同的工具 02. 变量的命名规则 命名规则 可以被视为一种 惯例，并无绝对与强制 目的是为了 增加代码的识别和可读性 注意 Python 中的 标识符 是 区分大小写的 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都使用小写字母 单词与单词之间使用 _下划线 连接 例如：first_name、last_name、qq_number、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如：FirstName、LastName、CamelCase Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/10_判断（if）语句.html":{"url":"RD/python基础/10_判断（if）语句.html","title":"10_判断（if）语句","keywords":"","body":"判断（if）语句 目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用 01. 开发中的应用场景 生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？…… 程序中的判断 if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天 else: 盼着发工资 判断的定义 如果 条件满足，才能做某件事情， 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化！ 判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支 02. if 语句体验 2.1 if 判断语句基本语法 在 Python 中，if 语句 就是用来进行判断的，格式如下： if 要判断的条件: 条件成立时，要做的事情 …… 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格 在 Python 开发中，Tab 和空格不要混用！ 我们可以把整个 if 语句看成一个完整的代码块 2.2 判断语句演练 —— 判断年龄 需求 定义一个整数变量记录年龄 判断是否满 18 岁 （>=） 如果满 18 岁，允许进网吧嗨皮 # 1. 定义年龄变量 age = 18 # 2. 判断是否满 18 岁 # if 语句以及缩进部分的代码是一个完整的代码块 if age >= 18: print(\"可以进网吧嗨皮……\") # 3. 思考！- 无论条件是否满足都会执行 print(\"这句代码什么时候执行?\") 注意： if 语句以及缩进部分是一个 完整的代码块 2.3 else 处理条件不满足的情况 思考 在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢？ 答案 else，格式如下： if 要判断的条件: 条件成立时，要做的事情 …… else: 条件不成立时，要做的事情 …… 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 2.4 判断语句演练 —— 判断年龄改进 需求 输入用户年龄 判断是否满 18 岁 （>=） 如果满 18 岁，允许进网吧嗨皮 如果未满 18 岁，提示回家写作业 # 1. 输入用户年龄 age = int(input(\"今年多大了？\")) # 2. 判断是否满 18 岁 # if 语句以及缩进部分的代码是一个完整的语法块 if age >= 18: print(\"可以进网吧嗨皮……\") else: print(\"你还没长大，应该回家写作业！\") # 3. 思考！- 无论条件是否满足都会执行 print(\"这句代码什么时候执行?\") 03. 逻辑运算 在程序开发中，通常 在判断条件时，会需要同时判断多个条件 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 逻辑运算符 逻辑运算符 可以把 多个条件 按照 逻辑 进行 连接，变成 更复杂的条件 Python 中的 逻辑运算符 包括：与 and／或 or／非 not 三种 3.1 and 条件1 and 条件2 与／并且 两个条件同时满足，返回 True 只要有一个不满足，就返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 不成立 不成立 成立 不成立 不成立 不成立 不成立 3.2 or 条件1 or 条件2 或／或者 两个条件只要有一个满足，返回 True 两个条件都不满足，返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 成立 不成立 成立 成立 不成立 不成立 不成立 3.3 not not 条件 非／不是 条件 结果 成立 不成立 不成立 成立 逻辑运算演练 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 要求人的年龄在 0-120 之间 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 要求只要有一门成绩 > 60 分就算合格 练习3: 定义一个布尔型变量 is_employee，编写代码判断是否是本公司员工 如果不是提示不允许入内 答案 1： # 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 age = 100 # 要求人的年龄在 0-120 之间 if age >= 0 and age 答案 2： # 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 python_score = 50 c_score = 50 # 要求只要有一门成绩 > 60 分就算合格 if python_score > 60 or c_score > 60: print(\"考试通过\") else: print(\"再接再厉！\") 答案 3： # 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工 is_employee = True # 如果不是提示不允许入内 if not is_employee: print(\"非公勿内\") 04. if 语句进阶 4.1 elif 在开发中，使用 if 可以 判断条件 使用 else 可以处理 条件不成立 的情况 但是，如果希望 再增加一些条件，条件不同，需要执行的代码也不同 时，就可以使用 elif 语法格式如下： if 条件1: 条件1满足执行的代码 …… elif 条件2: 条件2满足时，执行的代码 …… elif 条件3: 条件3满足时，执行的代码 …… else: 以上条件都不满足时，执行的代码 …… 对比逻辑运算符的代码 if 条件1 and 条件2: 条件1满足 并且 条件2满足 执行的代码 …… 注意 elif 和 else 都必须和 if 联合使用，而不能单独使用 可以将 if、elif 和 else 以及各自缩进的代码，看成一个 完整的代码块 elif 演练 —— 女友的节日 需求 定义 holiday_name 字符串变量记录节日名称 如果是 情人节 应该 买玫瑰／看电影 如果是 平安夜 应该 买苹果／吃大餐 如果是 生日 应该 买蛋糕 其他的日子每天都是节日啊…… holiday_name = \"平安夜\" if holiday_name == \"情人节\": print(\"买玫瑰\") print(\"看电影\") elif holiday_name == \"平安夜\": print(\"买苹果\") print(\"吃大餐\") elif holiday_name == \"生日\": print(\"买蛋糕\") else: print(\"每天都是节日啊……\") 4.2 if 的嵌套 elif 的应用场景是：同时 判断 多个条件，所有的条件是 平级 的 在开发中，使用 if 进行条件判断，如果希望 在条件成立的执行语句中 再 增加条件判断，就可以使用 if 的嵌套 if 的嵌套 的应用场景就是：在之前条件满足的前提下，再增加额外的判断 if 的嵌套 的语法格式，除了缩进之外 和之前的没有区别 语法格式如下： if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理 else: 条件1 不满足时，执行的代码 …… if 的嵌套 演练 —— 火车站安检 需求 定义布尔型变量 has_ticket 表示是否有车票 定义整型变量 knife_length 表示刀的长度，单位：厘米 首先检查是否有车票，如果有，才允许进行 安检 安检时，需要检查刀的长度，判断是否超过 20 厘米 如果超过 20 厘米，提示刀的长度，不允许上车 如果不超过 20 厘米，安检通过 如果没有车票，不允许进门 # 定义布尔型变量 has_ticket 表示是否有车票 has_ticket = True # 定义整数型变量 knife_length 表示刀的长度，单位：厘米 knife_length = 20 # 首先检查是否有车票，如果有，才允许进行 安检 if has_ticket: print(\"有车票，可以开始安检...\") # 安检时，需要检查刀的长度，判断是否超过 20 厘米 # 如果超过 20 厘米，提示刀的长度，不允许上车 if knife_length >= 20: print(\"不允许携带 %d 厘米长的刀上车\" % knife_length) # 如果不超过 20 厘米，安检通过 else: print(\"安检通过，祝您旅途愉快……\") # 如果没有车票，不允许进门 else: print(\"大哥，您要先买票啊\") 05. 综合应用 —— 石头剪刀布 目标 强化 多个条件 的 逻辑运算 体会 import 导入模块（“工具包”）的使用 需求 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能 比较胜负 序号 规则 1 石头 胜 剪刀 2 剪刀 胜 布 3 布 胜 石头 5.1 基础代码实现 先 假定电脑就只会出石头，完成整体代码功能 # 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） player = int(input(\"请出拳 石头（1）／剪刀（2）／布（3）：\")) # 电脑 随机 出拳 - 假定电脑永远出石头 computer = 1 # 比较胜负 # 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号 # 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格 if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(\"噢耶！！！电脑弱爆了！！！\") elif player == computer: print(\"心有灵犀，再来一盘！\") else: print(\"不行，我要和你决战到天亮！\") 5.2 随机数的处理 在 Python 中，要使用随机数，首先需要导入 随机数 的 模块 —— “工具包” import random 导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数 random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 b 例如： random.randint(12, 20) # 生成的随机数n: 12 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/11_运算符.html":{"url":"RD/python基础/11_运算符.html","title":"11_运算符","keywords":"","body":"运算符 目标 算数运算符 比较（关系）运算符 逻辑运算符 赋值运算符 运算符的优先级 数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表 01. 算数运算符 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 In [1]: \"-\" * 50 Out[1]: '----------------------------------------' 02. 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True > 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True >= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True Python 2.x 中判断 不等于 还可以使用 <> 运算符 != 在 Python 2.x 中同样可以用来判断 不等于 03. 逻辑运算符 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 04. 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 05. 运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 not or and 逻辑运算符 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/12_循环.html":{"url":"RD/python基础/12_循环.html","title":"12_循环","keywords":"","body":"循环 目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套 01. 程序的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下，顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 02. while 循环基本使用 循环的作用就是让 指定的代码 重复的执行 while 循环最常用的应用场景就是 让执行的代码 按照 指定的次数 重复 执行 需求 —— 打印 5 遍 Hello Python 思考 —— 如果要求打印 100 遍怎么办？ 2.1 while 语句基本语法 初始条件设置 —— 通常是重复执行的 计数器 while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 注意： while 语句以及缩进部分是一个 完整的代码块 第一个 while 循环 需求 打印 5 遍 Hello Python # 1. 定义重复次数计数器 i = 1 # 2. 使用 while 判断条件 while i 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的 死循环 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 2.2 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 2.3 Python 中的计数方法 常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数 因此，大家在编写程序时，应该尽量养成习惯：除非需求的特殊要求，否则 循环 的计数都从 0 开始 2.4 循环计算 在程序开发中，通常会遇到 利用循环 重复计算 的需求 遇到这种需求，可以： 在 while 上方定义一个变量，用于 存放最终计算结果 在循环体内部，每次循环都用 最新的计算结果，更新 之前定义的变量 需求 计算 0 ~ 100 之间所有数字的累计求和结果 # 计算 0 ~ 100 之间所有数字的累计求和结果 # 0. 定义最终结果的变量 result = 0 # 1. 定义一个整数的变量记录循环的次数 i = 0 # 2. 开始循环 while i 需求进阶 计算 0 ~ 100 之间 所有 偶数 的累计求和结果 开发步骤 编写循环 确认 要计算的数字 添加 结果 变量，在循环内部 处理计算结果 # 0. 最终结果 result = 0 # 1. 计数器 i = 0 # 2. 开始循环 while i 03. break 和 continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 3.1 break 在循环过程中，如果 某一个条件满足后，不 再希望 循环继续执行，可以使用 break 退出循环 i = 0 while i break 只针对当前所在循环有效 3.2 continue 在循环过程中，如果 某一个条件满足后，不 希望 执行循环代码，但是又不希望退出循环，可以使用 continue 也就是：在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行 i = 0 while i 需要注意：使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环 continue 只针对当前所在循环有效 04. while 循环嵌套 4.1 循环嵌套 while 嵌套就是：while 里面还有 while while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 4.2 循环嵌套演练 —— 九九乘法表 第 1 步：用嵌套打印小星星 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 * ** *** **** ***** 使用字符串 * 打印 # 1. 定义一个计数器变量，从数字1开始，循环会比较方便 row = 1 while row 第 2 步：使用循环嵌套打印小星星 知识点 对 print 函数的使用做一个增强 在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行 如果不希望末尾增加换行，可以在 print 函数输出内容的后面增加 , end=\"\" 其中 \"\" 中间可以指定 print 函数输出内容之后，继续希望显示的内容 语法格式如下： # 向控制台输出内容结束之后，不会换行 print(\"*\", end=\"\") # 单纯的换行 print(\"\") end=\"\" 表示向控制台输出内容结束之后，不会换行 假设 Python 没有提供 字符串的 * 操作 拼接字符串 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 * ** *** **** ***** 开发步骤 1> 完成 5 行内容的简单输出 2> 分析每行内部的 * 应该如何处理？ 每行显示的星星和当前所在的行数是一致的 嵌套一个小的循环，专门处理每一行中 列 的星星显示 row = 1 while row 第 3 步： 九九乘法表 需求 输出 九九乘法表，格式如下： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 开发步骤 打印 9 行小星星 * ** *** **** ***** ****** ******* ******** ********* 将每一个 * 替换成对应的行与列相乘 # 定义起始行 row = 1 # 最大打印 9 行 while row 字符串中的转义字符 \\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐 \\n 在控制台输出一个 换行符 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本 转义字符 描述 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\n 换行 \\t 横向制表符 \\r 回车 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/13_函数基础.html":{"url":"RD/python基础/13_函数基础.html","title":"13_函数基础","keywords":"","body":"函数基础 目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套调用 在模块中定义函数 01. 函数的快速体验 1.1 快速体验 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成果 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用 演练步骤 新建 04_函数 项目 复制之前完成的 乘法表 文件 修改文件，增加函数定义 multiple_table(): 新建另外一个文件，使用 import 导入并且调用函数 02. 函数基本使用 2.1 函数的定义 定义函数的格式如下： def 函数名(): 函数封装的代码 …… def 是英文 define 的缩写 函数名称 应该能够表达 函数封装代码 的功能，方便后续的调用 函数名称 的命名应该 符合 标识符的命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 2.2 函数调用 调用函数很简单的，通过 函数名() 即可完成对函数的调用 2.3 第一个函数演练 需求 编写一个打招呼 say_hello 的函数，封装三行打招呼的代码 在函数下方调用打招呼的代码 name = \"小明\" # 解释器知道这里定义了一个函数 def say_hello(): print(\"hello 1\") print(\"hello 2\") print(\"hello 3\") print(name) # 只有在调用函数时，之前定义的函数才会被执行 # 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码 say_hello() print(name) 用 单步执行 F8 和 F7 观察以下代码的执行过程 定义好函数之后，只表示这个函数封装了一段代码而已 如果不主动调用函数，函数是不会主动执行的 思考 能否将 函数调用 放在 函数定义 的上方？ 不能！ 因为在 使用函数名 调用函数之前，必须要保证 Python 已经知道函数的存在 否则控制台会提示 NameError: name 'say_hello' is not defined (名称错误：say_hello 这个名字没有被定义) 2.4 PyCharm 的调试工具 F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行 F7 Step Into 可以单步执行代码，如果是函数，会进入函数内部 2.5 函数的文档注释 在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号 在 连续的三对引号 之间编写对函数的说明文字 在 函数调用 位置，使用快捷键 CTRL + Q 可以查看函数的说明信息 注意：因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行 03. 函数的参数 演练需求 开发一个 sum_2_num 的函数 函数能够实现 两个数字的求和 功能 演练代码如下： def sum_2_num(): num1 = 10 num2 = 20 result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result)) sum_2_num() 思考一下存在什么问题 函数只能处理 固定数值 的相加 如何解决？ 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！ 3.1 函数参数的使用 在函数名的后面的小括号内部填写 参数 多个参数之间使用 , 分隔 def sum_2_num(num1, num2): result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result)) sum_2_num(50, 20) 3.2 参数的作用 函数，把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据 在函数 内部，把参数当做 变量 使用，进行需要的数据处理 函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递 3.3 形参和实参 形参：定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用 实参：调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的 04. 函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 注意：return 表示返回，后续的代码都不会被执行 def sum_2_num(num1, num2): \"\"\"对两个数字的求和\"\"\" return num1 + num2 # 调用函数，并使用 result 变量接收计算结果 result = sum_2_num(10, 20) print(\"计算结果是 %d\" % result) 05. 函数的嵌套调用 一个函数里面 又调用 了 另外一个函数，这就是 函数嵌套调用 如果函数 test2 中，调用了另外一个函数 test1 那么执行到调用 test1 函数时，会先把函数 test1 中的任务都执行完 才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码 def test1(): print(\"*\" * 50) print(\"test 1\") print(\"*\" * 50) def test2(): print(\"-\" * 50) print(\"test 2\") test1() print(\"-\" * 50) test2() 函数嵌套的演练 —— 打印分隔线 体会一下工作中 需求是多变 的 需求 1 定义一个 print_line 函数能够打印 * 组成的 一条分隔线 def print_line(char): print(\"*\" * 50) 需求 2 定义一个函数能够打印 由任意字符组成 的分隔线 def print_line(char): print(char * 50) 需求 3 定义一个函数能够打印 任意重复次数 的分隔线 def print_line(char, times): print(char * times) 需求 4 定义一个函数能够打印 5 行 的分隔线，分隔线要求符合需求 3 提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数！ def print_line(char, times): print(char * times) def print_lines(char, times): row = 0 while row 06. 使用模块中的函数 模块是 Python 程序架构的一个核心概念 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具 6.1 第一个模块体验 步骤 新建 hm_10_分隔线模块.py 复制 hm_09_打印多条分隔线.py 中的内容，最后一行 print 代码除外 增加一个字符串变量 name = \"黑马程序员\" 新建 hm_10_体验模块.py 文件，并且编写以下代码： import hm_10_分隔线模块 hm_10_分隔线模块.print_line(\"-\", 80) print(hm_10_分隔线模块.name) 体验小结 可以 在一个 Python 文件 中 定义 变量 或者 函数 然后在 另外一个文件中 使用 import 导入这个模块 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数 模块可以让 曾经编写过的代码 方便的被 复用！ 6.2 模块名也是一个标识符 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 注意：如果在给 Python 文件起名时，以数字开头 是无法在 PyCharm 中通过导入这个模块的 6.3 Pyc 文件（了解） C 是 compiled 编译过 的意思 操作步骤 浏览程序目录会发现一个 __pycache__ 的目录 目录下会有一个 hm_10_分隔线模块.cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码 Python 这样保存 字节码 是作为一种启动 速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译 生成一个二进制 字节码 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码 有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！ 模块是 Python 程序架构的一个核心概念 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/14_高级变量类型.html":{"url":"RD/python基础/14_高级变量类型.html","title":"14_高级变量类型","keywords":"","body":"高级变量类型 目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 01. 列表 1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 name_list = [\"zhangsan\", \"lisi\", \"wangwu\"] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： In [1]: name_list. name_list.append name_list.count name_list.insert name_list.reverse name_list.clear name_list.extend name_list.pop name_list.sort name_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 In [1]: import keyword In [2]: print(keyword.kwlist) In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 # for 循环内部使用的变量 in 列表 for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 02. 元组 2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 info_tuple = (\"zhangsan\", 18, 1.75) 创建空元组 info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号 info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 # for 循环内部使用的变量 in 元组 for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 info = (\"zhangsan\", 18) print(\"%s 的年龄是 %d\" % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 list(元组) 使用 tuple 函数可以把列表转换成元组 tuple(列表) 03. 字典 3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 xiaoming = {\"name\": \"小明\", \"age\": 18, \"gender\": True, \"height\": 1.75} 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： In [1]: xiaoming. xiaoming.clear xiaoming.items xiaoming.setdefault xiaoming.copy xiaoming.keys xiaoming.update xiaoming.fromkeys xiaoming.pop xiaoming.values xiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 # for 循环内部使用的 `key 的变量` in 字典 for k in xiaoming: print(\"%s: %s\" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 card_list = [{\"name\": \"张三\", \"qq\": \"12345\", \"phone\": \"110\"}, {\"name\": \"李四\", \"qq\": \"54321\", \"phone\": \"10086\"} ] 04. 字符串 4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 \" 或者 一对单引号 ' 定义一个字符串 虽然可以使用 \\\" 或者 \\' 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 \"，可以使用 ' 定义字符串 如果字符串内部需要使用 '，可以使用 \" 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 \" 来定义字符串 string = \"Hello Python\" for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = \"\" 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： In [1]: hello_str. hello_str.capitalize hello_str.isidentifier hello_str.rindex hello_str.casefold hello_str.islower hello_str.rjust hello_str.center hello_str.isnumeric hello_str.rpartition hello_str.count hello_str.isprintable hello_str.rsplit hello_str.encode hello_str.isspace hello_str.rstrip hello_str.endswith hello_str.istitle hello_str.split hello_str.expandtabs hello_str.isupper hello_str.splitlines hello_str.find hello_str.join hello_str.startswith hello_str.format hello_str.ljust hello_str.strip hello_str.format_map hello_str.lower hello_str.swapcase hello_str.index hello_str.lstrip hello_str.title hello_str.isalnum hello_str.maketrans hello_str.translate hello_str.isalpha hello_str.partition hello_str.upper hello_str.isdecimal hello_str.replace hello_str.zfill hello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=\"\", num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\\r', '\\t', '\\n' 和空格 string.splitlines() 按照行('\\r', '\\n', '\\r\\n')分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 4.3 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) => 开始索引 >= 范围 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 num_str = \"0123456789\" # 1. 截取从 2 ~ 5 位置 的字符串 print(num_str[2:6]) # 2. 截取从 2 ~ `末尾` 的字符串 print(num_str[2:]) # 3. 截取从 `开始` ~ 5 位置 的字符串 print(num_str[:6]) # 4. 截取完整的字符串 print(num_str[:]) # 5. 从开始位置，每隔一个字符截取字符串 print(num_str[::2]) # 6. 从索引 1 开始，每隔一个取一个 print(num_str[1::2]) # 倒序切片 # -1 表示倒数第一个字符 print(num_str[-1]) # 7. 截取从 2 ~ `末尾 - 1` 的字符串 print(num_str[2:-1]) # 8. 截取字符串末尾两个字符 print(num_str[-2:]) # 9. 字符串的逆序（面试题） print(num_str[::-1]) 05. 公共方法 5.1 Python 内置函数 Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： \"0\" 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 \"0123456789\"[::-2] \"97531\" 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [\"Hi!\"] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 > >= == (1, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符 成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： for 变量 in 集合: 循环体代码 else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 students = [ {\"name\": \"阿土\", \"age\": 20, \"gender\": True, \"height\": 1.7, \"weight\": 75.0}, {\"name\": \"小美\", \"age\": 19, \"gender\": False, \"height\": 1.6, \"weight\": 45.0}, ] find_name = \"阿土\" for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[\"name\"] == find_name: print(\"找到了\") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 break else: print(\"没有找到\") print(\"循环结束\") Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/16_变量进阶（理解）.html":{"url":"RD/python基础/16_变量进阶（理解）.html","title":"16_变量进阶（理解）","keywords":"","body":"变量进阶（理解） 目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念 在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例 在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递 在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 def test(num): print(\"-\" * 50) print(\"%d 在函数内的内存地址是 %x\" % (num, id(num))) result = 100 print(\"返回值 %d 在内存中的地址是 %x\" % (result, id(result))) print(\"-\" * 50) return result a = 10 print(\"调用函数前 内存地址是 %x\" % id(a)) r = test(a) print(\"调用函数后 实参内存地址是 %x\" % id(a)) print(\"调用函数后 返回值内存地址是 %x\" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict a = 1 a = \"hello\" a = [1, 2, 3] a = [3, 2, 1] demo_list = [1, 2, 3] print(\"定义列表后的内存地址 %d\" % id(demo_list)) demo_list.append(999) demo_list.pop(0) demo_list.remove(2) demo_list[0] = 10 print(\"修改数据后的内存地址 %d\" % id(demo_list)) demo_dict = {\"name\": \"小明\"} print(\"定义字典后的内存地址 %d\" % id(demo_dict)) demo_dict[\"age\"] = 18 demo_dict.pop(\"name\") demo_dict[\"name\"] = \"老王\" print(\"修改数据后的内存地址 %d\" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 def demo1(): num = 10 print(num) num = 20 print(\"修改后 %d\" % num) def demo2(): num = 100 print(num) demo1() demo2() print(\"over\") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 # 定义一个全局变量 num = 10 def demo1(): print(num) def demo2(): print(num) demo1() demo2() print(\"over\") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 a = 10 def demo(): print(\"%d\" % a) print(\"%d\" % b) print(\"%d\" % c) b = 20 demo() c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/python基础/17_函数进阶.html":{"url":"RD/python基础/17_函数进阶.html","title":"17_函数进阶","keywords":"","body":"函数进阶 目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用 函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值 此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值 此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值 此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值 此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 print(\"测量结束...\") return temp result = measure() print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 wetness = 10 print(\"测量结束...\") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 result = temp, wetness = measure() 面试题 —— 交换两个数字 题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量 # 解法 1 - 使用临时变量 c = b b = a a = c 解法 2 —— 不使用临时变量 # 解法 2 - 不使用临时变量 a = a + b b = a - b a = a - b 解法 3 —— Python 专有，利用元组 a, b = b, a 03. 函数的参数 进阶 3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 def demo(num, num_list): print(\"函数内部\") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(\"函数代码完成\") gl_num = 99 gl_list = [4, 5, 6] demo(gl_num, gl_list) print(gl_num) print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list) gl_list = [6, 7, 8] mutable(gl_list) print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 def demo(num, num_list): print(\"函数内部代码\") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(\"函数代码完成\") gl_num = 9 gl_list = [1, 2, 3] demo(gl_num, gl_list) print(gl_num) print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 gl_num_list = [6, 3, 9] # 默认就是升序排序，因为这种应用需求更多 gl_num_list.sort() print(gl_num_list) # 只有当需要降序排序时，才需要传递 `reverse` 参数 gl_num_list.sort(reverse=True) print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 def print_info(name, gender=True): gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s 是 %s\" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项 1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ def print_info(name, title=\"\", gender=True): \"\"\" :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 \"\"\" gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s%s 是 %s\" % (title, name, gender_text)) # 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！ print_info(\"小明\") print_info(\"老王\", title=\"班长\") print_info(\"小美\", gender=False) 3.3 多值参数（知道） 定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 def demo(num, *args, **kwargs): print(num) print(args) print(kwargs) demo(1, 2, 3, 4, 5, name=\"小明\", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和 需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return num print(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * def demo(*args, **kwargs): print(args) print(kwargs) # 需要将一个元组变量/字典变量传递给函数对应的参数 gl_nums = (1, 2, 3) gl_xiaoming = {\"name\": \"小明\", \"age\": 18} # 会把 num_tuple 和 xiaoming 作为元组传递个 args # demo(gl_nums, gl_xiaoming) demo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点 特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加 需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + ... num 的结果 def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + temp print(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-02 21:34:42 "},"RD/从零学Python/":{"url":"RD/从零学Python/","title":"从零学Python","keywords":"","body":"从零学Python 这可能是东半球最好的妹子图小程序，点她、点她、点她！！！ 这可能是世界上最好的 图床 ：https://www.cloudbed.vip 在线百度语音播报：https://gitee.com/52itstyle/baidu-speech 演示地址：https://speech.52itstyle.vip Activiti 工作流 BPMN 在线作图项目：https://gitee.com/52itstyle/BPMN 演示地址：https://bpmn.52itstyle.vip 一款爬虫博客： https://blog.52itstyle.top/ https://blog.52itstyle.top/index 项目介绍 从零学Python，各种开发案例，不定期更新。 软件 版本 功能 地址 Python 3.7.1 脚本语言 https://www.python.org/ Django 2.1.3 Web框架 https://www.djangoproject.com/ PyCharm 2018.2.4 可视化开发工具 http://www.jetbrains.com/pycharm/ 环境搭建说明： http://www.runoob.com/python3/python3-install.html 软件配置 PyCharm 新增一个 Python 项目，File->Settings->project interperter 配置 pip 源 为 # 总之快，很快，非常快 https://pypi.tuna.tsinghua.edu.cn/simple/ 最佳字体： Git v2.20.1 (2019-01-01) 64-bit Git for Windows Setup : https://npm.taobao.org/mirrors/git-for-windows/v2.20.1.windows.1/Git-2.20.1-64-bit.exe 64-bit Git for Windows Portable : https://npm.taobao.org/mirrors/git-for-windows/v2.20.1.windows.1/PortableGit-2.20.1-64-bit.7z.exe 案例 不定期更新 Day01 爬取套图: https://gitee.com/52itstyle/Python/blob/master/Day01/ Day02 操作数据库: https://gitee.com/52itstyle/Python/blob/master/Day02/ Day03 爬取小说: https://gitee.com/52itstyle/Python/blob/master/Day03/ Day04 爬取小说存入数据库: https://gitee.com/52itstyle/Python/blob/master/Day04/ Day05 问题总结：https://gitee.com/52itstyle/Python/blob/master/Day05/ Day06 小说网站雏形: https://gitee.com/52itstyle/Python/blob/master/Day06/ Day07 日志框架: https://gitee.com/52itstyle/Python/blob/master/Day07/ Day08 微信监控: https://gitee.com/52itstyle/Python/blob/master/Day08/ Day09 人脸识别: https://gitee.com/52itstyle/Python/blob/master/Day09/ Day10 Django后台: https://gitee.com/52itstyle/Python/blob/master/Day10/ Day11 链家数据: https://gitee.com/52itstyle/Python/blob/master/Day11/ Day12 OpenCV识别答题卡: https://gitee.com/52itstyle/Python/blob/master/Day12/ Day13 生成识别二维码: https://gitee.com/52itstyle/Python/blob/master/Day13/ Day14 我爬了《流浪地球》十万个短评得出以下结论: https://gitee.com/52itstyle/Python/blob/master/Day14/ Day15 上传图片二维码并解析: https://gitee.com/52itstyle/Python/blob/master/Day15/ Day16 文字转音频播报: https://gitee.com/52itstyle/Python/blob/master/Day16/ Day17 在线百度语音: https://gitee.com/52itstyle/Python/blob/master/Day17/ Day18 微信小黄鸡: https://gitee.com/52itstyle/Python/blob/master/Day18/ Day19 Activiti 工作流 BPMN 作图工具: https://gitee.com/52itstyle/Python/blob/master/Day19/ Day20 李沧二手房: https://gitee.com/52itstyle/Python/blob/master/Day20/ Day21 车牌号识别: https://gitee.com/52itstyle/Python/blob/master/Day21/ Day22 树莓派闹钟: https://gitee.com/52itstyle/Python/blob/master/Day22/ Day23 树莓派监控: https://gitee.com/52itstyle/Python/blob/master/Day23/ Day24 Selenium学习笔记: https://gitee.com/52itstyle/Python/blob/master/Day24/ Day25 爬取博客文章并入库: https://gitee.com/52itstyle/Python/blob/master/Day25/ Day27 生成微信头像全家福: https://gitee.com/52itstyle/Python/blob/master/Day27/ 淘宝镜像 https://npm.taobao.org/ 参考学习 https://www.python.org/ https://docs.djangoproject.com/ http://www.jetbrains.com/pycharm/ http://www.runoob.com/python3/python3-tutorial.html 墙裂推荐，一个能够让程序猿快速开发的极简工具箱：https://gitee.com/52itstyle/spring-boot-tools Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RD/从零学Python/Day01/Linux下安装Python3.html":{"url":"RD/从零学Python/Day01/Linux下安装Python3.html","title":"Linux下安装Python3","keywords":"","body":"前言 Linux下大部分系统默认自带python2.x的版本，最常见的是python2.6或python2.7版本，默认的python被系统很多程序所依赖，比如centos下的yum就是python2写的，所以默认版本不要轻易删除，否则会有一些问题，如果需要使用最新的Python3那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，python3和python2两个环境并存即可 安装 # 下载最新版本 wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tar.xz 事先安装依赖，否则后期安装会报错： yum -y install zlib* yum install libffi-devel -y 下面开始正式安装： # 解压 tar -xvf Python-3.7.1.tar.xz # 切换大目录 cd Python-3.7.1 # 配置编译 ./configure # 编译安装 make && make install 安装成功后python2 和 python3 可以同时使用： [root@AY140216131049Z mzitu]# python2 -V Python 2.7.5 [root@AY140216131049Z mzitu]# python3 -V Python 3.7.1 # 默认版本 [root@AY140216131049Z mzitu]# python -V Python 2.7.5 # 临时切换版本 [root@AY140216131049Z mzitu]# alias python='/usr/local/bin/python3.7' [root@AY140216131049Z mzitu]# python -V Python 3.7.1 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day01/PyCharm小技巧.html":{"url":"RD/从零学Python/Day01/PyCharm小技巧.html","title":"PyCharm小技巧","keywords":"","body":"1）PyCharm引入自定义类报错 解决方案：右击pycharm中项目名-->Mark Directory as -->Resource root Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day01/PyCharm常用快捷键和设置.html":{"url":"RD/从零学Python/Day01/PyCharm常用快捷键和设置.html","title":"PyCharm常用快捷键和设置","keywords":"","body":"1、编辑（Editing） Ctrl + Space 基本的代码完成（类、方法、属性） Ctrl + Alt + Space 快速导入任意类 Ctrl + Shift + Enter 语句完成 Ctrl + P 参数信息（在方法中调用参数） Ctrl + Q 快速查看文档 F1 外部文档 Shift + F1 外部文档，进入web文档主页 Ctrl + Shift + Z --> Redo 重做 Ctrl + 鼠标 简介/进入代码定义 Ctrl + F1 显示错误描述或警告信息 Alt + Insert 自动生成代码 Ctrl + O 重新方法 Ctrl + Alt + T 选中 Ctrl + / 行注释/取消行注释 Ctrl + Shift + / 块注释 Ctrl + W 选中增加的代码块 Ctrl + Shift + W 回到之前状态 Ctrl + Shift + ]/[ 选定代码块结束、开始 Alt + Enter 快速修正 Ctrl + Alt + L 代码格式化 Ctrl + Alt + O 优化导入 Ctrl + Alt + I 自动缩进 Tab / Shift + Tab 缩进、不缩进当前行 Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板 Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板 Ctrl+V/Shift+Insert 从剪贴板粘贴 Ctrl + Shift + V 从最近的缓冲区粘贴 Ctrl + D 复制选定的区域或行 Ctrl + Y 删除选定的行 Ctrl + Shift + J 添加智能线 Ctrl + Enter 智能线切割 Shift + Enter 另起一行 Ctrl + Shift + U 在选定的区域或代码块间切换 Ctrl + Delete 删除到字符结束 Ctrl + Backspace 删除到字符开始 Ctrl + Numpad+/- 展开/折叠代码块（当前位置的：函数，注释等） Ctrl + shift + Numpad+/- 展开/折叠所有代码块 Ctrl + F4 关闭运行的选项卡 2、查找/替换(Search/Replace) F3 下一个 Shift + F3 前一个 Ctrl + R 替换 Ctrl + Shift + F 或者连续2次敲击shift 全局查找{可以在整个项目中查找某个字符串什么的，如查找某个函数名字符串看之前是怎么使用这个函数的} Ctrl + Shift + R 全局替换 3、运行(Running) Alt + Shift + F10 运行模式配置 Alt + Shift + F9 调试模式配置 Shift + F10 运行 Shift + F9 调试 Ctrl + Shift + F10 运行编辑器配置 Ctrl + Alt + R 运行manage.py任务 4、调试(Debugging) F8 跳过 F7 进入 Shift + F8 退出 Alt + F9 运行游标 Alt + F8 验证表达式 Ctrl + Alt + F8 快速验证表达式 F9 恢复程序 Ctrl + F8 断点开关 Ctrl + Shift + F8 查看断点 5、导航(Navigation) Ctrl + N 跳转到类 Ctrl + Shift + N 跳转到符号 Alt + Right/Left 跳转到下一个、前一个编辑的选项卡 F12 回到先前的工具窗口 Esc 从工具窗口回到编辑窗口 Shift + Esc 隐藏运行的、最近运行的窗口 Ctrl + Shift + F4 关闭主动运行的选项卡 Ctrl + G 查看当前行号、字符号 Ctrl + E 当前文件弹出，打开最近使用的文件列表 Ctrl+Alt+Left/Right 后退、前进 Ctrl+Shift+Backspace 导航到最近编辑区域 Alt + F1 查找当前文件或标识 Ctrl+B / Ctrl+Click 跳转到声明 Ctrl + Alt + B 跳转到实现 Ctrl + Shift + I查看快速定义 Ctrl + Shift + B跳转到类型声明 Ctrl + U跳转到父方法、父类 Alt + Up/Down跳转到上一个、下一个方法 Ctrl + ]/[跳转到代码块结束、开始 Ctrl + F12弹出文件结构 Ctrl + H类型层次结构 Ctrl + Shift + H方法层次结构 Ctrl + Alt + H调用层次结构 F2 / Shift + F2下一条、前一条高亮的错误 F4 / Ctrl + Enter编辑资源、查看资源 Alt + Home显示导航条F11书签开关 Ctrl + Shift + F11书签助记开关 Ctrl + #[0-9]跳转到标识的书签 Shift + F11显示书签 6、搜索相关(Usage Search) Alt + F7/Ctrl + F7文件中查询用法 Ctrl + Shift + F7文件中用法高亮显示 Ctrl + Alt + F7显示用法 7、重构(Refactoring) F5复制F6剪切 Alt + Delete安全删除 Shift + F6重命名 Ctrl + F6更改签名 Ctrl + Alt + N内联 Ctrl + Alt + M提取方法 Ctrl + Alt + V提取属性 Ctrl + Alt + F提取字段 Ctrl + Alt + C提取常量 Ctrl + Alt + P提取参数 8、控制VCS/Local History Ctrl + K提交项目 Ctrl + T更新项目 Alt + Shift + C查看最近的变化 Alt + BackQuote(’)VCS快速弹出 9、模版(Live Templates) Ctrl + Alt + J当前行使用模版 Ctrl +Ｊ插入模版 10、基本(General) Alt + #[0-9]打开相应的工具窗口 Ctrl + Alt + Y同步 Ctrl + Shift + F12最大化编辑开关 Alt + Shift + F添加到最喜欢 Alt + Shift + I根据配置检查当前文件 Ctrl + BackQuote(’)快速切换当前计划 Ctrl + Alt + S　打开设置页 Ctrl + Shift + A查找编辑器里所有的动作 Ctrl + Tab在窗口间进行切换 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day01/弱类型、强类型、动态类型、静态类型语言的区别是什么.html":{"url":"RD/从零学Python/Day01/弱类型、强类型、动态类型、静态类型语言的区别是什么.html","title":"弱类型、强类型、动态类型、静态类型语言的区别是什么","keywords":"","body":"类型系统的一些概念，众说纷纭，使用上也比较乱。有些东西，甚至不好严格定义。以下算学术界的一种相对“严格”的说法。 1. 先定义一些基础概念 Program Error strapped errors。导致程序终止执行，如除0，Java中数组越界访问 untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址 Forbidden Behaviours 语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors. Well behaved、ill behavedwell behaved: 如果程序执行不可能出现forbidden behaviors, 则为well behaved。 ill behaved: 否则为ill behaved... 2. 有了上面的概念，再讨论强、弱类型，静态、动态类型 强、弱类型 强类型strongly typed: 如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。 弱类型weakly typed: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型 前面的人也说了，弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。 这样的结果是：容易产生forbidden behaviours，所以是弱类型的 动态、静态类型静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed;动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。 3. 误区 大家觉得C语言要写int a, int b之类的，Python不用写(可以直接写a, b)，所以C是静态，Python是动态。这么理解是不够准确的。譬如Ocaml是静态类型的，但是也可以不用明确地写出来。。Ocaml是静态隐式类型 静态类型可以分为两种：如果类型是语言语法的一部分，在是explicitly typed显式类型； 如果类型通过编译时推导，是implicity typed隐式类型, 比如ML和Haskell 4.下面是些例子 无类型： 汇编 弱类型、静态类型 ： C/C++ 弱类型、动态类型检查： Perl/PHP 强类型、静态类型检查 ：Java/C# 强类型、动态类型检查 ：Python, Scheme 静态显式类型 ：Java/C 静态隐式类型 ：Ocaml, Haskell 来源：https://www.zhihu.com/question/19918532 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day01/爬取套图之新手攻略以及注意事项.html":{"url":"RD/从零学Python/Day01/爬取套图之新手攻略以及注意事项.html","title":"爬取套图之新手攻略以及注意事项","keywords":"","body":"进军指南 如果是没有任何语言开发经验的同学，建议从头系统的学起，无论是书、视频还是文字教程都可以。 如果是有其他语言开发经验的同学，建议从一个案例入手，比如爬取某个网站的套图。 因为语言都是想通的，语法之类的只要你要语感，代码基本能读个八九不离十。 所以不建议有经验的开发者从头学起，无论是视频还是书，对于开始学一门语言来说都是太浪费时间了。 当然，等你深入进去以后，还是要系统的去学习，这是后话。 软件工具 Python3 这里选择的是最新版 Python 3.7.1 安装教程这里推荐：http://www.runoob.com/python3/python3-install.html win下载地址：https://www.python.org/downloads/windows Linux下载地址：https://www.python.org/downloads/source PyCharm 可视化开发工具：http://www.jetbrains.com/pycharm 这里说一句题外话，如果你在10-20分钟还没有把运行环境，集成开发环境配置并搭建好，我建议你还是放弃开发吧，祖国可能有更合适的岗位给你留着。 案例 实现步骤 以妹子图为例，其实很简单，分以下四步： 获取首页的页码数，并创建与页码对应的文件夹 获取页面的栏目地址 进入栏目，获取栏目页码数(每个栏目下有多张图片，分页显示) 获取到栏目下对用标签容器中的图片并下载 注意事项 这里以爬取某个网站的套路为例，详细见代码，这里主要说以下几点注意事项： 1）导库，其实就类似于Java中框架或者是工具类，底层都被封装好了 安装第三方库： # Win下直接装的 python3 pip install bs4、pip install requests # Linux python2 python3 共存 pip3 install bs4、pip3 install requests 导入第三方库： # 导入requests库 import requests # 导入文件操作库 import os # bs4全名BeautifulSoup，是编写python爬虫常用库之一，主要用来解析html标签。 import bs4 from bs4 import BeautifulSoup # 基础类库 import sys # Python 3.x 解决中文编码问题 import importlib importlib.reload(sys) 2）定义方法函数，一个爬虫可能会几百行，所以尽量不要写成一坨 def download(page_no, file_path): # 这里写代码逻辑 3）定义全局变量 # 给请求指定一个请求头来模拟chrome浏览器 global headers # 告诉编译器这是全局变量 headers headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'} # 函数内使用之前需要 # 告诉编译器我在这个方法中使用的a是刚才定义的全局变量 headers ，而不是方法内部的局部变量。 global headers 4）防盗链 有些网站加入了防盗链，无所不能的 python 解决方案： headers = {'Referer': href} img = requests.get(url, headers=headers) 5）切换版本 Linux服务器使用的是阿里云服务器（centos7.4），默认版本 python2，python3 自行安装 [root@AY140216131049Z mzitu]# python2 -V Python 2.7.5 [root@AY140216131049Z mzitu]# python3 -V Python 3.7.1 # 默认版本 [root@AY140216131049Z mzitu]# python -V Python 2.7.5 # 临时切换版本 [root@AY140216131049Z mzitu]# alias python='/usr/local/bin/python3.7' [root@AY140216131049Z mzitu]# python -V Python 3.7.1 6）异常捕获 在爬取的过程中可能存在异常页面，这里我们进行捕获，不影响后续操作： try: # 业务逻辑 except Exception as e: print(e) 执行脚本 python3 mzitu.py # 或者后台执行 nohup python3 -u mzitu.py > mzitu.log 2>&1 & Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day02/Python实现mysql数据库连接池.html":{"url":"RD/从零学Python/Day02/Python实现mysql数据库连接池.html","title":"Python实现mysql数据库连接池","keywords":"","body":" python编程中可以使用MySQLdb进行数据库的连接及诸如查询/插入/更新等操作，但是每次连接mysql数据库请求时，都是独立的去请求访问，相当浪费资源， 而且访问数量达到一定数量时，对mysql的性能会产生较大的影响。 因此，实际使用中，通常会使用数据库的连接池技术，来访问数据库达到资源复用的目的。 安装数据库连接池模块DBUtils pip3 install DBUtils DBUtils是一套Python数据库连接池包，并允许对非线程安全的数据库接口进行线程安全包装。DBUtils来自Webware for Python。 DBUtils提供两种外部接口： PersistentDB ：提供线程专用的数据库连接，并自动管理连接。 PooledDB ：提供线程间可共享的数据库连接，并自动管理连接。 dbapi ：数据库接口 mincached ：启动时开启的空连接数量 maxcached ：连接池最大可用连接数量 maxshared ：连接池最大可共享连接数量 maxconnections ：最大允许连接数量 blocking ：达到最大数量时是否阻塞 maxusage ：单个连接最大复用次数 根据自己的需要合理配置上述的资源参数，以满足自己的实际需要。 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day02/Python操作数据库.html":{"url":"RD/从零学Python/Day02/Python操作数据库.html","title":"Python操作数据库","keywords":"","body":"简介 pymysql：纯Python实现的一个驱动。因为是纯Python编写的，因此执行效率不如MySQL-python。并且也因为是纯Python编写的，因此可以和Python代码无缝衔接。 MySQL Connector/Python：MySQL官方推出的使用纯Python连接MySQL的驱动。因为是纯Python开发的，效率不高。 MySQL-python：也就是MySQLdb。是对C语言操作MySQL数据库的一个简单封装。遵循了Python DB API v2。但是只支持Python2，目前还不支持Python3。 mysqlclient：是MySQL-python的另外一个分支。支持Python3并且修复了一些bug。 PyMySQL Python3 MySQL 数据库连接 - PyMySQL 驱动 PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 pip3 install PyMySQL 案例 这里以查询秒杀商品数据为例： #!/usr/bin/python3 import pymysql # 打开数据库连接 db = pymysql.connect(\"localhost\", \"root\", \"123456\", \"seckill\") # 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute(\"SELECT * FROM seckill\") # 使用 fetchall() 方法获取s所有数据. data = cursor.fetchall() print(data) # 关闭数据库连接 db.close() mysql-connector mysql-connector 是 MySQL 官方提供的驱动器。 我们可以使用 pip 命令来安装 mysql-connector： pip3 install mysql-connector 案例 这里以查询秒杀商品数据为例： #!/usr/bin/python3 import mysql.connector # 打开数据库连接 # db = pymysql.connect(\"localhost\", \"root\", \"123456\", \"seckill\") db = mysql.connector.connect( host=\"localhost\", user=\"root\", passwd=\"123456\", database=\"seckill\" ) # 使用 cursor() 方法创建一个游标对象 cursor cursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute(\"SELECT * FROM seckill\") # 使用 fetchall() 方法获取s所有数据. data = cursor.fetchall() print(data) # 关闭数据库连接 db.close() Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day03/python3codecs.open和open的区别.html":{"url":"RD/从零学Python/Day03/python3codecs.open和open的区别.html","title":"python3codecs.open和open的区别","keywords":"","body":"Python3直接用open。 Python2.x下用codecs.open，特别是有中文的情况，然后也可以避免踩到2.6下面io.open的坑。 如果希望代码同时兼容Python2和Python3，那么推荐用codecs.open。 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day03/爬取小说相关指南.html":{"url":"RD/从零学Python/Day03/爬取小说相关指南.html","title":"爬取小说相关指南","keywords":"","body":"爬取指南 目前最火的小说《星辰变》为例： 实现步骤 获取小说所有章节以及对应地址 遍历所有章节地址，获取其标题以及内容 最后，把内容写入文本 学习重点 写入文本方式一： import codecs # 传入参数为chapter，content；content为需要写入的内容，数据类型为字符串，chapter为写入文件，数据类型为字符串。 # 传入的chapter需如下定义：path= 'G:/星辰变/第五章 修炼功法秘藏.txt' # f = codecs.open(path, 'a', code)中，’a’表示追加写入txt，可以换成’w’，表示覆盖写入。 # code 表示编码 比如 'utf8'、'gbk'等。 def write_txt(chapter, content, code): f = codecs.open(path, 'a', code) f.write(str(content)) f.close() 写入文本方式二（比较常用）： import codecs def writetxt(chapter, content, code): with codecs.open(path, 'a', encoding=code)as f: f.write(content) return chapter+' is ok!' Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day04/爬取小说存入数据库.html":{"url":"RD/从零学Python/Day04/爬取小说存入数据库.html","title":"爬取小说存入数据库","keywords":"","body":"准备工作 安装： # 数据库驱动 pip install pymysql # 数据库连接池 pip install DBUtils 建表 CREATE TABLE `novel` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键', `title` varchar(100) NOT NULL COMMENT '标题', `content` text NOT NULL COMMENT '内容', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2353 DEFAULT CHARSET=utf8 脚本 # 写入数据库 def write_db(chapter, content): sql = \"INSERT INTO novel (title, content) VALUES(%(title)s, %(content)s);\" param = {\"title\": chapter, \"content\": content} mysql.insert(sql, param) Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day05/Django切换MySQL数据库.html":{"url":"RD/从零学Python/Day05/Django切换MySQL数据库.html","title":"Django切换MySQL数据库","keywords":"","body":"准备 软件 版本 Django 2.1.3 Python 3.7.1 默认使用的是sqlite3 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), } } 切换为MySql： # settings.py DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'book', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'POST': '3306', } } 实现步骤： 我们使用Django 来操作MySQL，实际上底层还是通过Python来操作的。因此我们想要用Django来操作MySQL，首先还是需要安装一个驱动程序。在Python3中，驱动程序有多种选择。比如有pymysql以及mysqlclient等。 常见的Mysql驱动介绍： MySQL-python：也就是MySQLdb。是对C语言操作MySQL数据库的一个简单封装。遵循了Python DB API v2。但是只支持Python2，目前还不支持Python3。 mysqlclient：是MySQL-python的另外一个分支。支持Python3并且修复了一些bug。 pymysql：纯Python实现的一个驱动。因为是纯Python编写的，因此执行效率不如MySQL-python。并且也因为是纯Python编写的，因此可以和Python代码无缝衔接。 MySQL Connector/Python：MySQL官方推出的使用纯Python连接MySQL的驱动。因为是纯Python开发的。效率不高。 mysqlclient安装 基于目前的环境以及版本来说，直接运行 pip install mysqlclient 是会报错的，具体错误，自己执行以下就知道了。 解决办法： 去 https://www.lfd.uci.edu/~gohlke/pythonlibs/#mysqlclient 下载指定文件，我用的是python3.7，win环境是64位，所以下载了mysqlclient-1.3.13-cp37-cp37m-win_amd64.whl。 然后执行： pip3 install mysqlclient-1.3.13-cp37-cp37m-win_amd64.whl 如果出现以下说明安装成功： Installing collected packages: mysqlclient Successfully installed mysqlclient-1.3.13 迁移数据库 Django中通过以下命令来迁移数据库，在每次创建Model时，执行该命令，在数据库中生成对应的表： python manage.py makemigrations python manage.py migrate Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day05/今天出现的一些小问题.html":{"url":"RD/从零学Python/Day05/今天出现的一些小问题.html","title":"今天出现的一些小问题","keywords":"","body":"中文编码问题 这样一段代码： import json dict = {'id': 1, 'title': b'\\xe7\\xac\\xac\\xe4\\xb8\\x80\\xe7\\xab\\xa0 \\xe7\\xa7\\xa6\\xe7\\xbe\\xbd'} dup = json.dumps(dict ,ensure_ascii=False) print(dup) Python2执行输出： {\"id\": 1, \"title\": \"第一章 秦羽\"} Python3执行报错： TypeError: Object of type bytes is not JSON serializable 终稿： 安装模块： pip3 install numpy 最终代码： import json import numpy as np class MyEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, np.ndarray): return obj.tolist() elif isinstance(obj, bytes): return str(obj, encoding='utf-8'); return json.JSONEncoder.default(self, obj) dict = {'id': 1, 'title': b'\\xe7\\xac\\xac\\xe4\\xb8\\x80\\xe7\\xab\\xa0 \\xe7\\xa7\\xa6\\xe7\\xbe\\xbd'} dup = json.dumps(dict , cls=MyEncoder, ensure_ascii=False, indent=4) print(dup) 之前的单个转码： sql = \"SELECT id,title FROM novel LIMIT 10;\" result = mysql.getAll(sql) for each in result: ach['title'] = each['title'].decode('utf-8') 参考：https://blog.csdn.net/bear_sun/article/details/79397155 Web输出 JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数： json.dumps(): 对数据进行编码。 json.loads(): 对数据进行解码。 # 字典类型中有中文编码 dict= {'id': 1, 'title': b'\\xe7\\xac\\xac\\xe4\\xb8\\x80\\xe7\\xab\\xa0 \\xe7\\xa7\\xa6\\xe7\\xbe\\xbd'} # 转Json对象 dict= json.dumps(dict, cls=MyEncoder, ensure_ascii=False, indent=4) # 转字典类型 dict= json.loads(dict) context = {} context.update({'novel_list': result}) # 或者直接 context = {'novel_list': result} return render(request, 'novel_list.html', context) Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day05/关于json.dumps中的参数详解.html":{"url":"RD/从零学Python/Day05/关于json.dumps中的参数详解.html","title":"关于json.dumps中的参数详解","keywords":"","body":"例子如下： import json import numpy as np class MyEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, np.ndarray): return obj.tolist() elif isinstance(obj, bytes): return str(obj, encoding='utf-8'); return json.JSONEncoder.default(self, obj) dict = {'id': 1, 'title': b'\\xe7\\xac\\xac\\xe4\\xb8\\x80\\xe7\\xab\\xa0 \\xe7\\xa7\\xa6\\xe7\\xbe\\xbd'} dup = json.dumps(dict, cls=MyEncoder, ensure_ascii=False, indent=4) print(dup) indent 根据数据格式缩进显示，读起来更加清晰，indent的数值，代表缩进的位数。 ensure_ascii 如果无任何配置，或者说使用默认配置， 输出的会是中文的ASCII字符吗，而不是真正的中文。 这是因为json.dumps 序列化时对中文默认使用的ascii编码。 { \"id\": 1, \"title\": \"\\u7b2c\\u4e00\\u7ae0 \\u79e6\\u7fbd\" } cls dict类型的数据(存在中文)，在python2中是可以转化的，但是在python3中存在序列化问题： TypeError: Object of type bytes is not JSON serializable Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day06/Python3开发一个web项目.html":{"url":"RD/从零学Python/Day06/Python3开发一个web项目.html","title":"Python3开发一个web项目","keywords":"","body":"准备工作 # 安装 Web 框架 pip install Django # 创建一个项目 python django-admin.py startproject itstyle # 切换目录 cd itstyle # 创建 App python manage.py startapp novel 一般一个项目有多个app, 当然通用的app也可以在多个项目中使用，然后启动服务： # 默认端口是8000 python manage.py runserver 如果提示端口被占用，可以用其它端口： python manage.py runserver 8001 python manage.py runserver 8002 项目结构 win下使用命令 tree /F > 项目结构图.txt ，如下： │ manage.py │ ├─novel │ │ settings.py # 基础配置 │ │ urls.py # URL映射 │ │ wsgi.py │ │ __init__.py │ │ │ ├─templates # 相关页面 │ novel.html # 章节 │ novel_list.html # 小说首页 │ ├─utils │ │ dbMysqlConfig.cnf # 数据库配置参数 │ │ encoder.py # 编码类 │ │ mysql_DBUtils.py # 数据库连接池 │ └─view │ index.py # 后台业务 要点备注 RESTful 风格 控制器 from django.conf.urls import url from django.urls import path from view import index urlpatterns = [ # 首页 path('', index.main), # new # 章节页面 正则匹配 path('chapter//', index.chapter), # new ] 代码实现 # 此处 novel_id 对应 urls.py 中的 # 你可以访问：http://localhost:8000/chapter/1/ def chapter(request, novel_id): sql = \"SELECT title,content FROM novel where id = %(id)s;\" param = {\"id\": novel_id} result = mysql.getOne(sql, param) # 中文编码问题，由于查询出来的额中文是字节码，这里需要转换一下 result['title'] = result['title'].decode('utf-8') result['content'] = result['content'].decode('utf-8') context = {'novel': result} return render(request, 'novel.html', context) 列表展示 基于后端返回的数据，在前台进行展示，这里你可以把它想象成Java中的Struts2标签或者JSTL标签，当然也有点Vue的意思： {% for novel in novel_list %} {{ novel.title }} {% endfor %} Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day08/微信机器人预警通知.html":{"url":"RD/从零学Python/Day08/微信机器人预警通知.html","title":"微信机器人预警通知","keywords":"","body":"前言 目前公司生产环境日志系统使用ELK搭建，所有的消息都汇总到统一的日志平台，异常日志一开始都是通过邮件通知发送的，考虑到消息的及时性，后期我们增加了钉钉告警。 然而钉钉的打开率是极低的，即时有消息也懒得看一眼，特别是在周末。如果告警通知可以发送的微信上那岂不是美滋滋，娱乐通知两不误。其实企业微信公众平台是可以调用API实现报警功能的，但是对于个人开发用户来说是不现实的，总不能因为这个功能，注册个公司。 wechat_sender 很多牛逼的开发者，利用 web 版微信的协议封装成了工具类，可以通过个人微信实现登录，消息的接收和发送功能。wechat_sender 就是基于 wxpy 和 tornado 实现的一个可以将你的网站、爬虫、脚本等其他应用中各种消息 （日志、报警、运行结果等） 发给到微信的工具 安装 pip install wechat_sender 运行环境 Python 2.7 及以上 Python 3 及以上 使用 启动 wechat.py # coding: utf-8 from __future__ import unicode_literals from wxpy import * from wechat_sender import listen bot = Bot('bot.pkl') listen(bot) 发送 sender.py # coding: utf-8 from __future__ import unicode_literals from wxpy import * import sys # 日志告警这里有三个参数 %{type} %{path} %{message}，可根据自己的日志自行配置参数 if len(sys.argv) == 4: bot = Bot('bot.pkl') # 关闭群主确认，否则无法找到对应的群组 alarm_group = bot.groups().search('监控报警')[0] message = \"项目名：{type}, 日志路径 {path}，详细信息 {message}\".format(type=sys.argv[1], path=sys.argv[2], message=sys.argv[3]) alarm_group.send(message) 把发送脚本嵌入到相应的告警脚本中： sender.py 参数一 参数二 参数三 小结 总的来说还是很方便的，毕竟别人已经封装好了，这里登录的是 Web 网页端，并不影响 App 端的使用。 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day10/Python3+Django2配置后台管理.html":{"url":"RD/从零学Python/Day10/Python3+Django2配置后台管理.html","title":"Python3+Django2配置后台管理","keywords":"","body":"前言 使用 Django 我们只需要做一些配置，就可以实现简单的后台管理系统，下面我们以新闻系统为例子来搭建后台。 创建项目 切换到工作空间，执行以下命令： django-admin.py startproject itstyle # 进入 itstyle 文件夹 cd itstyle # 创建 news App manage.py startapp news 项目结构： │ manage.py ├─news │ │ admin.py │ │ apps.py │ │ models.py │ │ tests.py │ │ views.py │ │ __init__.py │ │ │ ├─migrations │ │ │ __init__.py │ │ │ └─itstyle │ settings.py │ urls.py │ wsgi.py │ __init__.py 配置后台 修改 news 文件夹中的 models.py # coding:utf-8 from django.db import models class News(models.Model): title = models.CharField(u'标题', max_length=256) content = models.TextField(u'内容') create_time = models.DateTimeField(u'发布时间', auto_now_add=True, editable = True) update_time = models.DateTimeField(u'更新时间',auto_now=True, null=True) 把 news 加入到settings.py中的INSTALLED_APPS中 INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'news', ) 把 settings.py中 DATABASES 修改数据源为MySql DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'itstyle', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'POST': '3306', } } 同步所有的数据表 # 进入包含有 manage.py 的文件夹 manage.py makemigrations manage.py migrate 创建管理员账号 manage.py createsuperuser 操作如下 E:\\python3\\Day10\\itstyle>manage.py createsuperuser Username (leave blank to use 'zzp'): admin Email address: 345849402@qq.com Password: Password (again): This password is too short. It must contain at least 8 characters. This password is too common. Bypass password validation and create user anyway? [y/N]: y Superuser created successfully. 修改 admin.py 进入 news 文件夹，修改 admin.py 文件 from django.contrib import admin from .models import News admin.site.register(News) 最后，启动服务 manage.py runserver 访问 http://localhost:8000/admin/ 输入设定的帐号和密码，我们添加两篇新闻。 小结 总的来说 Django 作为简单的后台CURD管理还是非常方便的，虽然界面简陋的一点，但是对于要求不高的站点还是挺不错的。 地址：https://blog.52itstyle.com/archives/3497/ Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day13/Python学习案例之二维码生成和识别.html":{"url":"RD/从零学Python/Day13/Python学习案例之二维码生成和识别.html","title":"Python学习案例之二维码生成和识别","keywords":"","body":"前言 在 JavaWeb 开发中，一般使用 Zxing 来生成和识别二维码，但是，Zxing 的识别有点差强人意，不少相对模糊的二维码识别率很低。不过就最新版本的测试来说，识别率有了现显著提高。 对比 在没接触 Python 之前，曾使用 Zbar 的客户端进行识别，测了大概几百张相对模糊的图片，Zbar的识别速度要快很多，识别率也比 Zxing 稍微准确那边一丢丢，但是，稍微模糊一点就无法识别。相比之下，微信和支付宝的识别效果就逆天了。 代码案例 # -*- coding:utf-8 -*- import os import qrcode import time from PIL import Image from pyzbar import pyzbar \"\"\" # 升级 pip 并安装第三方库 pip install -U pip pip install Pillow pip install pyzbar pip install qrcode \"\"\" def make_qr_code_easy(content, save_path=None): \"\"\" Generate QR Code by default :param content: The content encoded in QR Codeparams :param save_path: The path where the generated QR Code image will be saved in. If the path is not given the image will be opened by default. \"\"\" img = qrcode.make(data=content) if save_path: img.save(save_path) else: img.show() def make_qr_code(content, save_path=None): \"\"\" Generate QR Code by given params :param content: The content encoded in QR Code :param save_path: The path where the generated QR Code image will be saved in. If the path is not given the image will be opened by default. \"\"\" qr_code_maker = qrcode.QRCode(version=2, error_correction=qrcode.constants.ERROR_CORRECT_M, box_size=8, border=1, ) qr_code_maker.add_data(data=content) qr_code_maker.make(fit=True) img = qr_code_maker.make_image(fill_color=\"black\", back_color=\"white\") if save_path: img.save(save_path) else: img.show() def make_qr_code_with_icon(content, icon_path, save_path=None): \"\"\" Generate QR Code with an icon in the center :param content: The content encoded in QR Code :param icon_path: The path of icon image :param save_path: The path where the generated QR Code image will be saved in. If the path is not given the image will be opened by default. :exception FileExistsError: If the given icon_path is not exist. This error will be raised. :return: \"\"\" if not os.path.exists(icon_path): raise FileExistsError(icon_path) # First, generate an usual QR Code image qr_code_maker = qrcode.QRCode(version=4, error_correction=qrcode.constants.ERROR_CORRECT_H, box_size=8, border=1, ) qr_code_maker.add_data(data=content) qr_code_maker.make(fit=True) qr_code_img = qr_code_maker.make_image(fill_color=\"black\", back_color=\"white\").convert('RGBA') # Second, load icon image and resize it icon_img = Image.open(icon_path) code_width, code_height = qr_code_img.size icon_img = icon_img.resize((code_width // 4, code_height // 4), Image.ANTIALIAS) # Last, add the icon to original QR Code qr_code_img.paste(icon_img, (code_width * 3 // 8, code_width * 3 // 8)) if save_path: qr_code_img.save(save_path) else: qr_code_img.show() def decode_qr_code(code_img_path): \"\"\" Decode the given QR Code image, and return the content :param code_img_path: The path of QR Code image. :exception FileExistsError: If the given code_img_path is not exist. This error will be raised. :return: The list of decoded objects \"\"\" if not os.path.exists(code_img_path): raise FileExistsError(code_img_path) # Here, set only recognize QR Code and ignore other type of code return pyzbar.decode(Image.open(code_img_path), symbols=[pyzbar.ZBarSymbol.QRCODE], scan_locations=True) if __name__ == \"__main__\": # # 简易版 # make_qr_code_easy(\"make_qr_code_easy\", \"make_qr_code_easy.png\") # results = decode_qr_code(\"make_qr_code_easy.png\") # if len(results): # print(results[0].data.decode(\"utf-8\")) # else: # print(\"Can not recognize.\") # # # 参数版 # make_qr_code(\"make_qr_code\", \"make_qr_code.png\") # results = decode_qr_code(\"make_qr_code.png\") # if len(results): # print(results[0].data.decode(\"utf-8\")) # else: # print(\"Can not recognize.\") # # 带中间 logo 的 # make_qr_code_with_icon(\"https://blog.52itstyle.vip\", \"icon.jpg\", \"make_qr_code_with_icon.png\") # results = decode_qr_code(\"make_qr_code_with_icon.png\") # if len(results): # print(results[0].data.decode(\"utf-8\")) # else: # print(\"Can not recognize.\") # 识别答题卡二维码 16 识别失败 t1 = time.time() count = 0 for i in range(1, 33): results = decode_qr_code(os.getcwd()+\"\\\\img\\\\\"+str(i)+\".png\") if len(results): print(results[0].data.decode(\"utf-8\")) else: print(\"Can not recognize.\") count += 1 t2 = time.time() print(\"识别失败数量:\" + str(count)) print(\"测试时间:\" + str(int(round(t2 * 1000))-int(round(t1 * 1000)))) 测试了32张精挑细选模糊二维码： 识别失败数量:1 测试时间:130 使用最新版的 Zxing 识别失败了三张。 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day15/上传二维码并解析.html":{"url":"RD/从零学Python/Day15/上传二维码并解析.html","title":"上传二维码并解析","keywords":"","body":"Django上传二维码并解析 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day17/在线百度语音播报.html":{"url":"RD/从零学Python/Day17/在线百度语音播报.html","title":"在线百度语音播报","keywords":"","body":"安装说明：https://gitee.com/52itstyle/baidu-speech/blob/master/README.md 演示地址：https://speech.52itstyle.vip Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day19/":{"url":"RD/从零学Python/Day19/","title":"Day 19","keywords":"","body":"介绍 找一个好用的画图工具真心不容易，Activiti 工作流自带的 Web 版画图工具，外表挺华丽，其实使用起来各种拧巴；Eclipse 的 Activiti 画图插件，对于相对复杂的流程也是很不友好。 环境搭建 软件 版本 功能 地址 Python 3.7.1 脚本语言 https://www.python.org/ Django 2.1.3 Web框架 https://www.djangoproject.com/ PyCharm 2018.2.4 可视化开发工具 http://www.jetbrains.com/pycharm/ BPMN-JS 3.2.2 BPMN前端插件 https://github.com/bpmn-io/bpmn-js 项目截图 功能模块 这是一个Python版本，Java版本功能已经基本开发完毕，需要进行功能迁移。 用户登录 流程列表(CURD) 用户注册(待实现) 游客访问在线作图，可实现在线导入导出，本地缓存 演示 以下是基于 bpmn-js 开发的一个 Activiti 工作流作图管理系统，可以增删查改流程图，系统还在优化中。 游客访问：https://bpmn.52itstyle.vip/ Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:14 "},"RD/从零学Python/Day24/读我.html":{"url":"RD/从零学Python/Day24/读我.html","title":"读我","keywords":"","body":"安装 驱动： https://npm.taobao.org/mirrors/chromedriver/ 下载对应谷歌版本放置到 Python 安装目录 说明 find_element_by_xpath(\"//[@id=‘属性值’]\") find_element_by_xpath(\"//标签名[@id=‘属性值’]\"） find_element_by_xpath(\"//标签名[@name=‘属性值’]\"） find_element_by_xpath(\"//标签名[@class_name=‘属性值’]\"） Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RD/从零学Python/Day29/下小姐姐视频.html":{"url":"RD/从零学Python/Day29/下小姐姐视频.html","title":"下小姐姐视频","keywords":"","body":"You-Get 乃一小小哒命令行程序，提供便利的方式来下载网络上的媒体信息。 利用you-get下载这个网页的视频: 安装 pip3 install you-get pip3 install --upgrade you-get python -m pip install --upgrade pip 下载 you-get https://www.bilibili.com/video/av77151622/ 高级下载 you-get -i https://www.bilibili.com/video/av77151622/ 如果我们要下载高清的，可以追加以下参数： you-get --format=dash-flv720 https://www.bilibili.com/video/av77151622/ 更多中文说明 https://github.com/soimort/you-get/wiki Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RD/从零学Python/python基本语法.html":{"url":"RD/从零学Python/python基本语法.html","title":"python基本语法","keywords":"","body":"一张图认识Python（附基本语法总结） Python基础语法总结： 1.Python标识符 在 Python 里，标识符有字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入； 以双下划线开头的 foo 代表类的私有成员；以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 init__() 代表类的构造函数。 2.Python有五个标准的数据类型 Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） Python支持四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。 列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 加号 + 是列表连接运算符，星号 * 是重复操作。 元组是另一个数据类型，类似于List（列表）。 元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。 列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 3.Python数据类型转换 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 4.Python 运算符 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 python算术运算符 运算符 描述 实例 加 - 两个对象相加 a + b 输出结果 30 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 幂 - 返回x的y次幂 ab 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 ①：python比较运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. <> 不等于 - 比较两个对象是否不相等 (a <> b) 返回 true。这个运算符类似 != 。 大于 - 返回x是否大于y (a > b) 返回 False。 = b) 返回 False。 ②：Python赋值运算符 以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a = 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a = 幂赋值运算符 c = a 等效于 c = c * a //= 取整除赋值运算符 c //= a 等效于 c = c // a ③：Python位运算符 下表中变量 a 为 60，b 为 13，二进制格式如下： a = 0011 1100 b = 0000 1101 a&b = 0000 1100 a|b = 0011 1101 a^b = 0011 0001 ~a = 1100 0011 运算符 描述 实例 & 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a & b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a | b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 右移动运算符：把”>>”左边的运算数的各二进位全部右移若干位，”>>”右边的数指定移动的位数 a >> 2 输出结果 15 ，二进制解释： 0000 1111 ④：Python逻辑运算符 Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False ⑤：Python成员运算符 除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 ⑥：Python身份运算符 身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。注：is 与 == 区别： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 学习资料推荐>>> 基于Python的机器学习 Python高级安全编程 Python实战应用开发 Python 信息安全工具开发 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RD/从零学Python/python高级语法.html":{"url":"RD/从零学Python/python高级语法.html","title":"python高级语法","keywords":"","body":"高级语法 函数定义 def fun(): # statement... [return ] 定义模块 一个python文件就是一个模块 一个包含模块的文件夹也是一个模块 导入模块 import ${module_name} # module_name 就是模块文件的名称,不加后缀 .py from ${module_namespace} import ${module_name} #从模块空间导入某个模块 面向对象 创建类 使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾: class ClassName: '类的帮助信息' #类文档字符串 class_suite #类体 注意 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 例子: #!/usr/bin/python # -*- coding: UTF-8 -*- class Employee: '所有员工的基类' empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print \"Total Employee %d\" % Employee.empCount def displayEmployee(self): print \"Name : \", self.name, \", Salary: \", self.salary class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt() 以上实例执行结果为： main.Test 创建实例对象 实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。 以下使用类的名称 Employee 来实例化，并通过 init 方法接收参数。 \"创建 Employee 类的第一个对象\" emp1 = Employee(\"Zara\", 2000) \"创建 Employee 类的第二个对象\" emp2 = Employee(\"Manni\", 5000) 访问属性 您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量: emp1.displayEmployee() emp2.displayEmployee() print \"Total Employee %d\" % Employee.empCount Python内置类属性 dict : 类的属性（包含一个字典，由类的数据属性组成） doc :类的文档字符串 name: 类名 module: 类定义所在的模块（类的全名是'main.className'，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） bases : 类的所有父类构成元组（包含了一个由所有父类组成的元组） python对象销毁(垃圾回收) 语法 del instance Python 使用了引用计数这一简单技术来跟踪和回收垃圾。 在 Python 内部记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为一个引用计数器。 当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是\"立即\"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（及未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。 类的继承 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 继承语法 class 派生类名(基类名) ... 在python中继承中的一些特点： 1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。 2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数 3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 如果在继承元组中列了一个以上的类，那么它就被称作\"多重继承\" 。 语法： 派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示： class SubClassName (ParentClass1[, ParentClass2, ...]): ... 类属性与方法 类的私有属性 private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.private_attrs。 类的方法 在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数 类的私有方法 private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.private_methods 单下划线、双下划线、头尾双下划线说明： foo: 定义的是特殊方法，一般是系统定义名字 ，类似 init() 之类的。 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。 Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RD/从零学Python/常用python模块.html":{"url":"RD/从零学Python/常用python模块.html","title":"常用python模块","keywords":"","body":"常用模块说明 os 操作系统模块，文件路径操作等 sys 程序系统本身模块，获取参数，导入的模块，输入输出等 time timestamp时间戳，struct_time时间元组，format time 格式化时间模块 datetime模块 datatime模块重新封装了time模块，提供更多接口 hashlib加密 hashlib主要提供字符加密功能，将md5和sha模块整合到了一起，支持md5,sha1, sha224, sha256, sha384, sha512等算法 logging模块简介 logging模块是Python内置的标准模块，可以设置级别 subprocess模块 subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程 总结 那么我们到底该用哪个模块、哪个函数来执行命令与系统及系统进行交互呢？下面我们来做个总结： 首先应该知道的是，Python2.4版本引入了subprocess模块用来替换os.system()、os.popen()、os.spawn*()等函数以及commands模块；也就是说如果你使用的是Python 2.4及以上的版本就应该使用subprocess模块了。 如果你的应用使用的Python 2.4以上，但是是Python 3.5以下的版本，Python官方给出的建议是使用subprocess.call()函数。Python 2.5中新增了一个subprocess.check_call()函数，Python 2.7中新增了一个subprocess.check_output()函数，这两个函数也可以按照需求进行使用。 如果你的应用使用的是Python 3.5及以上的版本（目前应该还很少），Python官方给出的建议是尽量使用subprocess.run()函数。 当subprocess.call()、subprocess.check_call()、subprocess.check_output()和subprocess.run()这些高级函数无法满足需求时，我们可以使用subprocess.Popen类来实现我们需要的复杂功能。 json ,pickle模块 JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。JSON的数据格式其实就是python里面的字典格式，里面可以包含方括号括起来的数组，也就是python里面的列表。 在python中，有专门处理json格式的模块—— json 和 picle模块 Json 模块提供了四个方法： dumps、dump、loads、load pickle 模块也提供了四个功能：dumps、dump、loads、load 参考地址 常用模块和使用案例 https://www.cnblogs.com/wf-linux/archive/2018/08/01/9400354.html Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-05-05 08:52:16 "},"RHEL/firewalld配置.html":{"url":"RHEL/firewalld配置.html","title":"firewalld配置","keywords":"","body":"防火墙状态及规则 1、查看防火墙状态：firewall-cmd --state [root@localhost ~]# firewall-cmd --state running [root@localhost ~]# 2、查看防火墙：firewall-cmd --list-all [root@localhost ~]# firewall-cmd --list-all public (active) target: default icmp-block-inversion: no interfaces: eth0 sources: services: dhcpv6-client http ports: 999/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: rule family=\"ipv4\" source address=\"10.45.148.240\" accept rule family=\"ipv4\" source address=\"10.45.152.0/24\" accept rule family=\"ipv4\" source address=\"10.45.149.59\" accept rule family=\"ipv4\" source address=\"10.72.55.99\" accept rule family=\"ipv4\" source address=\"10.45.148.44\" accept rule family=\"ipv4\" source address=\"10.45.149.2\" accept rule family=\"ipv4\" source address=\"10.45.149.124\" accept rule family=\"ipv4\" source address=\"10.45.148.184\" accept rule family=\"ipv4\" source address=\"10.45.148.143\" accept rule family=\"ipv4\" source address=\"10.45.148.18\" accept rule family=\"ipv4\" source address=\"172.16.3.18\" accept rule family=\"ipv4\" source address=\"10.45.152.225\" accept rule family=\"ipv4\" source address=\"10.45.152.104\" accept rule family=\"ipv4\" source address=\"10.45.156.169\" accept rule family=\"ipv4\" source address=\"10.72.55.10\" accept rule family=\"ipv4\" source address=\"10.72.55.108\" accept rule family=\"ipv4\" source address=\"10.45.149.15\" accept rule family=\"ipv4\" source address=\"10.45.148.16\" accept rule family=\"ipv4\" source address=\"10.45.148.239\" accept rule family=\"ipv4\" source address=\"10.45.146.51\" accept rule family=\"ipv4\" source address=\"10.45.157.70\" accept rule family=\"ipv4\" source address=\"10.45.2.0/24\" accept rule family=\"ipv4\" source address=\"10.45.2.49\" accept rule family=\"ipv4\" source address=\"10.45.2.47\" accept rule family=\"ipv4\" source address=\"10.45.2.48\" accept rule family=\"ipv4\" source address=\"10.45.2.21\" accept rule family=\"ipv4\" source address=\"10.45.2.63\" accept rule family=\"ipv4\" source address=\"10.45.132.34\" accept rule family=\"ipv4\" source address=\"10.72.90.250\" accept [root@localhost ~]# 3、更新防火墙规则：firewall-cmd --reload [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# 端口 1、临时增加(reload之后消失)：不需要reload [root@localhost ~]# firewall-cmd --add-port=999/tcp success [root@localhost ~]# firewall-cmd --query-port=999/tcp yes [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-port=999/tcp no [root@localhost ~]# 2、永久增加：reload后生效 [root@localhost ~]# firewall-cmd --permanent --add-port=999/tcp success [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-port=999/tcp yes 3、临时删除端口：reload后消失 [root@localhost ~]# firewall-cmd --remove-port=999/tcp success [root@localhost ~]# firewall-cmd --query-port=999/tcp no [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-port=999/tcp yes [root@localhost ~]# 4、永久删除端口：reload后生效 [root@localhost ~]# firewall-cmd --permanent --remove-port=999/tcp success [root@localhost ~]# firewall-cmd --query-port=999/tcp yes [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-port=999/tcp no [root@localhost ~]# 5、查询端口 [root@localhost ~]# firewall-cmd --query-port=999/tcp yes [root@localhost ~]# 6、查看所有放行的端口： [root@localhost ~]# firewall-cmd --permanent --add-port=999/tcp success [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --list-ports 999/tcp [root@localhost ~]# IP 1、防火墙添加允许访问的IP 注：添加允许访问的IP后，需要reload才能生效 [root@localhost logs]# firewall-cmd --zone=public --add-rich-rule 'rule family=\"ipv4\" source address=\"10.45.2.35\" accept' --permanent success [root@localhost logs]# firewall-cmd --reload success 服务 1、防火墙服务的状态 [root@localhost ~]# systemctl status firewalld.service ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled) Active: active (running) since 五 2021-10-29 11:09:30 CST; 3 days ago Docs: man:firewalld(1) Main PID: 42215 (firewalld) CGroup: /system.slice/firewalld.service └─42215 /usr/bin/python -Es /usr/sbin/firewalld --nofork --nopid 10月 29 11:09:30 localhost.localdomain systemd[1]: Starting firewalld - dyna... 10月 29 11:09:30 localhost.localdomain systemd[1]: Started firewalld - dynam... 11月 02 10:22:44 localhost.localdomain firewalld[42215]: WARNING: ALREADY_EN... 11月 02 10:23:29 localhost.localdomain firewalld[42215]: WARNING: ALREADY_EN... Hint: Some lines were ellipsized, use -l to show in full. [root@localhost ~]# 2、启动/关闭防火墙 [root@localhost ~]# systemctl stop firewalld.service [root@localhost ~]# systemctl start firewalld.service 3、获取所有支持的服务 [root@localhost ~]# firewall-cmd --get-services RH-Satellite-6 amanda-client amanda-k5-client bacula bacula-client bgp bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc ceph ceph-mon cfengine condor-collector ctdb dhcp dhcpv6 dhcpv6-client dns docker-registry docker-swarm dropbox-lansync elasticsearch freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master git gre high-availability http https imap imaps ipp ipp-client ipsec irc ircs iscsi-target jenkins kadmin kerberos kibana klogin kpasswd kprop kshell ldap ldaps libvirt libvirt-tls managesieve mdns minidlna mongodb mosh mountd ms-wbt mssql murmur mysql nfs nfs3 nmea-0183 nrpe ntp openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy proxy-dhcp ptp pulseaudio puppetmaster quassel radius redis rpc-bind rsh rsyncd samba samba-client sane sip sips smtp smtp-submission smtps snmp snmptrap spideroak-lansync squid ssh syncthing syncthing-gui synergy syslog syslog-tls telnet tftp tftp-client tinc tor-socks transmission-client upnp-client vdsm vnc-server wbem-https xmpp-bosh xmpp-client xmpp-local xmpp-server zabbix-agent zabbix-server [root@localhost ~]# 4、增加服务（临时增加） [root@localhost ~]# firewall-cmd --add-service=https success [root@localhost ~]# firewall-cmd --query-service=https yes [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-service=https no [root@localhost ~]# 5、删除服务（临时删除） [root@localhost ~]# firewall-cmd --query-service=https yes [root@localhost ~]# firewall-cmd --remove-service=https success [root@localhost ~]# firewall-cmd --query-service=https no [root@localhost ~]# firewall-cmd --reload success [root@localhost ~]# firewall-cmd --query-service=https no [root@localhost ~]# 6、查询服务 [root@localhost ~]# firewall-cmd --query-service=https yes [root@localhost ~]# 7、增加服务（永久） [root@localhost bin]# firewall-cmd --permanent --add-service=http success [root@localhost bin]# firewall-cmd --reload success [root@localhost bin]# firewall-cmd --query-service=http yes 8、删除服务（永久） [root@localhost bin]# firewall-cmd --permanent --remove-service=ssh success [root@localhost bin]# firewall-cmd --reload success [root@localhost bin]# firewall-cmd --query-servicessh no Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-24 07:16:06 "},"Vim/vi编辑器.html":{"url":"Vim/vi编辑器.html","title":"vi编辑器","keywords":"","body":"vi —— 终端中的编辑器 目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介 1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vim vim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 # 查找 vi 的运行文件 $ which vi $ ls -l /usr/bin/vi $ ls -l /etc/alternatives/vi $ ls -l /usr/bin/vim.basic # 查找 vim 的运行文件 $ which vim $ ls -l /usr/bin/vim $ ls -l /etc/alternatives/vim $ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 $ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 $ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write & quit 保存并退出 x 保存并退出 04. 常用命令 命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序） 1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 'x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： * dw # 从光标位置删除到单词末尾 * d0 # 从光标位置删除到一行的起始位置 * d} # 从光标位置删除到段落结尾 * ndd # 从光标位置向下连续删除 n 行 * d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码 * d'a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 >> 向右增加缩进 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 > 或者 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找 常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： :%s///g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： :%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： :s/旧文本/新文本/g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ :%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展 末行命令 主要是针对文件进行操作的：保存、退出、保存&退出、搜索&替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write & quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 > 增加窗口宽度 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 /etc/vim/vimrc ~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！ Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-30 16:57:00 "},"zabbix/zabbix.html":{"url":"zabbix/zabbix.html","title":"Zabbix","keywords":"","body":"Zabbix 构建企业级监控告警平台 Zabbix 构建企业级监控告警平台 一. 简介 Zabbix 是一个基于 WEB 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。它能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。 二.监控对象 源代码: .html .jsp .php .py 数据库： MySQL,MariaDB,Oracle,SQL Server,DB2 应用软件：Nginx,Apache,PHP,Tomcat agent 集群： LVS,Keepalived,HAproxy,RHCS,F5 虚拟化层/云层： VMware,KVM,XEN agent 操作系统：Linux,Unix,Windows性能参数 硬件： 服务器，存储 IPMI 网络： 网络环境（路由器，交换机，防火墙，内网环境，外网环境） SNMP 三.监控收集信息方式 被动模式 主动模式 四.Zabbix 部署 zabbix-server(192.168.100.10) 1.官网：我是链接 2.环境 IP 主机名 角色 192.168.100.10 zabbix_server 监控服务器 192.168.100.20 web1 业务主机 3.Installing Zabbix packages ①.设置主机名 hostnamectl set-hostname zabbix_server ②.防火墙 systemctl stop firewalld.service systemctl disable firewalld.service ③.selinux setenforce 0 永久关闭 sed -ir '/^SELINUX/cSELINUX=disabled' /etc/selinux/config ④.准备Zabbix-repo rpm -Uvh https://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-2.el7.noarch.rpm rpm -Uvh https://repo.zabbix.com/zabbix/5.0/rhel/7/x86_64/zabbix-release-5.0-1.el7.noarch.rpm yum clean all 国外镜像特别慢，可以使用阿里提供的zabbixYUM源。在epel中就有40版本 ⑤.安装Zabbix服务器 yum -y install zabbix-server-mysql zabbix-web-mysql zabbix-agent zabbix-get.x86_64 zabbix-server-mysql：数据库 zabbix-web-mysql：WEB zabbi-agent：代理程序（上报信息的程序） 4. Creating initial database ①.安装数据库 yum -y install mariadb mariadb-server ②.启动数据库 systemctl enable mariadb systemctl start mariadb ③.授权zabbix账号 mysql create database zabbix character set utf8 collate utf8_bin; create user zabbix@localhost identified by '123456'; grant all privileges on zabbix.* to zabbix@localhost; flush privileges; 5.Starting Zabbix server process ①.配置sql账号密码 导入初始架构和数据，系统将提示您输入新创建的密码。 zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix vim /etc/zabbix/zabbix_server.conf DBPassword=zxc123 ②.启动zabbix systemctl restart zabbix-server zabbix-agent httpd systemctl enable zabbix-server zabbix-agent httpd ③.Editing PHP configuration for Zabbix frontend 默认值，只需要配置时区。 vim /etc/httpd/conf.d/zabbix.conf php_value date.timezone Asia/Shanghai systemctl restart httpd 安装后图形界面显示图形，文末有解决方案，php版本问题 升级php7.0即可，并重新安装zabbix-web [root@zabbix-server ~]# php -version PHP 7.0.33 (cli) (built: Dec 6 2018 22:30:44) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies with Zend OPcache v7.0.33, Copyright (c) 1999-2017, by Zend Technologies [root@zabbix-server ~]# rpm -qa zabbix-web zabbix-web-4.0.28-1.el7.noarch 欢迎页面 http://zabbix-server-ip/zabbix 登录 用户名： Admin 密码： zabbix 语言和乱码 administration>users>admin user 右上角用户图标，更换语言 设置中文后，查看图形有乱码，文字变成了方块 解决方案 Win+R打开运行，输入fonts，回车进入Windows字体目录，找到微软雅黑-常规字体右键复制，找个文件夹，点击粘贴，复制出来将文件名修改为msyh.ttf，注意后缀ttf 只需要改一个 C:\\Windows\\Fonts 将msyh.ttf上传到服务器zabbix字体目录中：/usr/share/zabbix/assets/fonts/ 注意文件权限 [root@zabbix_server fonts]# mv msyh.ttc msyh.ttf chmod 777 /usr/share/zabbix/assets/fonts/msyh.ttf 查看字体配置# grep FONT_NAME /usr/share/zabbix/include/defines.inc.php -n 执行快捷替换 sed -i \"s/graphfont/msyh/g\" /usr/share/zabbix/include/defines.inc.php 确认是否替换成功 grep FONT_NAME /usr/share/zabbix/include/defines.inc.php -n 45:define('ZBX_GRAPH_FONT_NAME', 'msyh'); // font file name 93:define('ZBX_FONT_NAME', 'msyh'); 字体配置修改成功后，刷新图形界面即可看到图形字体显示正常了。 zabbix-agent(192.168.100.20) 安装和配置 ①.设置主机名 hostnamectl set-hostname web1 ②.防火墙 systemctl stop firewalld.service systemctl disable firewalld.service ③.selinux setenforce 0 ④.准备zabbix-repo rpm -Uvh https://repo.zabbix.com/zabbix/4.0/rhel/7/x86_64/zabbix-release-4.0-2.el7.noarch.rpm #rpm -ivh http://repo.zabbix.com/zabbix/4.4/rhel/7/x86_64/zabbix-release-4.4-1.el7.noarch.rpm 使用epel源中的zabbix版本 ⑤.安装zabbix-agent yum -y install zabbix-agent ⑥.配置代理 vim /etc/zabbix/zabbix_agentd.conf 说明：192.168.100.10是zabbix服务器的地址 Server=192.168.100.10,192.168.100.11 被动模式 zabbix-server-ip ServerActive=192.168.100.10,192.168.100.11 主动模式 zabbix-server-ip （谁从我这里采集数据。） Hostname=web1 建议使用 $HOSTNAME ⑦.启动zabbix-agent：10050 systemctl start zabbix-agent systemctl enable zabbix-agent ss -anlp |grep :10050 服务器是10051 7.命令行测试 [root@zabbix_server fonts]# yum install zabbix-get [root@zabbix ~]# zabbix_get -s 10.11.67.137 -k system.uname Linux server 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 [root@zabbix ~]# zabbix_get -s 10.11.67.137 -k system.cpu.load[all,avg15] 0.050000 [root@zabbix ~]# zabbix_get -s 10.11.67.137 -k net.tcp.service[http] 1 # 0假 # 1真 Apache监控示例（图形监控） 创建主机组 （zabbix-server-192.168.100.10） 选择默认模板，模板就是zabbix推荐的监控参数。（这样可以缩小选择范围） 创建主机（zabbix-server-192.168.100.10） 选择群组 创建图形（zabbix-server-192.168.100.10） 模板Template 应用集（app）：对监控项的分类 监控项（item）：具体监控的项目 比例。。大小。。 图形：监控项产生的连续数据用图形表示 聚合图形：多个图形在一个页面显示 自动发现：自动发现主机并添加到组中 报错及解决： 安装zabbix4.0图形界面不显示图 解决： 大佬提示php版本问题，yum安装为5.4 ，升级为7的版本测试 1.执行下面的命令升级软件仓库 rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 2.删除PHP yum remove php-common 3.安装php 5.6版本（php56w-devel不是必需） yum install -y php56w php56w-opcache php56w-xml php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring 4.重启Apache 安装PHP7 yum install php70w-fpm php70w-mysql php70w-mysqli php70w php70w-opcache php70w-gd php70w-intl php70w-mbstring php70w-exif php70w-mcrypt php70w-openssl 安装zabbix 后进入graph界面 显示Fail 依据提示修改 vim /etc/php.ini date.timezone = Asia/Shanghai #重启php-fpm httpd systemctl restart php-fpm systemctl restart httpd Zabbix 构建企业级监控告警平台 2 Zabbix Items 监控项 获取监控数据方式 zabbix-agent SNMP 简单的网际发现协议 取值的数据类型、单位 监控key：是监控的内容 ， 获取数据的间隔：不能太小，1s 1m 历史数据保存的时间： 趋势数据保存时间： 新建item监控项 监控项：服务器启动分区剩余空间 1、新建模板 2、创建监控项 3、新建图形 添加模板到主机 然后在检测：最新数据：查看图形 监控项：服务器网络进出口流量 新建项 IN（新建项OUT，新建项all） 新建项mem 创建图形 模板关联主机 最新数据 创建聚合图形 监控项：监控ftp服务 自定义Key vim /etc/zabbix/zabbix_agentd.d/userparamenter_mysql.conf 以conf结尾即可 [root@zabbix_server ~]# vim /etc/zabbix/zabbix_agentd.d/userparamenter_mysql.conf UserParameter=mysql.questions.zhangshoulong,mysqladmin -uroot -p123456 status | awk '{print $6}' [root@zabbix_server ~]# zabbix_agentd -t mysql.questions.zhangshoulong mysql.questions.zhangshoulong [t|801689] Zabbix Triger 触发器 触发器用于定义item的报警阈值 触发器表达式 {:.()} server: 可以是host 也可以是template key: item 包括自定义的key 函数 常用模板 例子：CPU负载超过2 ``` ![image-20211111192234039](zabbix.assets/image-20211111192234039.png) ![image-20211111201253785](zabbix.assets/image-20211111201253785.png) ### Zabbix Action 动作 动作Action #### 简介 当某个触发器状态发生改变(如Problem、OK)，可以采取相应的动作，如： #### 邮件，短信，微信告警 ##### 告警实验简介 1. 创建告警media type（发送消息的方式，例如使用某个mail user连接某个邮件服务器 smtp.126.com love_cloud@126.com xxxx） 2. 创建用户或组（接收消息的用户例如email address, 注意权限） 3. 创建Action（使用之前定义好的media type 发送给之前定义好的用户或组） 邮件告警 准备告警信息 1.注册新邮箱 http://mail.126.com/或mail.qq.com 2.开启POP3的授权码 ![在这里插入图片描述](zabbix.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MzcxODEz,size_16,color_FFFFFF,t_70#pic_center-163663468125351.png) 3.zabbix设置邮箱 ##### zabbix服务器与邮箱服务器的连通性测试 nc smtp.126.com -t 25 连接成功 [root@zabbix ~]# nc smtp.126.com -t 25 220 126.com Anti-spam GT for Coremail System (126com[20140526]) ##### 设置zabbix链接126邮箱信息 ![image-20211112075406077](zabbix.assets/image-20211112075406077-163667484785953.png) ![image-20211112080619306](zabbix.assets/image-20211112080619306.png)4.创建 ###### 用户组 运维组 ![image-20211112081040025](zabbix.assets/image-20211112081040025.png)用户kk ![image-20211112081323188](zabbix.assets/image-20211112081323188.png) 密码自定义 ![image-20211112081431474](zabbix.assets/image-20211112081431474.png) 告警类型 ![image-20211112081525726](zabbix.assets/image-20211112081525726.png) 设置告警 ![image-20211112081716621](zabbix.assets/image-20211112081716621.png) 设置动作：触发器产生的告警 ![image-20211112082124999](zabbix.assets/image-20211112082124999.png)![image-20211112082343476](zabbix.assets/image-20211112082343476.png) 多个条件会有逻辑关系 ![image-20211112082514028](zabbix.assets/image-20211112082514028.png) ![image-20211112082950282](zabbix.assets/image-20211112082950282.png)设置一旦模板发生问题，每隔60秒就发送邮件给用户1 ![image-20211112083224765](zabbix.assets/image-20211112083224765.png) ![image-20211112092251314](zabbix.assets/image-20211112092251314.png) ![image-20211112092308452](zabbix.assets/image-20211112092308452.png) ```bash {TRIGGER.STATUS}: {TRIGGER.NAME} 告警主机:{HOST.NAME} 主机地址:{HOST.IP} 告警时间:{EVENT.DATE} {EVENT.TIME} 告警等级:{TRIGGER.SEVERITY} 告警信息:{TRIGGER.NAME} 问题详情:{ITEM.NAME}:{ITEM.VALUE} 事件代码:{EVENT.ID} 当事件升级，发送给更高级用户。 微信告警 获取企业ID： ww88cfc4e6401f9bb0 https://work.weixin.qq.com/wework_admin/loginpage_wx?from=myhome AgentID：1000003 Secret： FrmpVSXIt8kokhQJ9neNSQwti-ZeTcFhWqzifvBWvuA vim /usr/lib/zabbix/alertscripts/wechat.py chown zabbix:zabbix /usr/lib/zabbix/alertscripts/wechat.py #!/usr/bin/env python # -*- coding: utf-8 -*- import urllib,urllib2,json import sys reload(sys) sys.setdefaultencoding( \"utf-8\" ) class WeChat(object): __token_id = '' # init attribute def __init__(self,url): self.__url = url.rstrip('/') self.__corpid = 'ww88cfc4e6401f9bb0' self.__secret = 'FrmpVSXIt8kokhQJ9neNSQwti-ZeTcFhWqzifvBWvuA' # Get TokenID def authID(self): params = {'corpid':self.__corpid, 'corpsecret':self.__secret} data = urllib.urlencode(params) content = self.getToken(data) try: self.__token_id = content['access_token'] # print content['access_token'] except KeyError: raise KeyError # Establish a connection def getToken(self,data,url_prefix='/'): url = self.__url + url_prefix + 'gettoken?' try: response = urllib2.Request(url + data) except KeyError: raise KeyError result = urllib2.urlopen(response) content = json.loads(result.read()) return content # Get sendmessage url def postData(self,data,url_prefix='/'): url = self.__url + url_prefix + 'message/send?access_token=%s' % self.__token_id request = urllib2.Request(url,data) try: result = urllib2.urlopen(request) except urllib2.HTTPError as e: if hasattr(e,'reason'): print 'reason',e.reason elif hasattr(e,'code'): print 'code',e.code return 0 else: content = json.loads(result.read()) result.close() return content # send message def sendMessage(self,touser,message): self.authID() data = json.dumps({ \"touser\":\"user\", \"toparty\":\"3\", \"msgtype\":\"text\", \"agentid\":\"1000003\", \"text\":{ 'content':message }, \"safe\":\"0\" },ensure_ascii=False) response = self.postData(data) print response if __name__ == '__main__': a = WeChat('https://qyapi.weixin.qq.com/cgi-bin') a.sendMessage(sys.argv[1],sys.argv[3]) [root@zabbix_server alertscripts]# ./wechat.py Jocker test test {u'msgid': u'mrVtVXE39it1tWVvd57npNzElVA2MgYok9Pc-PiVh1kIAhi7-jUDlWEyhZ-7G_7CuSBmcdanBYORruEw_ycDdg', u'invaliduser': u'user', u'errcode': 0, u'errmsg': u'ok'} [用户] [title] [内容] {TRIGGER.STATUS}: {TRIGGER.NAME} 告警主机:{HOST.NAME} 主机地址:{HOST.IP} 告警时间:{EVENT.DATE} {EVENT.TIME} 告警等级:{TRIGGER.SEVERITY} 告警信息:{TRIGGER.NAME} 问题详情:{ITEM.NAME}:{ITEM.VALUE} 事件代码:{EVENT.ID} 远程执行 当问题发生时，可以通过远程执行命令的形式对目标主机进行控制 Zabbix Macros 内置宏 https://www.zabbix.com/documentation/5.0/zh/manual/config/notifications/action/operation/macros ## 主机相关 {HOSTNAME1} 告警主机 {HOST.IP} 主机IP {HOST.METADATA} 设备元数据（自动注册的时候会发这种宏的通知给你） ## 时间相关 {DATE} 当前时间 {EVENT.DATE} {EVENT.TIME} 告警时间 ## 触发器相关 {TRIGGER.SEVERITY} 触发器告警等级 {TRIGGER.NAME} 触发器名 {TRIGGER.KEY1} 触发器告警项目 {TRIGGER.STATUS} 触发器状态 ## 监控项相关 {ITEM.NAME}:{ITEM.VALUE} 监控项名 ## 动作（ Action）相关 {ACTION.ID} Action(动作)的数字标识 {ACTION.NAME} Action(动作)名 ## 自动发现相关 {DISCOVERY.DEVICE.IPADDRESS} 被发现的设备地址 {DISCOVERY.DEVICE.STATUS} 被发现设备的状态: 可能是Up 或 Down ## 事件（EVENT)相关 {EVENT.ACK.STATUS} 事件的确认状态 {EVENT.AGE} 触发动作的事件持续时间 {EVENT.ID} 触发动作的事件数字标识 {EVENT.STATUS} 触发动作的事件状态 Zabbix 自动发现 自动发现动作 发现的主机在哪 Zabbix自动注册 由客户端主动发起，客户端必须安装Agentd。否则无法被自动注册添加至主机列表 zabbix_agent 配置 vim /etc/zabbix/zabbix_agentd.conf ServerActive=192.168.0.110 主动模式 zabbix-server-ip systemctl restart zabbix-agentd 实战：TCP连接状态监控 状态码： 握手： 1-SYN_SENT 发送syn握手 2-LISTEN 监听 V 2-SYN_REVND 发送同步 1-ESTABLISHED 完成连接 2-ESTABLISHED 完成连接 数据传输： 1-write 2-read 挥手： 1-FIN_WAIT-1 开始等待1 2-CLOSE_WAIT 关闭等待 V 2-LAST_ACK 最后询问[若无回复,倒数秒表自动关闭] 1-FIN_WAIT-2 开始等待2 V 1-TIME_WAIT 2-TIME_WAIT 工具 netstat an 多少个连接 netstat -anpt | grep ESTABLISHED | wc -l agent： vim /etc/zabbix/zabbix_agentd.d/userparamenter_mysql.conf UserParameter=tcp.status.ESTABLISHED,netstat -anpt | grep ESTABLISHED | wc -l UserParameter=tcp.status.TIME_WAIT,netstat -anpt | grep TIME_WAIT | wc -l 实战：TCP连接状态监控2 agent: vim /etc/zabbix/zabbix_agentd.d/userparamenter_mysql.conf UserParameter=tcp.status.[*],netstat -anpt | grep \"$1\" | wc -l $1 = 前方第一个[方括号里的内容] 高级用法 vim /etc/zabbix/zabbix_agentd.conf中增加 UserParameter=tcp.status[*],/etc/zabbix/scripts/tcp_conn_status.sh $1 chmod a+x /etc/zabbix/scripts/tcp_conn_status.sh case $1 in closed) output=$(awk '/CLOSED/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; listen) output=$(awk '/LISTEN/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; synrecv) output=$(awk '/SYN_RECV/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; synsent) output=$(awk '/SYN_SENT/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; established) output=$(awk '/ESTABLISHED/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; timewait) output=$(awk '/TIME_WAIT/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; closing) output=$(awk '/CLOSING/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; closewait) output=$(awk '/CLOSE_WAIT/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; lastack) output=$(awk '/LAST_ACK/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; finwait1) output=$(awk '/FIN_WAIT1/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; finwait2) output=$(awk '/FIN_WAIT2/{print $2}' $tmp_file) if [ \"$output\" == \"\" ];then echo 0 else echo $output fi ;; *) echo -e \"\\e[033mUsage: sh $0 [closed|closing|closewait|synrecv|synsent|finwait1|finwait2|listen|established|lastack|timewait]\\e[0m\" Copyright © JokerDragon 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-04-25 13:41:09 "}}