# Lesson2: 算法的时间复杂度和空间复杂度

**实现目标**

> 算法效率
>
> 时间复杂度
>
> 空间复杂度
>
> 常见时间复杂度以及复杂度的练习

## 1. 算法效率

### 1.1 如何衡量一个算法的好坏

如何衡量一个算法的好坏呢？比如对于一下斐波那契数列：

```c
 long long Fib(int N):
{
	if(N < 3){
		//TODO
		return 1;
	}
	return Fib(N-1) + Fib(N-2)
}
```

斐波那契数列非常简洁，但简洁一定就好吗？那该如何衡量其好与坏的呢？

### 1.2 算法的复杂度

算法在编写成可执行程序后，运行时需要耗费时间资源和空间（内存）资源。因此 **衡量一个算法的好坏，一般是从空间和时间两个维度来衡量的**，即时间复杂度和空间复杂度。

**时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间**。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。

### 1.3 复杂度在校招中的考察

![image-20220702185337477](02-时间复杂度空间复杂度.assets/image-20220702185337477.png)



## 2.时间复杂度

### 2.1时间复杂度的概念

时间复杂度的定义： 在计算机科学中，**算法的时间复杂度是一个函数**，它定量描述了该算法的运行时间。一个算法执行所耗费的时间。从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上级测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，**算法的基本操作的执行次数，为算法的时间复杂度**

即： 找到某条基本语与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。



```bash
// 请算一下Func1中++count语句总共执行了多少次

#include<stdio.h>
 
 
void Func1(int N){
	int count =0;
	for(int i=0;i<=N;++i){
		for(int j=0;j<=N;++j){
			++count;
		}
	}
	
	for(int k=0;k <2;++k){
		++count;
	}
	
	int M=10;
	while(M--){
		++count;
	}
	printf("%d\n", count);
}

```



